


SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE EXTENSION IF NOT EXISTS "pg_cron" WITH SCHEMA "pg_catalog";






COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "moddatetime" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE TYPE "public"."court_status_enum" AS ENUM (
    'open',
    'in_session',
    'adjourned',
    'closed'
);


ALTER TYPE "public"."court_status_enum" OWNER TO "postgres";


CREATE TYPE "public"."provider_cost" AS ENUM (
    'livekit',
    'supabase',
    'fastly',
    'vercel',
    'paypal',
    'ionos',
    'openai'
);


ALTER TYPE "public"."provider_cost" OWNER TO "postgres";


CREATE TYPE "public"."provider_enum" AS ENUM (
    'livekit',
    'supabase',
    'fastly',
    'vercel',
    'paypal',
    'ionos'
);


ALTER TYPE "public"."provider_enum" OWNER TO "postgres";


CREATE TYPE "public"."provider_status_enum" AS ENUM (
    'ok',
    'warning',
    'action_needed'
);


ALTER TYPE "public"."provider_status_enum" OWNER TO "postgres";


CREATE TYPE "public"."reward_status_enum" AS ENUM (
    'pending',
    'eligible',
    'paid',
    'revoked'
);


ALTER TYPE "public"."reward_status_enum" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_is_court_admin"() RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT EXISTS (
    SELECT 1
    FROM user_profiles up
    WHERE up.id = auth.uid()
      AND (up.role = 'admin'
           OR up.role = 'lead_troll_officer'
           OR up.is_admin = true)
  );
$$;


ALTER FUNCTION "public"."_is_court_admin"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_mai_block_mutations"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  RAISE EXCEPTION 'MAI timeline is immutable';
END;
$$;


ALTER FUNCTION "public"."_mai_block_mutations"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_mai_gift_abuse_trigger"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_recent_count integer := 0;
  v_recent_sum bigint := 0;
BEGIN
  -- Self-gifting is disallowed or suspicious.
  IF NEW.sender_id IS NOT NULL
     AND NEW.receiver_id IS NOT NULL
     AND NEW.sender_id = NEW.receiver_id THEN

    PERFORM public.mai_flag_economy_abuse(
      NEW.sender_id,
      'self_gifting',
      0.95,
      jsonb_build_object(
        'gift_id', NEW.id,
        'coins_spent', NEW.coins_spent,
        'stream_id', NEW.stream_id
      ),
      NEW.receiver_id,
      NEW.stream_id
    );

    RETURN NEW;
  END IF;

  -- Rapid pair gifting: many gifts to the same receiver in a short window.
  IF NEW.sender_id IS NOT NULL AND NEW.receiver_id IS NOT NULL THEN
    SELECT
      COUNT(*)::int,
      COALESCE(SUM(coins_spent), 0)::bigint
    INTO
      v_recent_count,
      v_recent_sum
    FROM public.gifts g
    WHERE g.sender_id = NEW.sender_id
      AND g.receiver_id = NEW.receiver_id
      AND g.created_at >= (now() - interval '10 minutes');

    IF v_recent_count >= 25 AND v_recent_sum >= 25000 THEN
      PERFORM public.mai_flag_economy_abuse(
        NEW.sender_id,
        'rapid_pair_gifting',
        0.90,
        jsonb_build_object(
          'gift_id', NEW.id,
          'pair_count_10m', v_recent_count,
          'pair_sum_10m', v_recent_sum,
          'stream_id', NEW.stream_id
        ),
        NEW.receiver_id,
        NEW.stream_id
      );
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."_mai_gift_abuse_trigger"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."activate_entrance_effect"("p_user_id" "uuid", "p_effect_id" "text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
begin
  if not exists (
    select 1 from user_entrance_effects
    where user_id = p_user_id and effect_id = p_effect_id
  ) then
    raise exception 'User does not own this entrance effect';
  end if;

  -- Set active entrance
  insert into user_active_entrance_effect (user_id, effect_id, activated_at)
  values (p_user_id, p_effect_id, now())
  on conflict (user_id)
  do update set effect_id = excluded.effect_id,
                activated_at = now();

  -- Update profile for fast lookup
  update user_profiles
  set active_entrance_effect_id = p_effect_id
  where id = p_user_id;
end;
$$;


ALTER FUNCTION "public"."activate_entrance_effect"("p_user_id" "uuid", "p_effect_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."activate_item"("p_user_id" "uuid", "p_item_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
declare
  v_type text;
  v_duration int;
begin
  -- get item details
  select item_type, duration_minutes
  into v_type, v_duration
  from store_items
  where id = p_item_id
  and is_active = true;

  if v_type is null then
    raise exception 'Item not found or inactive';
  end if;

  -- Deactivate previous active item of same type
  update user_active_items
  set is_active = false
  where user_id = p_user_id
  and item_type = v_type
  and is_active = true;

  -- Insert new active
  insert into user_active_items (user_id, item_id, item_type, activated_at, expires_at, is_active)
  values (
    p_user_id,
    p_item_id,
    v_type,
    now(),
    case
      when v_duration is null then null
      else now() + make_interval(mins => v_duration)
    end,
    true
  );

end;
$$;


ALTER FUNCTION "public"."activate_item"("p_user_id" "uuid", "p_item_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."activate_perk"("p_user_id" "uuid", "p_perk_id" "text") RETURNS timestamp with time zone
    LANGUAGE "plpgsql"
    AS $$
declare
  v_duration int;
  v_expires timestamptz;
  v_effect text;
begin
  -- Load perk duration and username effect if any
  select duration_minutes,
         (metadata->>'username_effect')
  into v_duration, v_effect
  from perk_catalog
  where id = p_perk_id
  and is_enabled = true;

  if v_duration is null then
    raise exception 'Perk not found or disabled';
  end if;

  v_expires := now() + make_interval(mins => v_duration);

  -- Mark previous same perk inactive (optional cleanup)
  update user_perks
  set is_active = false
  where user_id = p_user_id
  and perk_id = p_perk_id
  and is_active = true;

  -- Insert new activation record
  insert into user_perks (user_id, perk_id, purchased_at, expires_at, is_active)
  values (p_user_id, p_perk_id, now(), v_expires, true);

  -- If perk affects username, apply the effect
  if v_effect is not null then
    -- Deactivate other username cosmetic perks for same user
    update user_perks up
    set is_active = false
    where up.user_id = p_user_id
      and up.is_active = true
      and up.perk_id in ('perk_rgb_username','perk_global_highlight','perk_flex_banner')
      and up.perk_id <> p_perk_id;

    -- Update profile with effect
    update user_profiles
    set username_effect = v_effect,
        username_effect_expires_at = v_expires
    where id = p_user_id;
  end if;

  return v_expires;
end;
$$;


ALTER FUNCTION "public"."activate_perk"("p_user_id" "uuid", "p_perk_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."activate_perk"("p_user_id" "uuid", "p_perk_id" "text", "p_duration_minutes" integer DEFAULT 30) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_expires_at TIMESTAMPTZ;
  v_perk_record UUID;
BEGIN
  -- Calculate expiry time
  v_expires_at := NOW() + (p_duration_minutes || ' minutes')::INTERVAL;

  -- Insert or update perk record
  INSERT INTO user_perks (
    user_id,
    perk_id,
    expires_at,
    is_active,
    activated_at
  ) VALUES (
    p_user_id,
    p_perk_id,
    v_expires_at,
    true,
    NOW()
  )
  ON CONFLICT (user_id, perk_id, expires_at) DO UPDATE
  SET 
    is_active = true,
    activated_at = NOW(),
    updated_at = NOW()
  RETURNING id INTO v_perk_record;

  RETURN jsonb_build_object(
    'success', true,
    'perk_id', p_perk_id,
    'expires_at', v_expires_at,
    'record_id', v_perk_record
  );
END;
$$;


ALTER FUNCTION "public"."activate_perk"("p_user_id" "uuid", "p_perk_id" "text", "p_duration_minutes" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."activate_perk"("p_user_id" "uuid", "p_perk_id" "text", "p_duration_minutes" integer) IS 'Activates a perk for a user with specified duration';



CREATE OR REPLACE FUNCTION "public"."activate_store_item"("p_user_id" "uuid", "p_item_id" "text") RETURNS timestamp with time zone
    LANGUAGE "plpgsql"
    AS $$
declare
  v_category text;
  v_duration int;
  v_expires timestamptz;
begin
  select category, duration_minutes
  into v_category, v_duration
  from store_items
  where id = p_item_id and is_enabled = true;

  if v_category is null then
    raise exception 'Item not found or disabled';
  end if;

  v_expires := case 
    when v_duration is null then null
    else now() + make_interval(mins => v_duration)
  end;

  -- if insurance, deactivate old insurance
  if v_category = 'insurance' then
    update user_active_items
    set is_active = false
    where user_id = p_user_id
      and category = 'insurance'
      and is_active = true;
  end if;

  insert into user_active_items (user_id, item_id, category, activated_at, expires_at, is_active)
  values (p_user_id, p_item_id, v_category, now(), v_expires, true);

  return v_expires;
end;
$$;


ALTER FUNCTION "public"."activate_store_item"("p_user_id" "uuid", "p_item_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_call_minutes"("p_user_id" "uuid", "p_minutes" integer, "p_type" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_current_audio INTEGER := 0;
  v_current_video INTEGER := 0;
BEGIN
  -- Get current balance (handle no row case)
  SELECT COALESCE(audio_minutes, 0), COALESCE(video_minutes, 0)
  INTO v_current_audio, v_current_video
  FROM call_minutes
  WHERE user_id = p_user_id;

  -- Update or insert
  IF NOT FOUND THEN
    INSERT INTO call_minutes (user_id, audio_minutes, video_minutes, updated_at)
    VALUES (
      p_user_id,
      CASE WHEN p_type = 'audio' THEN p_minutes ELSE 0 END,
      CASE WHEN p_type = 'video' THEN p_minutes ELSE 0 END,
      NOW()
    )
    ON CONFLICT (user_id) DO UPDATE
    SET 
      audio_minutes = call_minutes.audio_minutes + CASE WHEN p_type = 'audio' THEN p_minutes ELSE 0 END,
      video_minutes = call_minutes.video_minutes + CASE WHEN p_type = 'video' THEN p_minutes ELSE 0 END,
      updated_at = NOW();
      
    -- Re-fetch to be sure
    SELECT COALESCE(audio_minutes, 0), COALESCE(video_minutes, 0)
    INTO v_current_audio, v_current_video
    FROM call_minutes
    WHERE user_id = p_user_id;
  ELSE
    UPDATE call_minutes
    SET 
      audio_minutes = CASE WHEN p_type = 'audio' THEN audio_minutes + p_minutes ELSE audio_minutes END,
      video_minutes = CASE WHEN p_type = 'video' THEN video_minutes + p_minutes ELSE video_minutes END,
      updated_at = NOW()
    WHERE user_id = p_user_id
    RETURNING audio_minutes, video_minutes INTO v_current_audio, v_current_video;
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'audio_minutes', v_current_audio,
    'video_minutes', v_current_video
  );
END;
$$;


ALTER FUNCTION "public"."add_call_minutes"("p_user_id" "uuid", "p_minutes" integer, "p_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_earned_coins"("user_id" "uuid", "coins" integer) RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  update user_profiles
  set earned_coin_balance = earned_coin_balance + coins,
      total_earned_coins = total_earned_coins + coins
  where id = user_id;
end;
$$;


ALTER FUNCTION "public"."add_earned_coins"("user_id" "uuid", "coins" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_free_coins"("p_user_id" "uuid", "p_amount" bigint) RETURNS "void"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  UPDATE user_profiles SET free_coin_balance = free_coin_balance + p_amount, updated_at = now() WHERE id = p_user_id;
$$;


ALTER FUNCTION "public"."add_free_coins"("p_user_id" "uuid", "p_amount" bigint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_paid_coins"("user_id_input" "uuid", "coins_to_add" integer) RETURNS "void"
    LANGUAGE "sql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
  UPDATE user_profiles
  SET paid_coin_balance = COALESCE(paid_coin_balance, 0) + coins_to_add
  WHERE id = user_id_input;
$$;


ALTER FUNCTION "public"."add_paid_coins"("user_id_input" "uuid", "coins_to_add" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_stream_xp"("p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
    -- Security check: Ensure user is updating themselves
    IF auth.uid() != p_user_id THEN
        RETURN jsonb_build_object('success', false, 'reason', 'unauthorized');
    END IF;

    -- Award 20 XP (Streaming has no hard daily cap in add_xp currently, which is intended)
    RETURN add_xp(p_user_id, 20, 'stream');
END;
$$;


ALTER FUNCTION "public"."add_stream_xp"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_troll_coins"("user_id_input" "uuid", "coins_to_add" integer) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE user_profiles
  SET 
    troll_coins = COALESCE(troll_coins, 0) + coins_to_add,
    total_earned_coins = COALESCE(total_earned_coins, 0) + coins_to_add,
    updated_at = NOW()
  WHERE id = user_id_input;
END;
$$;


ALTER FUNCTION "public"."add_troll_coins"("user_id_input" "uuid", "coins_to_add" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_watch_xp"("p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
    -- Security check: Ensure user is updating themselves
    IF auth.uid() != p_user_id THEN
        RETURN jsonb_build_object('success', false, 'reason', 'unauthorized');
    END IF;

    -- Award 5 XP (Logic in add_xp handles the daily cap of 60)
    RETURN add_xp(p_user_id, 5, 'watch');
END;
$$;


ALTER FUNCTION "public"."add_watch_xp"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_xp"("p_user_id" "uuid", "p_amount" integer) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_current_xp INTEGER;
BEGIN
  SELECT xp INTO v_current_xp
  FROM user_profiles
  WHERE id = p_user_id;

  IF v_current_xp IS NULL THEN
    v_current_xp := 0;
  END IF;

  UPDATE user_profiles
  SET xp = v_current_xp + p_amount
  WHERE id = p_user_id;

  RETURN jsonb_build_object(
    'success', TRUE,
    'new_xp', v_current_xp + p_amount
  );
END;
$$;


ALTER FUNCTION "public"."add_xp"("p_user_id" "uuid", "p_amount" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_xp"("p_user_id" "uuid", "p_amount" integer, "p_reason" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
begin
  -- your update logic
end;
$$;


ALTER FUNCTION "public"."add_xp"("p_user_id" "uuid", "p_amount" integer, "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."adjust_balance"("p_user_id" "uuid", "p_currency" "text", "p_amount" bigint, "p_event" "text") RETURNS TABLE("troll_coins" bigint, "trollmonds" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  if p_currency not in ('troll_coins','trollmonds') then
    raise exception 'Invalid currency. Only troll_coins and trollmonds allowed.';
  end if;

  if p_currency = 'troll_coins' then
    update user_balances
    set troll_coins = troll_coins + p_amount,
        updated_at = now()
    where user_id = p_user_id;

  else
    update user_balances
    set trollmonds = trollmonds + p_amount,
        updated_at = now()
    where user_id = p_user_id;
  end if;

  insert into balance_ledger(user_id, currency, amount, event)
  values (p_user_id, p_currency, p_amount, p_event);

  return query
  select ub.troll_coins, ub.trollmonds
  from user_balances ub
  where ub.user_id = p_user_id;
end;
$$;


ALTER FUNCTION "public"."adjust_balance"("p_user_id" "uuid", "p_currency" "text", "p_amount" bigint, "p_event" "text") OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";

CREATE OR REPLACE FUNCTION public.increment_gift_vote_count(p_gift_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public', 'extensions'
AS $$
BEGIN
  UPDATE user_gifts
  SET vote_count = vote_count + 1,
      updated_at = now()
  WHERE id = p_gift_id;
END;
$$;


CREATE TABLE IF NOT EXISTS "public"."payout_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "coin_amount" bigint DEFAULT 7000 NOT NULL,
    "cash_amount" numeric(12,2) DEFAULT 0,
    "currency" "text" DEFAULT 'USD'::"text",
    "processing_fee" numeric(12,2) DEFAULT 0,
    "status" "text" DEFAULT 'pending'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "receipt_url" "text",
    "approved_at" timestamp with time zone,
    "approved_by" "text",
    "coins_redeemed" bigint,
    "admin_id" "uuid",
    "processed_at" timestamp with time zone,
    "notes" "text",
    "paypal_payout_id" "text",
    "paypal_email" "text",
    "provider_type" "text",
    "provider_username" "text",
    "amount_usd" numeric(10,2) DEFAULT 0,
    "requested_coins" bigint DEFAULT 0,
    "is_sent" boolean DEFAULT false,
    "requested_at" timestamp with time zone DEFAULT "now"(),
    "processed_by" "uuid",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "idempotency_key" "text",
    "coins_reserved" boolean DEFAULT false NOT NULL,
    "paypal_sender_batch_id" "text",
    "rejection_reason" "text",
    "payment_method" "text",
    "payment_reference" "text",
    "paid_at" timestamp with time zone,
    "coins_used" integer,
    "net_amount" numeric(10,2),
    "paypal_batch_id" "text",
    "paypal_batch_status" "text",
    CONSTRAINT "payout_requests_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'paid'::"text", 'rejected'::"text"])))
);

ALTER TABLE ONLY "public"."payout_requests" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."payout_requests" OWNER TO "postgres";


COMMENT ON COLUMN "public"."payout_requests"."paypal_email" IS 'PayPal email for payout destination';



CREATE OR REPLACE FUNCTION "public"."admin_approve_payout"("p_payout_id" "uuid") RETURNS "public"."payout_requests"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  payout payout_requests;
BEGIN
  SELECT *
  INTO payout
  FROM payout_requests
  WHERE id = p_payout_id
    AND status = 'pending'
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Payout not found or not pending';
  END IF;

  UPDATE payout_requests
  SET
    status = 'approved',
    processed_by = auth.uid(),
    processed_at = now()
  WHERE id = p_payout_id
  RETURNING * INTO payout;

  RETURN payout;
END;
$$;


ALTER FUNCTION "public"."admin_approve_payout"("p_payout_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_end_shift"("p_shift_id" "uuid", "p_reason" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_shift RECORD;
  v_hours_worked NUMERIC;
  v_coins_earned INTEGER;
BEGIN
  -- Get shift details
  SELECT * INTO v_shift
  FROM officer_shift_logs
  WHERE id = p_shift_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Shift not found');
  END IF;

  -- Check if shift is already ended
  IF v_shift.clock_out IS NOT NULL THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Shift already ended');
  END IF;

  -- Calculate hours worked
  v_hours_worked := EXTRACT(EPOCH FROM (NOW() - v_shift.clock_in)) / 3600.0;

  -- Calculate coins (100 coins per hour, minimum 1 hour)
  v_coins_earned := GREATEST(100, FLOOR(v_hours_worked * 100));

  -- Update shift log
  UPDATE officer_shift_logs
  SET 
    clock_out = NOW(),
    hours_worked = v_hours_worked,
    coins_earned = v_coins_earned,
    auto_clocked_out = TRUE, -- Mark as admin-ended
    updated_at = NOW()
  WHERE id = p_shift_id;

  -- Credit coins to officer
  UPDATE user_profiles
  SET 
    troll_coins = COALESCE(troll_coins, 0) + v_coins_earned,
    updated_at = NOW()
  WHERE id = v_shift.officer_id;

  RETURN jsonb_build_object(
    'success', TRUE,
    'hours_worked', v_hours_worked,
    'coins_earned', v_coins_earned,
    'message', 'Shift ended successfully'
  );
END;
$$;


ALTER FUNCTION "public"."admin_end_shift"("p_shift_id" "uuid", "p_reason" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."admin_end_shift"("p_shift_id" "uuid", "p_reason" "text") IS 'Allows admins to end officer shifts and calculate earnings';



CREATE OR REPLACE FUNCTION "public"."admin_execute_action"("p_action" "text", "p_target_user" "uuid", "p_amount" integer, "p_admin_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_is_admin BOOLEAN;
BEGIN
  -- Verify admin server-side
  SELECT (role = 'admin') INTO v_is_admin
  FROM user_profiles
  WHERE id = p_admin_id;

  IF NOT v_is_admin THEN
    RAISE EXCEPTION 'Unauthorized: Not an admin';
  END IF;

  --------------------------------------------------------------------
  -- ACTION: GRANT COINS
  --------------------------------------------------------------------
  IF p_action = 'grant_coins' THEN
    UPDATE user_profiles
    SET coin_balance = coin_balance + p_amount
    WHERE id = p_target_user;

    INSERT INTO coin_transactions (id, user_id, amount, type, status)
    VALUES (gen_random_uuid(), p_target_user, p_amount, 'admin_grant', 'success');

    RETURN 'Coins granted';
  END IF;


  --------------------------------------------------------------------
  -- ACTION: ZERO COINS
  --------------------------------------------------------------------
  IF p_action = 'zero_coins' THEN
    UPDATE user_profiles
    SET coin_balance = 0
    WHERE id = p_target_user;

    RETURN 'Coin balance reset';
  END IF;


  --------------------------------------------------------------------
  -- ACTION: SET USER LEVEL
  --------------------------------------------------------------------
  IF p_action = 'set_user_level' THEN
    UPDATE user_profiles
    SET user_level = p_amount
    WHERE id = p_target_user;

    RETURN 'User level updated';
  END IF;


  --------------------------------------------------------------------
  -- ACTION: APPROVE OFFICER APPLICATION
  --------------------------------------------------------------------
  IF p_action = 'approve_application' THEN
    UPDATE officer_applications
    SET status = 'approved'
    WHERE user_id = p_target_user;

    UPDATE user_profiles
    SET role = 'officer'
    WHERE id = p_target_user;

    RETURN 'Officer approved';
  END IF;


  --------------------------------------------------------------------
  -- ACTION: REJECT OFFICER APPLICATION
  --------------------------------------------------------------------
  IF p_action = 'reject_application' THEN
    UPDATE officer_applications
    SET status = 'rejected'
    WHERE user_id = p_target_user;

    RETURN 'Officer rejected';
  END IF;


  --------------------------------------------------------------------
  -- ACTION: GIFT COINS TO ALL USERS
  --------------------------------------------------------------------
  IF p_action = 'gift_all' THEN
    UPDATE user_profiles
    SET coin_balance = coin_balance + p_amount;

    RETURN 'Coins granted to all users';
  END IF;

  RETURN 'Invalid admin action';
END;
$$;


ALTER FUNCTION "public"."admin_execute_action"("p_action" "text", "p_target_user" "uuid", "p_amount" integer, "p_admin_id" "uuid") OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_shift_logs" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "officer_id" "uuid",
    "hours_worked" numeric,
    "coins_earned" integer,
    "paid" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "last_activity" timestamp with time zone DEFAULT "now"(),
    "auto_clocked_out" boolean DEFAULT false,
    "shift_slot_id" "uuid",
    "clock_in_time" timestamp with time zone,
    "clock_out_time" timestamp with time zone,
    "clock_in" timestamp with time zone,
    "clock_out" timestamp with time zone,
    "shift_start" timestamp with time zone DEFAULT "now"() NOT NULL,
    "shift_end" timestamp with time zone
);

ALTER TABLE ONLY "public"."officer_shift_logs" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_shift_logs" OWNER TO "postgres";


COMMENT ON TABLE "public"."officer_shift_logs" IS 'Tracks officer work shifts, hours worked, and coins earned. Auto-clocks out after 6 hours or 30 minutes of inactivity.';



COMMENT ON COLUMN "public"."officer_shift_logs"."clock_in" IS 'Timestamp when shift started (clock in)';



COMMENT ON COLUMN "public"."officer_shift_logs"."clock_out" IS 'Timestamp when shift ended (clock out, null if active)';



CREATE TABLE IF NOT EXISTS "public"."user_profiles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "username" "text" DEFAULT ('user'::"text" || "substr"(("gen_random_uuid"())::"text", 1, 8)) NOT NULL,
    "avatar_url" "text",
    "bio" "text",
    "role" "text" DEFAULT 'user'::"text",
    "tier" "text" DEFAULT 'Bronze'::"text",
    "total_earned_coins" bigint DEFAULT 0 NOT NULL,
    "total_spent_coins" bigint DEFAULT 0 NOT NULL,
    "insurance_level" "text",
    "insurance_expires_at" timestamp with time zone,
    "no_kick_until" timestamp with time zone,
    "no_ban_until" timestamp with time zone,
    "platform_fee_last_charged" timestamp with time zone,
    "sav_bonus_coins" integer DEFAULT 0 NOT NULL,
    "has_crown_badge" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "insurance_type" "text",
    "badge" "text",
    "has_insurance" boolean DEFAULT false,
    "multiplier_active" boolean DEFAULT false,
    "multiplier_value" numeric DEFAULT 1,
    "multiplier_expires" timestamp with time zone,
    "terms_accepted" boolean DEFAULT false,
    "payout_method" "text",
    "payout_details" "text",
    "legal_first_name" "text",
    "legal_last_name" "text",
    "date_of_birth" "date",
    "country" "text",
    "street_address" "text",
    "city" "text",
    "state" "text",
    "postal_code" "text",
    "phone_number" "text",
    "payout_handle" "text",
    "tax_status" "text",
    "is_creator_onboarded" boolean DEFAULT false NOT NULL,
    "onboarded_at" timestamp with time zone,
    "total_earned_usd" numeric(10,2) DEFAULT 0,
    "last_payout_at" timestamp with time zone,
    "lifetime_payout_total" numeric(10,2) DEFAULT 0,
    "is_troll_officer" boolean DEFAULT false,
    "officer_level" integer DEFAULT 1,
    "is_og_user" boolean DEFAULT false,
    "is_admin" boolean DEFAULT false,
    "is_troller" boolean DEFAULT false,
    "troller_level" integer DEFAULT 1,
    "is_banned" boolean DEFAULT false,
    "banned_until" timestamp with time zone,
    "last_known_ip" "inet",
    "ip_address_history" "jsonb" DEFAULT '[]'::"jsonb",
    "is_broadcaster" boolean DEFAULT true NOT NULL,
    "preferred_payout_method" "text",
    "payout_destination_masked" "text",
    "is_empire_partner" boolean DEFAULT false,
    "is_og" boolean DEFAULT false,
    "is_officer" boolean DEFAULT false,
    "is_recruiter" boolean DEFAULT false,
    "address_line1" "text",
    "legal_full_name" "text",
    "state_region" "text",
    "tax_id_last4" "text",
    "tax_classification" "text" DEFAULT 'individual'::"text",
    "w9_status" "text" DEFAULT 'not_submitted'::"text",
    "w9_verified_at" timestamp with time zone,
    "address_line2" "text",
    "profile_view_price" integer DEFAULT 0,
    "is_lead_officer" boolean DEFAULT false,
    "payout_paypal_email" "text",
    "officer_reputation_score" integer DEFAULT 100,
    "is_ghost_mode" boolean DEFAULT false,
    "is_verified" boolean DEFAULT false,
    "verification_date" timestamp with time zone,
    "verification_paid_amount" numeric(6,2),
    "verification_payment_method" "text",
    "ban_expires_at" timestamp with time zone,
    "influencer_tier" "text",
    "profile_banner_url" "text",
    "profile_theme" "text",
    "officer_tier_badge" "text" DEFAULT 'blue'::"text",
    "owc_balance" bigint DEFAULT 0,
    "total_owc_earned" bigint DEFAULT 0,
    "officer_role" "text" DEFAULT 'officer'::"text",
    "is_officer_active" boolean DEFAULT false NOT NULL,
    "email" "text",
    "ban_reason" "text",
    "total_coins_earned" bigint DEFAULT 0,
    "total_coins_spent" bigint DEFAULT 0,
    "empire_role" "text",
    "level" integer DEFAULT 1,
    "xp" bigint DEFAULT 0,
    "is_test_user" boolean DEFAULT false,
    "active_entrance_effect" "text",
    "application_status" "text" DEFAULT 'pending'::"text",
    "app_access_enabled" boolean DEFAULT false,
    "bonus_coin_balance" bigint DEFAULT 0 NOT NULL,
    "troll_pass_expires_at" timestamp with time zone,
    "troll_pass_last_purchased_at" timestamp with time zone,
    "has_troll_pass" boolean DEFAULT false,
    "account_state" "text" DEFAULT 'normal'::"text" NOT NULL,
    "payout_frozen" boolean DEFAULT false NOT NULL,
    "payout_freeze_reason" "text",
    "payout_freeze_at" timestamp with time zone,
    "creator_trust_score" integer DEFAULT 100 NOT NULL,
    "birthday_coins_awarded_date" "date",
    "ghost_mode_expires_at" timestamp with time zone,
    "message_price" integer DEFAULT 0 NOT NULL,
    "message_requests_enabled" boolean DEFAULT false,
    "court_recording_consent" boolean DEFAULT false,
    "court_recording_consent_at" timestamp with time zone,
    "application_required" boolean DEFAULT false,
    "application_submitted" boolean DEFAULT false,
    "is_employee" boolean DEFAULT false,
    "employee_role" "text",
    "hire_date" "date",
    "verified_birthday" boolean DEFAULT false,
    "last_birthday_award" "date",
    "kick_count" integer DEFAULT 0,
    "last_kicked_at" timestamp with time zone,
    "is_kicked" boolean DEFAULT false,
    "kicked_until" timestamp with time zone,
    "account_deleted_at" timestamp with time zone,
    "account_deletion_cooldown_until" timestamp with time zone,
    "account_reset_after_ban" boolean DEFAULT false,
    "empire_partner" boolean DEFAULT false NOT NULL,
    "partner_status" "text",
    "entrance_effect_key" "text",
    "earned_coins" integer DEFAULT 0,
    "last_birthday_coins_awarded" timestamp with time zone,
    "coin_balance" bigint DEFAULT 0 NOT NULL,
    "free_coin_balance" bigint DEFAULT 0 NOT NULL,
    "troll_role" "text",
    "user_id" "uuid",
    "rgb_username_expires_at" timestamp with time zone,
    "rgb_username_enabled" boolean DEFAULT false,
    "entrance_effects" "jsonb" DEFAULT '[]'::"jsonb",
    "reserved_paid_coins" bigint DEFAULT 0,
    "reserved_troll_coins" bigint DEFAULT 0,
    "id_document_url" "text",
    "id_uploaded_at" timestamp with time zone,
    "id_verification_status" "text" DEFAULT 'not_submitted'::"text",
    "full_name" "text",
    "founder_badge" boolean DEFAULT false,
    "boosted_until" timestamp with time zone,
    "reduced_fees_until" timestamp with time zone,
    "verified_creator" boolean DEFAULT false,
    "onboarding_completed" boolean DEFAULT false NOT NULL,
    "total_xp" bigint DEFAULT 0,
    "prestige" integer DEFAULT 0,
    "xp_multiplier" numeric DEFAULT 1.0,
    "coin_multiplier" numeric(4,2) DEFAULT 1.0,
    "rank" character varying(50) DEFAULT NULL::character varying,
    "vived_bonus_coins" integer DEFAULT 0 NOT NULL,
    "og_badge" boolean DEFAULT false,
    "preferred_language" "text" DEFAULT 'en'::"text",
    "seller_verified" boolean DEFAULT false,
    "gender" character varying(10),
    "court_reputation_score" integer DEFAULT 100,
    "muted_until" timestamp with time zone,
    "trollmonds" bigint DEFAULT 0 NOT NULL,
    "troll_coins" integer DEFAULT 0,
    "username_effect" "text",
    "username_effect_expires_at" timestamp with time zone,
    "active_entrance_effect_id" "text",
    "paid_coins" integer DEFAULT 0,
    "has_paid" boolean DEFAULT false NOT NULL,
    "first_seen_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "mic_muted_until" timestamp with time zone,
    "live_restricted_until" timestamp with time zone,
    "banner_url" "text",
    CONSTRAINT "check_empire_role" CHECK ((("empire_role" IS NULL) OR ("empire_role" = 'partner'::"text"))),
    CONSTRAINT "user_profiles_account_state_check" CHECK (("account_state" = ANY (ARRAY['normal'::"text", 'warned'::"text", 'restricted'::"text", 'jailed'::"text", 'banned'::"text", 'exiled'::"text"]))),
    CONSTRAINT "user_profiles_application_status_check" CHECK (("application_status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text"]))),
    CONSTRAINT "user_profiles_bonus_coin_balance_check" CHECK (("bonus_coin_balance" >= 0)),
    CONSTRAINT "user_profiles_court_reputation_score_check" CHECK (("court_reputation_score" >= 0)),
    CONSTRAINT "user_profiles_creator_trust_score_check" CHECK ((("creator_trust_score" >= 0) AND ("creator_trust_score" <= 100))),
    CONSTRAINT "user_profiles_gender_check" CHECK ((("gender")::"text" = ANY ((ARRAY['male'::character varying, 'female'::character varying])::"text"[]))),
    CONSTRAINT "user_profiles_id_verification_status_check" CHECK (("id_verification_status" = ANY (ARRAY['not_submitted'::"text", 'pending'::"text", 'approved'::"text", 'rejected'::"text"]))),
    CONSTRAINT "user_profiles_influencer_tier_check" CHECK (("influencer_tier" = ANY (ARRAY['basic'::"text", 'gold'::"text", 'platinum'::"text"]))),
    CONSTRAINT "user_profiles_officer_level_check" CHECK ((("officer_level" >= 1) AND ("officer_level" <= 5))),
    CONSTRAINT "user_profiles_officer_tier_badge_check" CHECK (("officer_tier_badge" = ANY (ARRAY['blue'::"text", 'orange'::"text", 'red'::"text"]))),
    CONSTRAINT "user_profiles_role_check" CHECK (("role" = ANY (ARRAY['user'::"text", 'moderator'::"text", 'admin'::"text", 'hr_admin'::"text", 'lead_troll_officer'::"text", 'troll_officer'::"text", 'troll_family'::"text", 'troller'::"text", 'empire_partner'::"text", 'secretary'::"text", 'broadcaster'::"text", 'family_leader'::"text", 'member'::"text", 'guest'::"text"]))),
    CONSTRAINT "user_profiles_sav_bonus_coins_check" CHECK (("sav_bonus_coins" >= 0)),
    CONSTRAINT "user_profiles_troll_coins_check" CHECK (("troll_coins" >= 0)),
    CONSTRAINT "user_profiles_vived_bonus_coins_check" CHECK (("vived_bonus_coins" >= 0))
);

ALTER TABLE ONLY "public"."user_profiles" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_profiles" OWNER TO "postgres";


COMMENT ON TABLE "public"."user_profiles" IS 'User profiles with paid_coins and trollmonds balances';



COMMENT ON COLUMN "public"."user_profiles"."is_troll_officer" IS 'Whether user is a troll officer';



COMMENT ON COLUMN "public"."user_profiles"."officer_level" IS 'Officer rank: 1=Officer, 2=Senior Officer, 3=Commander';



COMMENT ON COLUMN "public"."user_profiles"."is_og_user" IS 'OG status - automatically assigned based on join date (before 2026-01-01). Immutable and permanent.';



COMMENT ON COLUMN "public"."user_profiles"."is_admin" IS 'Whether user is an admin (highest privilege level)';



COMMENT ON COLUMN "public"."user_profiles"."is_troller" IS 'Whether user is a troller (chaos/mischief identity, no moderation powers)';



COMMENT ON COLUMN "public"."user_profiles"."troller_level" IS 'Troller rank: 1=Basic Troller, 2=Chaos Agent, 3=Supreme Troll';



COMMENT ON COLUMN "public"."user_profiles"."is_empire_partner" IS 'Indicates if user is an approved Empire Partner eligible for referral bonuses';



COMMENT ON COLUMN "public"."user_profiles"."is_lead_officer" IS 'True if user is a lead officer';



COMMENT ON COLUMN "public"."user_profiles"."payout_paypal_email" IS 'PayPal email address for receiving payouts';



COMMENT ON COLUMN "public"."user_profiles"."officer_role" IS 'Officer role: lead_officer, owner, or null';



COMMENT ON COLUMN "public"."user_profiles"."is_officer_active" IS 'Indicates if officer has completed orientation and is active';



COMMENT ON COLUMN "public"."user_profiles"."empire_role" IS 'Empire partner role: partner or null';



COMMENT ON COLUMN "public"."user_profiles"."court_recording_consent" IS 'User consent for TrollCourt recording';



COMMENT ON COLUMN "public"."user_profiles"."court_recording_consent_at" IS 'Timestamp when user accepted TrollCourt recording consent';



COMMENT ON COLUMN "public"."user_profiles"."rank" IS 'Troll Family rank: Tiny Troller, Gang Troller, OG Troller, Old Ass Troller, Dead Troller, Graveyard';



COMMENT ON COLUMN "public"."user_profiles"."preferred_language" IS 'User preferred language code (en, es, ar, fr, fil, etc.) for translations';



COMMENT ON COLUMN "public"."user_profiles"."seller_verified" IS 'Indicates if user has been approved as a seller and can create/manage shops';



CREATE OR REPLACE VIEW "public"."officer_shift_logs_view" WITH ("security_invoker"='true') AS
 SELECT "osl"."id",
    "osl"."officer_id",
    "osl"."shift_slot_id",
    "osl"."clock_in_time",
    "osl"."clock_out_time",
    "osl"."hours_worked",
    "osl"."coins_earned",
    "osl"."paid",
    "up"."username",
    "au"."email"
   FROM (("public"."officer_shift_logs" "osl"
     JOIN "public"."user_profiles" "up" ON (("up"."id" = "osl"."officer_id")))
     JOIN "auth"."users" "au" ON (("au"."id" = "osl"."officer_id")));


ALTER VIEW "public"."officer_shift_logs_view" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_get_officer_shift_logs"() RETURNS SETOF "public"."officer_shift_logs_view"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT *
  FROM public.officer_shift_logs_view;
$$;


ALTER FUNCTION "public"."admin_get_officer_shift_logs"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_grant_coins"("p_user_id" "uuid", "p_amount" integer, "p_admin_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_is_admin BOOLEAN;
BEGIN
  -- Verify admin via database (cannot be spoofed)
  SELECT (role = 'admin') INTO v_is_admin
  FROM user_profiles
  WHERE id = p_admin_id;

  IF NOT v_is_admin THEN
    RAISE EXCEPTION 'Unauthorized: Only admin can grant coins.';
  END IF;

  -- Grant coins
  UPDATE user_profiles
  SET coin_balance = coin_balance + p_amount
  WHERE id = p_user_id;

  -- Log the transaction
  INSERT INTO coin_transactions (
    id, user_id, amount, type, status, created_at
  ) VALUES (
    gen_random_uuid(), p_user_id, p_amount, 'admin_grant', 'success', NOW()
  );

  RETURN 'Coins granted successfully.';
END;
$$;


ALTER FUNCTION "public"."admin_grant_coins"("p_user_id" "uuid", "p_amount" integer, "p_admin_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_grant_troll_coin"("p_user_id" "uuid", "p_amount" integer, "p_reason" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  -- Only allow service_role to execute
  if auth.role() <> 'service_role' then
    raise exception 'Not authorized';
  end if;

  -- Update coin balance
  update public.user_profiles
  set troll_coin = coalesce(troll_coin, 0) + p_amount
  where user_id = p_user_id;

  if not found then
    raise exception 'User profile not found for user_id %', p_user_id;
  end if;

  -- Log grant
  insert into public.admin_coin_grants (granted_to, granted_by, amount, reason)
  values (p_user_id, auth.uid(), p_amount, p_reason);
end;
$$;


ALTER FUNCTION "public"."admin_grant_troll_coin"("p_user_id" "uuid", "p_amount" integer, "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_mark_cashout_completed"("p_cashout_id" "uuid", "p_payment_reference" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  if not exists (select 1 from user_profiles where id = auth.uid() and role = 'admin') then
    raise exception 'not authorized';
  end if;

  update cashout_requests
    set status = 'completed', admin_notes = case when p_payment_reference is null then admin_notes else coalesce(admin_notes,'') || ';ref=' || p_payment_reference end, updated_at = now()
    where id = p_cashout_id;

  return jsonb_build_object('success', true);
end;
$$;


ALTER FUNCTION "public"."admin_mark_cashout_completed"("p_cashout_id" "uuid", "p_payment_reference" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_mark_cashout_paid"("p_cashout_id" "uuid", "p_payment_reference" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare
  r record;
  flagged boolean := false;
  gross numeric := 0;
  base_perc numeric := 5;
  fee numeric := 0;
  extra_fee numeric := 0;
  net numeric := 0;
begin
  if not exists (select 1 from user_profiles where id = auth.uid() and role = 'admin') then
    raise exception 'not authorized';
  end if;

  select * into r from cashout_requests where id = p_cashout_id;
  if not found then
    raise exception 'cashout not found';
  end if;

  select exists(select 1 from user_bans where user_id = r.user_id and is_active = true)
    or exists(select 1 from admin_flags where user_id = r.user_id)
  into flagged;

  gross := coalesce(r.usd_value, 0);
  select coalesce(processing_fee_percentage, 5) into base_perc from cashout_tiers where coin_amount = r.requested_coins limit 1;
  fee := round(gross * base_perc / 100, 2);
  extra_fee := case when flagged then round(gross * 0.01, 2) else 0 end;
  net := round(gross - fee - extra_fee, 2);

  update cashout_requests
    set status = 'paid', admin_notes = concat('gross=', gross, ';fee=', fee, ';extra=', extra_fee, ';net=', net, ';ref=', coalesce(p_payment_reference,'')), updated_at = now()
    where id = p_cashout_id;

  insert into transactions(user_id, type, transaction_type, coins_used, amount, description, status, payment_method, metadata)
    values (r.user_id, 'cashout', 'cashout', r.requested_coins, net, 'Manual cashout', 'paid', r.payout_method,
            jsonb_build_object('gross', gross, 'fee', fee, 'extraFee', extra_fee, 'provider', r.payout_method, 'payout_details', r.payout_details, 'payment_reference', coalesce(p_payment_reference,'')));

  return jsonb_build_object('success', true, 'net', net, 'fee', fee, 'extraFee', extra_fee);
end;
$$;


ALTER FUNCTION "public"."admin_mark_cashout_paid"("p_cashout_id" "uuid", "p_payment_reference" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_update_payout_status"("p_payout_id" "uuid", "p_admin_id" "uuid", "p_new_status" "text", "p_admin_note" "text" DEFAULT NULL::"text", "p_rejection_reason" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_payout payout_requests%ROWTYPE;
  v_is_admin boolean;
BEGIN
  -- Check if admin
  SELECT is_admin INTO v_is_admin
  FROM user_profiles
  WHERE id = p_admin_id;

  IF v_is_admin IS NOT TRUE THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authorized');
  END IF;

  -- Load payout
  SELECT * INTO v_payout
  FROM payout_requests
  WHERE id = p_payout_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Payout request not found');
  END IF;

  IF v_payout.status NOT IN ('pending','approved') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Payout already processed');
  END IF;

  -- üëá CASE 1: Reject
  IF p_new_status = 'rejected' THEN
    -- Refund coins
    UPDATE user_profiles
    SET paid_coin_balance = paid_coin_balance + v_payout.amount_paid_coins
    WHERE id = v_payout.user_id;

    UPDATE payout_requests
    SET 
      status = 'rejected',
      processed_at = now(),
      processed_by = p_admin_id,
      admin_notes = p_admin_note,
      rejection_reason = p_rejection_reason
    WHERE id = p_payout_id;

    INSERT INTO notifications (user_id, message, type)
    VALUES (
      v_payout.user_id,
      format('‚ùå Your payout request was rejected. Reason: %s',
        COALESCE(p_rejection_reason,'No reason provided')),
      'warning'
    );

    RETURN jsonb_build_object('success', true, 'message', 'Payout rejected and coins refunded.');
  
  -- üëá CASE 2: Approve
  ELSIF p_new_status = 'approved' THEN
    UPDATE payout_requests
    SET 
      status = 'approved',
      processed_at = now(),
      processed_by = p_admin_id,
      admin_notes = p_admin_note
    WHERE id = p_payout_id;

    INSERT INTO notifications (user_id, message, type)
    VALUES (
      v_payout.user_id,
      'üõ† Your payout request has been approved and is being processed.',
      'success'
    );

    RETURN jsonb_build_object('success', true, 'message', 'Payout approved.');
  
  -- üëá CASE 3: Mark Paid
  ELSIF p_new_status = 'paid' THEN
    UPDATE payout_requests
    SET 
      status = 'paid',
      processed_at = now(),
      processed_by = p_admin_id,
      admin_notes = p_admin_note
    WHERE id = p_payout_id;

    -- Track earnings for taxes (1099)
    PERFORM update_creator_earnings(
      v_payout.user_id,
      v_payout.amount_cents,
      EXTRACT(YEAR FROM now())::int,
      EXTRACT(MONTH FROM now())::int
    );

    INSERT INTO notifications (user_id, message, type)
    VALUES (
      v_payout.user_id,
      'üí∞ Your payout has been successfully processed and sent.',
      'success'
    );

    RETURN jsonb_build_object('success', true, 'message', 'Payout marked as paid.');
  
  -- üëá INVALID STATUS
  ELSE
    RETURN jsonb_build_object('success', false, 'error', 'Invalid status provided');
  END IF;
END;
$$;


ALTER FUNCTION "public"."admin_update_payout_status"("p_payout_id" "uuid", "p_admin_id" "uuid", "p_new_status" "text", "p_admin_note" "text", "p_rejection_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_update_payout_status"("p_payout_id" "uuid", "p_admin_id" "uuid", "p_new_status" "text", "p_rejection_reason" "text" DEFAULT NULL::"text", "p_payment_reference" "text" DEFAULT NULL::"text", "p_notes" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_payout RECORD;
  v_user_profile RECORD;
BEGIN
  -- Verify admin
  IF NOT EXISTS (
    SELECT 1 FROM user_profiles
    WHERE id = p_admin_id AND role = 'admin'
  ) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Unauthorized: Admin access required');
  END IF;

  -- Get payout request
  SELECT * INTO v_payout
  FROM payout_requests
  WHERE id = p_payout_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Payout request not found');
  END IF;

  -- Validate status transition
  IF v_payout.status = 'paid' AND p_new_status != 'paid' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Cannot change status of paid payout');
  END IF;

  IF v_payout.status = 'rejected' AND p_new_status NOT IN ('rejected', 'pending') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Cannot change status of rejected payout');
  END IF;

  -- Update payout status
  UPDATE payout_requests
  SET 
    status = p_new_status,
    updated_at = NOW(),
    notes = COALESCE(p_notes, notes),
    payment_reference = COALESCE(p_payment_reference, payment_reference)
  WHERE id = p_payout_id;

  -- Set timestamps based on status
  IF p_new_status = 'approved' THEN
    UPDATE payout_requests
    SET approved_at = NOW()
    WHERE id = p_payout_id;
  ELSIF p_new_status = 'paid' THEN
    UPDATE payout_requests
    SET paid_at = NOW()
    WHERE id = p_payout_id;
  ELSIF p_new_status = 'rejected' THEN
    -- If rejected, refund coins to user
    UPDATE user_profiles
    SET 
      troll_coins = troll_coins + v_payout.coins_used,
      updated_at = NOW()
    WHERE id = v_payout.user_id;

    -- Record refund transaction
    INSERT INTO coin_transactions (
      user_id,
      type,
      amount,
      description,
      metadata
    )
    VALUES (
      v_payout.user_id,
      'payout_refund',
      v_payout.coins_used,
      format('Payout request rejected: %s coins refunded', v_payout.coins_used),
      jsonb_build_object('payout_request_id', p_payout_id, 'rejection_reason', p_rejection_reason)
    );

    -- Update notes with rejection reason
    UPDATE payout_requests
    SET notes = COALESCE(p_rejection_reason, notes)
    WHERE id = p_payout_id;
  END IF;

  -- Send notification to user
  INSERT INTO notifications (
    user_id,
    message,
    type,
    read
  )
  VALUES (
    v_payout.user_id,
    CASE 
      WHEN p_new_status = 'approved' THEN format('üí∞ Your payout request of $%s has been approved and is being processed.', v_payout.net_amount)
      WHEN p_new_status = 'paid' THEN format('‚úÖ Your payout of $%s has been sent!', v_payout.net_amount)
      WHEN p_new_status = 'rejected' THEN format('‚ùå Your payout request was rejected. Reason: %s', COALESCE(p_rejection_reason, 'Not specified'))
      ELSE format('üìã Your payout request status has been updated to: %s', p_new_status)
    END,
    CASE 
      WHEN p_new_status = 'paid' THEN 'success'
      WHEN p_new_status = 'rejected' THEN 'warning'
      ELSE 'info'
    END,
    false
  );

  RETURN jsonb_build_object(
    'success', true,
    'message', format('Payout status updated to %s', p_new_status)
  );
END;
$_$;


ALTER FUNCTION "public"."admin_update_payout_status"("p_payout_id" "uuid", "p_admin_id" "uuid", "p_new_status" "text", "p_rejection_reason" "text", "p_payment_reference" "text", "p_notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_update_user_profile"("p_target_user_id" "uuid", "p_troll_coins" integer DEFAULT NULL::integer, "p_free_coin_balance" integer DEFAULT NULL::integer, "p_level" integer DEFAULT NULL::integer, "p_role" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_admin_user_id UUID;
  v_is_admin BOOLEAN;
  v_current_profile RECORD;
  v_updates JSONB;
BEGIN
  -- Get the ID of the user executing this function
  v_admin_user_id := auth.uid();
  
  -- Check if the executor is an admin
  -- We check both the role column and specific admin email/metadata if needed
  SELECT EXISTS (
    SELECT 1 FROM user_profiles
    WHERE id = v_admin_user_id
    AND (role = 'admin' OR is_admin = true)
  ) INTO v_is_admin;

  -- Fallback: Check if it's the specific admin email from auth.users (if needed, but profile check is better)
  IF NOT v_is_admin THEN
    SELECT EXISTS (
      SELECT 1 FROM auth.users
      WHERE id = v_admin_user_id
      AND email = 'trollcity2025@gmail.com'
    ) INTO v_is_admin;
  END IF;

  IF NOT v_is_admin THEN
    RETURN jsonb_build_object('success', false, 'error', 'Unauthorized: Admin access required');
  END IF;

  -- Get current profile to preserve values if NULL passed
  SELECT * INTO v_current_profile FROM user_profiles WHERE id = p_target_user_id;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;

  -- Perform the update
  -- We use COALESCE to keep existing values if input is NULL
  -- Note: If you want to explicitly set to NULL, this logic needs adjustment, 
  -- but for coins/level/role, NULL is usually not desired.
  
  UPDATE user_profiles
  SET 
    troll_coins = COALESCE(p_troll_coins, troll_coins),
    free_coin_balance = COALESCE(p_free_coin_balance, free_coin_balance),
    level = COALESCE(p_level, level),
    role = COALESCE(p_role, role),
    is_admin = CASE WHEN p_role = 'admin' THEN true ELSE false END,
    is_troll_officer = CASE WHEN p_role = 'troll_officer' THEN true ELSE false END,
    is_troller = CASE WHEN p_role = 'troller' THEN true ELSE false END,
    updated_at = NOW()
  WHERE id = p_target_user_id;

  RETURN jsonb_build_object('success', true);
END;
$$;


ALTER FUNCTION "public"."admin_update_user_profile"("p_target_user_id" "uuid", "p_troll_coins" integer, "p_free_coin_balance" integer, "p_level" integer, "p_role" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."apply_family_war_winner_boosts"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  r RECORD;
  v_boost_value int;
BEGIN
  FOR r IN
    SELECT family_id,
           weekly_war_points,
           ROW_NUMBER() OVER (ORDER BY weekly_war_points DESC) AS rank
    FROM public.family_war_stats
    WHERE weekly_war_points > 0
    ORDER BY weekly_war_points DESC
    LIMIT 3
  LOOP
    IF r.rank = 1 THEN v_boost_value := 30;
    ELSIF r.rank = 2 THEN v_boost_value := 20;
    ELSE v_boost_value := 15;
    END IF;

    INSERT INTO public.family_boosts (
      family_id, boost_type, boost_value, starts_at, ends_at, metadata
    )
    VALUES (
      r.family_id,
      'war_winner',
      v_boost_value,
      now(),
      now() + INTERVAL '7 days',
      jsonb_build_object(
        'rank', r.rank,
        'weekly_war_points', r.weekly_war_points
      )
    );
  END LOOP;
END;
$$;


ALTER FUNCTION "public"."apply_family_war_winner_boosts"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."apply_stream_momentum_decay"("p_stream_id" "uuid") RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_m public.stream_momentum%rowtype;
  v_base timestamptz;
  v_blocks integer;
  v_new integer;
BEGIN
  PERFORM public.ensure_stream_momentum(p_stream_id);

  SELECT *
  INTO v_m
  FROM public.stream_momentum
  WHERE stream_id = p_stream_id
  FOR UPDATE;

  IF v_m.stream_id IS NULL THEN
    RETURN 100;
  END IF;

  v_base := GREATEST(
    COALESCE(v_m.last_decay_at, v_m.last_gift_at, now()),
    COALESCE(v_m.last_gift_at, now())
  );

  v_blocks := FLOOR(EXTRACT(EPOCH FROM (now() - v_base)) / 600)::integer;

  IF v_blocks <= 0 THEN
    RETURN v_m.momentum;
  END IF;

  v_new := GREATEST(0, LEAST(100, v_m.momentum - (v_blocks * 10)));

  UPDATE public.stream_momentum
  SET
    momentum = v_new,
    last_decay_at = v_base + make_interval(secs => v_blocks * 600),
    updated_at = now()
  WHERE stream_id = p_stream_id;

  RETURN v_new;
END;
$$;


ALTER FUNCTION "public"."apply_stream_momentum_decay"("p_stream_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."apply_top_gifter_boosts"("p_leaderboard_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  r RECORD;
  v_boost_value int;
BEGIN
  FOR r IN
    SELECT user_id, rank, score
    FROM public.gift_leaderboard_entries
    WHERE leaderboard_id = p_leaderboard_id
      AND rank <= 3
    ORDER BY rank ASC
  LOOP
    -- Rank-based boost values
    IF r.rank = 1 THEN v_boost_value := 50;
    ELSIF r.rank = 2 THEN v_boost_value := 30;
    ELSE v_boost_value := 20;
    END IF;

    INSERT INTO public.user_boosts (
      user_id, boost_type, boost_value, starts_at, ends_at, metadata
    )
    VALUES (
      r.user_id,
      'top_gifter',
      v_boost_value,
      now(),
      now() + INTERVAL '24 hours',
      jsonb_build_object(
        'leaderboard_id', p_leaderboard_id,
        'rank', r.rank,
        'coins_spent', r.score
      )
    );
  END LOOP;
END;
$$;


ALTER FUNCTION "public"."apply_top_gifter_boosts"("p_leaderboard_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."apply_town_update"("p_user_id" "uuid", "p_cost" integer, "p_update_type" "text", "p_payload" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_update_id uuid := gen_random_uuid();
BEGIN
  -- 1) Deduct coins safely (only if user has enough)
  UPDATE public.user_profiles
  SET troll_coins = troll_coins - p_cost,
      updated_at = now()
  WHERE id = p_user_id
    AND troll_coins >= p_cost;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'INSUFFICIENT_COINS';
  END IF;

  -- 2) Record the town update
  INSERT INTO public.town_updates (id, user_id, update_type, cost, payload, created_at)
  VALUES (v_update_id, p_user_id, p_update_type, p_cost, p_payload, now());

  RETURN v_update_id;
END;
$$;


ALTER FUNCTION "public"."apply_town_update"("p_user_id" "uuid", "p_cost" integer, "p_update_type" "text", "p_payload" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."apply_troll_pass_bundle"("p_user_id" "uuid") RETURNS timestamp with time zone
    LANGUAGE "plpgsql"
    AS $$
declare
  v_expires timestamptz;
begin
  -- Add coins bonus
  update user_profiles
  set troll_coins = coalesce(troll_coins,0) + 1500
  where id = p_user_id;

  -- Activate the bundle item
  v_expires := (select activate_store_item(p_user_id, 'bundle_troll_pass_paypal'));

  return v_expires;
end;
$$;


ALTER FUNCTION "public"."apply_troll_pass_bundle"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."apply_trollstown_upgrade"("p_user_id" "uuid", "p_property_type" "text", "p_upgrade_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_cost integer;
  v_balance integer;
  v_upgrade_record_id uuid := gen_random_uuid();
BEGIN
  -- 1) Get upgrade cost
  SELECT cost
  INTO v_cost
  FROM public.trollstown_upgrade_config
  WHERE id = p_upgrade_id;

  IF v_cost IS NULL THEN
    RAISE EXCEPTION 'INVALID_UPGRADE_ID: %', p_upgrade_id;
  END IF;

  -- 2) Load user's coin balance (and detect missing profile row)
  SELECT COALESCE(troll_coins, 0)
  INTO v_balance
  FROM public.user_profiles
  WHERE id = p_user_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'NO_USER_PROFILE_FOR_ID: %', p_user_id;
  END IF;

  -- 3) Enforce sufficient coins
  IF v_balance < v_cost THEN
    RAISE EXCEPTION 'INSUFFICIENT_TROLL_COINS: have %, need %', v_balance, v_cost;
  END IF;

  -- 4) Deduct coins
  UPDATE public.user_profiles
  SET troll_coins = COALESCE(troll_coins, 0) - v_cost,
      updated_at = now()
  WHERE id = p_user_id;

  -- 5) Record the upgrade
  INSERT INTO public.trollstown_property_upgrades (
    id,
    user_id,
    upgrade_id,
    applied_at
  )
  VALUES (
    v_upgrade_record_id,
    p_user_id,
    p_upgrade_id,
    now()
  );

  -- 6) Apply the upgrade effect (example: level + 1)
  UPDATE public.trollstown_properties
  SET level = COALESCE(level, 0) + 1,
      updated_at = now()
  WHERE user_id = p_user_id
    AND property_type = p_property_type;

  RETURN v_upgrade_record_id;
END;
$$;


ALTER FUNCTION "public"."apply_trollstown_upgrade"("p_user_id" "uuid", "p_property_type" "text", "p_upgrade_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."apply_violation_consequence"("p_user_id" "uuid", "p_violation_type" character varying, "p_severity_level" integer, "p_officer_id" "uuid", "p_reason" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    escalation_result JSONB;
    consequence_type VARCHAR(50);
    duration_minutes INTEGER;
    points_deducted INTEGER;
    court_session_id UUID;
BEGIN
    -- Check for escalation
    SELECT check_violation_escalation(p_user_id, p_violation_type, p_severity_level) INTO escalation_result;

    IF NOT (escalation_result->>'escalate')::BOOLEAN THEN
        -- Log the violation but no escalation
        PERFORM log_user_history(
            p_user_id, 'violation', 'escalation_check',
            CASE WHEN p_severity_level >= 4 THEN 'high'
                 WHEN p_severity_level >= 2 THEN 'medium'
                 ELSE 'low' END,
            'Violation logged: ' || p_violation_type,
            jsonb_build_object(
                'violation_type', p_violation_type,
                'severity_level', p_severity_level,
                'escalation_checked', TRUE,
                'escalation_result', 'none'
            ),
            p_officer_id
        );

        RETURN jsonb_build_object('success', TRUE, 'escalated', FALSE);
    END IF;

    -- Apply escalation
    consequence_type := escalation_result->>'consequence_type';
    duration_minutes := (escalation_result->>'consequence_duration_minutes')::INTEGER;
    points_deducted := (escalation_result->>'points_deducted')::INTEGER;

    -- Apply reputation penalty
    IF points_deducted > 0 THEN
        PERFORM update_user_reputation(
            p_user_id, -points_deducted, 'violation_penalty',
            'Penalty for ' || p_violation_type || ' violation', p_officer_id,
            jsonb_build_object('violation_type', p_violation_type, 'severity', p_severity_level)
        );
    END IF;

    -- Apply consequence based on type
    CASE consequence_type
        WHEN 'warning' THEN
            -- Send warning notification
            PERFORM send_notification(
                p_user_id, 'violation_warning', 'Violation Warning',
                'You have received a warning for: ' || p_violation_type || '. Continued violations may result in further action.',
                jsonb_build_object('violation_type', p_violation_type, 'severity', p_severity_level)
            );

        WHEN 'timeout' THEN
            -- Apply timeout (temporary ban)
            UPDATE user_profiles
            SET is_kicked = TRUE,
                kicked_until = NOW() + INTERVAL '1 minute' * duration_minutes,
                updated_at = NOW()
            WHERE id = p_user_id;

        WHEN 'ban' THEN
            -- Apply ban
            UPDATE user_profiles
            SET is_banned = TRUE,
                ban_expires_at = CASE WHEN duration_minutes IS NULL THEN NULL
                                     ELSE NOW() + INTERVAL '1 minute' * duration_minutes END,
                updated_at = NOW()
            WHERE id = p_user_id;

        WHEN 'court_session' THEN
            -- Create court session
            INSERT INTO court_sessions (
                defendant_id, case_type, severity_level, status,
                created_by, description
            ) VALUES (
                p_user_id, p_violation_type, p_severity_level, 'scheduled',
                p_officer_id, 'Auto-escalated court session for ' || p_violation_type
            ) RETURNING id INTO court_session_id;

        WHEN 'permanent_ban' THEN
            -- Permanent ban
            UPDATE user_profiles
            SET is_banned = TRUE,
                ban_expires_at = NULL,
                updated_at = NOW()
            WHERE id = p_user_id;
    END CASE;

    -- Log the violation and consequence
    PERFORM log_user_history(
        p_user_id, 'violation', consequence_type,
        CASE WHEN p_severity_level >= 4 THEN 'high'
             WHEN p_severity_level >= 2 THEN 'medium'
             ELSE 'low' END,
        'Violation consequence applied: ' || consequence_type || ' for ' || p_violation_type,
        jsonb_build_object(
            'violation_type', p_violation_type,
            'severity_level', p_severity_level,
            'consequence_type', consequence_type,
            'duration_minutes', duration_minutes,
            'points_deducted', points_deducted,
            'court_session_id', court_session_id
        ),
        p_officer_id
    );

    -- Log officer action
    PERFORM log_officer_action(
        p_officer_id, 'moderation', 'violation_handling',
        p_user_id, NULL, court_session_id,
        'Applied ' || consequence_type || ' for ' || p_violation_type || ' violation',
        p_reason, jsonb_build_object(
            'violation_type', p_violation_type,
            'consequence_type', consequence_type,
            'severity_level', p_severity_level
        ), 'successful', 1, NULL
    );

    RETURN jsonb_build_object(
        'success', TRUE,
        'escalated', TRUE,
        'consequence_type', consequence_type,
        'court_session_id', court_session_id
    );
END;
$$;


ALTER FUNCTION "public"."apply_violation_consequence"("p_user_id" "uuid", "p_violation_type" character varying, "p_severity_level" integer, "p_officer_id" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."approve_application"("p_application_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  UPDATE public.applications
  SET
    lead_officer_approved = true,
    lead_officer_approved_at = now()
  WHERE application_id = p_application_id;
END;
$$;


ALTER FUNCTION "public"."approve_application"("p_application_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."approve_application"("p_app_id" "uuid", "p_reviewer_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_application RECORD;
  v_reviewer RECORD;
  v_role_to_grant TEXT;
BEGIN
  -- Check if reviewer is admin
  SELECT * INTO v_reviewer
  FROM user_profiles
  WHERE id = p_reviewer_id;

  IF NOT (v_reviewer.role = 'admin' OR v_reviewer.is_admin = TRUE) THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Only admins can approve applications');
  END IF;

  -- Get application
  SELECT * INTO v_application
  FROM applications
  WHERE id = p_app_id AND status = 'pending';

  IF v_application IS NULL THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Application not found or already processed');
  END IF;

  -- Determine role to grant based on application type
  CASE v_application.type
    WHEN 'troller' THEN
      v_role_to_grant := 'troller';
    WHEN 'troll_family' THEN
      v_role_to_grant := 'troll_family';
    ELSE
      v_role_to_grant := v_application.type;
  END CASE;

  -- Update application status
  UPDATE applications
  SET 
    status = 'approved',
    reviewed_by = p_reviewer_id,
    reviewed_at = NOW(),
    updated_at = NOW()
  WHERE id = p_app_id;

  -- Update user profile based on type
  IF v_application.type = 'troller' THEN
    UPDATE user_profiles
    SET 
      role = 'troller',
      is_troller = TRUE,
      updated_at = NOW()
    WHERE id = v_application.user_id;

  ELSIF v_application.type = 'troll_family' THEN
    UPDATE user_profiles
    SET 
      role = 'troll_family',
      updated_at = NOW()
    WHERE id = v_application.user_id;
  END IF;

  -- Notification
  INSERT INTO notifications (
    user_id,
    type,
    title,
    message,
    metadata
  ) VALUES (
    v_application.user_id,
    'application_approved',
    'Application Approved',
    format('Your %s application has been approved!', v_application.type),
    jsonb_build_object('link', '/profile')
  );

  RETURN jsonb_build_object(
    'success', TRUE,
    'message', format('Application approved successfully. User granted role: %s', v_role_to_grant)
  );
END;
$$;


ALTER FUNCTION "public"."approve_application"("p_app_id" "uuid", "p_reviewer_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."approve_broadcaster"("p_application_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  UPDATE broadcaster_applications
  SET 
    status = 'approved',
    reviewer_id = auth.uid(),
    reviewed_at = NOW()
  WHERE id = p_application_id;
END;
$$;


ALTER FUNCTION "public"."approve_broadcaster"("p_application_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."approve_broadcaster"("p_application_id" "uuid", "p_reviewer_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  UPDATE broadcaster_applications
  SET 
    status = 'approved',
    reviewer_id = p_reviewer_id,
    reviewed_at = NOW()
  WHERE id = p_application_id;

  -- Optionally grant broadcaster role in user_profiles
  UPDATE user_profiles
  SET is_broadcaster = true
  WHERE id = (
    SELECT user_id FROM broadcaster_applications WHERE id = p_application_id
  );
END;
$$;


ALTER FUNCTION "public"."approve_broadcaster"("p_application_id" "uuid", "p_reviewer_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."approve_empire_application"("p_application_id" "uuid", "p_reviewer_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- Update the application
  UPDATE empire_applications
  SET 
    status = 'approved',
    reviewed_at = NOW(),
    reviewed_by = p_reviewer_id
  WHERE id = p_application_id;

  -- Promote user to partner
  UPDATE user_profiles
  SET 
    empire_role = 'partner',
    updated_at = NOW()
  WHERE id = (
    SELECT user_id 
    FROM empire_applications 
    WHERE id = p_application_id
  );

  -- Return consistent result JSON
  RETURN jsonb_build_object(
    'success', TRUE,
    'application_id', p_application_id,
    'reviewer_id', p_reviewer_id,
    'timestamp', NOW()
  );
END;
$$;


ALTER FUNCTION "public"."approve_empire_application"("p_application_id" "uuid", "p_reviewer_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."approve_empire_partner"("p_application_id" "uuid", "p_reviewer_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
   v_user_id uuid;
BEGIN
   -- Get user_id from application
   SELECT user_id INTO v_user_id
   FROM empire_applications
   WHERE id = p_application_id AND status = 'pending';

   IF v_user_id IS NULL THEN
     RAISE EXCEPTION 'Application not found or already processed';
   END IF;

   -- Update application status
   UPDATE empire_applications
   SET
     status = 'approved',
     reviewed_by = p_reviewer_id,
     reviewed_at = NOW()
   WHERE id = p_application_id;

   -- Update user profile with multiple fields for proper access control
   UPDATE user_profiles
   SET
     is_empire_partner = true,
     empire_partner = true,
     partner_status = 'approved',
     role = 'empire_partner'
   WHERE id = v_user_id;

   -- Update or insert empire_partners table entry
   INSERT INTO empire_partners (user_id, status, approved_at)
   VALUES (v_user_id, 'approved', NOW())
   ON CONFLICT (user_id)
   DO UPDATE SET
     status = 'approved',
     approved_at = NOW();
END;
$$;


ALTER FUNCTION "public"."approve_empire_partner"("p_application_id" "uuid", "p_reviewer_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."approve_empire_partner"("p_application_id" "uuid", "p_reviewer_id" "uuid") IS 'Approves an Empire Partner application and updates user profile';



CREATE OR REPLACE FUNCTION "public"."approve_lead_officer_application"("p_application_id" "uuid", "p_reviewer_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
    DECLARE
      v_user_id UUID;
      v_app_type TEXT;
    BEGIN
      -- Get application details
      SELECT user_id, type INTO v_user_id, v_app_type
      FROM applications
      WHERE id = p_application_id AND status = 'pending';

      IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'error', 'Application not found or already processed');
      END IF;

      IF v_app_type != 'lead_officer' THEN
        RETURN jsonb_build_object('success', false, 'error', 'Not a lead officer application');
      END IF;

      -- Update user profile
      UPDATE user_profiles
      SET 
        is_lead_officer = TRUE,
        officer_role = 'lead_officer',
        role = CASE WHEN role = 'user' THEN 'lead_officer' ELSE role END,
        updated_at = NOW()
      WHERE id = v_user_id;

      -- Update application status
      UPDATE applications
      SET 
        status = 'approved',
        reviewed_by = p_reviewer_id,
        reviewed_at = NOW()
      WHERE id = p_application_id;

      RETURN jsonb_build_object('success', true, 'user_id', v_user_id);
    END;
    $$;


ALTER FUNCTION "public"."approve_lead_officer_application"("p_application_id" "uuid", "p_reviewer_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."approve_lead_officer_application"("p_application_id" "uuid", "p_reviewer_id" "uuid") IS 'Approves a lead officer application and immediately activates them (no quiz required)';



CREATE OR REPLACE FUNCTION "public"."approve_officer_application"("app_id" "uuid") RETURNS json
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_user_id UUID;
  v_result JSON;
BEGIN
  -- Get user_id from application
  SELECT user_id INTO v_user_id
  FROM broadcaster_applications
  WHERE id = app_id AND application_type = 'troll_officer';

  IF v_user_id IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Application not found');
  END IF;

  -- Update user role
  UPDATE user_profiles
  SET 
    role = 'troll_officer',
    is_troll_officer = TRUE,
    officer_level = 1,
    updated_at = NOW()
  WHERE id = v_user_id;

  -- Update application status
  UPDATE broadcaster_applications
  SET 
    status = 'approved',
    reviewed_at = NOW(),
    updated_at = NOW()
  WHERE id = app_id;

  -- Create orientation record
  INSERT INTO officer_orientations (user_id, status, created_at)
  VALUES (v_user_id, 'pending', NOW())
  ON CONFLICT (user_id) DO NOTHING;

  RETURN json_build_object('success', true, 'user_id', v_user_id);
END;
$$;


ALTER FUNCTION "public"."approve_officer_application"("app_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."approve_payout"("p_payout_id" "uuid", "p_start_processing" boolean DEFAULT false) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_payout payout_requests%ROWTYPE;
  v_actor record;
  v_new_status text;
  v_has_approved_at boolean;
BEGIN
  SELECT role, is_admin, officer_role, is_lead_officer
  INTO v_actor
  FROM user_profiles
  WHERE id = auth.uid();

  IF v_actor IS NULL THEN
    RAISE EXCEPTION 'Authentication required';
  END IF;

  IF NOT (v_actor.role = 'admin' OR v_actor.is_admin = true OR v_actor.officer_role = 'lead_officer' OR v_actor.is_lead_officer = true) THEN
    RAISE EXCEPTION 'Only admins or lead officers can approve payouts';
  END IF;

  IF p_start_processing AND NOT (v_actor.role = 'admin' OR v_actor.is_admin = true) THEN
    RAISE EXCEPTION 'Only admins can start payout processing';
  END IF;

  SELECT *
  INTO v_payout
  FROM payout_requests
  WHERE id = p_payout_id;

  IF v_payout IS NULL THEN
    RAISE EXCEPTION 'Payout request not found';
  END IF;

  -- Idempotent behavior
  IF v_payout.status = 'paid' THEN
    RAISE EXCEPTION 'Payout is already paid';
  END IF;
  IF v_payout.status = 'rejected' THEN
    RAISE EXCEPTION 'Payout is rejected';
  END IF;
  IF v_payout.status = 'processing' THEN
    RETURN;
  END IF;
  IF v_payout.status != 'pending' AND v_payout.status != 'approved' THEN
    RAISE EXCEPTION 'Payout is already %', v_payout.status;
  END IF;

  v_new_status := CASE WHEN p_start_processing THEN 'processing' ELSE 'approved' END;

  v_has_approved_at := EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'payout_requests'
      AND column_name = 'approved_at'
  );

  IF v_has_approved_at THEN
    UPDATE payout_requests
    SET
      status = v_new_status,
      processed_by = auth.uid(),
      processed_at = now(),
      approved_at = CASE WHEN v_new_status = 'approved' THEN now() ELSE approved_at END
    WHERE id = p_payout_id;
  ELSE
    UPDATE payout_requests
    SET
      status = v_new_status,
      processed_by = auth.uid(),
      processed_at = now()
    WHERE id = p_payout_id;
  END IF;
END;
$$;


ALTER FUNCTION "public"."approve_payout"("p_payout_id" "uuid", "p_start_processing" boolean) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."approve_payout"("p_payout_id" "uuid", "p_start_processing" boolean) IS 'Approves and marks a payout as paid. Call with: { p_payout_id: payoutId }';



CREATE OR REPLACE FUNCTION "public"."approve_visa_redemption"("p_redemption_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_admin_id uuid := auth.uid();
  v_role text;
  v_row public.visa_redemptions;
BEGIN
  IF v_admin_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT role INTO v_role FROM public.user_profiles WHERE id = v_admin_id;
  IF v_role NOT IN ('admin','secretary') THEN
    RAISE EXCEPTION 'Not authorized';
  END IF;

  SELECT * INTO v_row FROM public.visa_redemptions WHERE id = p_redemption_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Redemption not found';
  END IF;

  IF v_row.status IN ('fulfilled','rejected') THEN
    RAISE EXCEPTION 'Redemption already processed';
  END IF;

  UPDATE public.visa_redemptions
  SET status = 'approved',
      approved_at = now(),
      approved_by = v_admin_id,
      updated_at = now()
  WHERE id = p_redemption_id;

  RETURN jsonb_build_object('success', true, 'RedemptionStatus', 'approved');
END;
$$;


ALTER FUNCTION "public"."approve_visa_redemption"("p_redemption_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."approve_visa_redemption"("p_redemption_id" "uuid", "p_staff_note" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
begin
  update public.visa_redemptions
  set status = 'approved',
      approved_at = now(),
      staff_note = coalesce(p_staff_note, staff_note)
  where id = p_redemption_id
    and status = 'pending';

  if not found then
    raise exception 'Redemption not found or not pending';
  end if;
end;
$$;


ALTER FUNCTION "public"."approve_visa_redemption"("p_redemption_id" "uuid", "p_staff_note" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."archive_court_ruling"("p_court_session_id" "uuid", "p_ruling" character varying, "p_consequence_applied" character varying, "p_duration_applied" character varying, "p_reasoning_summary" "text", "p_precedent_citation" "text", "p_judge_notes" "text", "p_is_public" boolean DEFAULT true) RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    ruling_id UUID;
    case_type VARCHAR(50);
    severity_level INTEGER;
BEGIN
    -- Get case details from court session
    SELECT case_type, severity_level INTO case_type, severity_level
    FROM court_sessions
    WHERE id = p_court_session_id;

    -- Insert ruling archive
    INSERT INTO court_rulings_archive (
        court_session_id, case_type, severity_level, ruling,
        consequence_applied, duration_applied, reasoning_summary,
        precedent_citation, judge_notes, is_public
    ) VALUES (
        p_court_session_id, case_type, severity_level, p_ruling,
        p_consequence_applied, p_duration_applied, p_reasoning_summary,
        p_precedent_citation, p_judge_notes, p_is_public
    ) RETURNING id INTO ruling_id;

    RETURN ruling_id;
END;
$$;


ALTER FUNCTION "public"."archive_court_ruling"("p_court_session_id" "uuid", "p_ruling" character varying, "p_consequence_applied" character varying, "p_duration_applied" character varying, "p_reasoning_summary" "text", "p_precedent_citation" "text", "p_judge_notes" "text", "p_is_public" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."assign_officer_orientation"("p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_orientation_id UUID;
BEGIN
  -- Check if orientation already exists
  SELECT id INTO v_orientation_id
  FROM officer_orientations
  WHERE user_id = p_user_id;

  IF v_orientation_id IS NOT NULL THEN
    RETURN jsonb_build_object(
      'success', true,
      'message', 'Orientation already assigned',
      'orientation_id', v_orientation_id
    );
  END IF;

  -- Create new orientation
  INSERT INTO officer_orientations (user_id, status, assigned_at)
  VALUES (p_user_id, 'assigned', NOW())
  RETURNING id INTO v_orientation_id;

  RETURN jsonb_build_object(
    'success', true,
    'message', 'Orientation assigned successfully',
    'orientation_id', v_orientation_id
  );
END;
$$;


ALTER FUNCTION "public"."assign_officer_orientation"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."assign_officer_orientation"("p_user_id" "uuid") IS 'Assigns orientation to a user after application approval';



CREATE OR REPLACE FUNCTION "public"."assign_og_user"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF NEW.created_at <= TIMESTAMPTZ '2025-12-31 23:59:59+00' THEN
    NEW.is_og_user := true;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."assign_og_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_approve_troller"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  if new.type = 'troller' then
    new.status := 'approved';
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."auto_approve_troller"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_grant_admin_officer_status"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- If user becomes admin, automatically grant troll_officer and activate
  IF (NEW.role = 'admin' OR NEW.is_admin = TRUE) THEN
    NEW.is_troll_officer := TRUE;
    NEW.is_officer_active := TRUE;  -- Admins don't need quiz
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_grant_admin_officer_status"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."auto_grant_admin_officer_status"() IS 'Automatically grants troll_officer status and activates admins (no quiz required)';



CREATE OR REPLACE FUNCTION "public"."auto_post_badge_earned"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_badge_name TEXT;
  v_username TEXT;
BEGIN
  -- Get badge name
  SELECT badge_name INTO v_badge_name
  FROM badges
  WHERE id = NEW.badge_id;
  
  -- Get username
  SELECT username INTO v_username
  FROM user_profiles
  WHERE id = NEW.user_id;
  
  -- Post badge announcement
  INSERT INTO troll_wall_posts (user_id, post_type, content, metadata)
  VALUES (
    NEW.user_id,
    'badge_earned',
    format('üèÜ @%s unlocked the "%s" badge!', v_username, COALESCE(v_badge_name, 'Unknown Badge')),
    jsonb_build_object(
      'badge_id', NEW.badge_id,
      'earned_at', NEW.earned_at
    )
  );
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_post_badge_earned"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_post_battle_result"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_host_username TEXT;
  v_challenger_username TEXT;
  v_winner_username TEXT;
  v_content TEXT;
BEGIN
  -- Only post when battle is completed
  IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
    -- Get usernames
    SELECT username INTO v_host_username
    FROM user_profiles
    WHERE id = NEW.host_id;
    
    SELECT username INTO v_challenger_username
    FROM user_profiles
    WHERE id = NEW.challenger_id;
    
    IF NEW.winner_id = NEW.host_id THEN
      v_winner_username := v_host_username;
    ELSE
      v_winner_username := v_challenger_username;
    END IF;
    
    v_content := format('‚öîÔ∏è Battle Result: @%s defeated @%s! Total coins: %s', 
      v_winner_username,
      CASE WHEN NEW.winner_id = NEW.host_id THEN v_challenger_username ELSE v_host_username END,
      (NEW.host_total_coins + NEW.challenger_total_coins)::TEXT
    );
    
    -- Post as system (user_id = host_id for attribution, but mark as system type)
    INSERT INTO troll_wall_posts (user_id, post_type, content, metadata)
    VALUES (
      NEW.host_id,
      'battle_result',
      v_content,
      jsonb_build_object(
        'battle_id', NEW.id,
        'host_id', NEW.host_id,
        'challenger_id', NEW.challenger_id,
        'winner_id', NEW.winner_id,
        'host_total_coins', NEW.host_total_coins,
        'challenger_total_coins', NEW.challenger_total_coins
      )
    );
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_post_battle_result"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_post_stream_live"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_username TEXT;
  v_stream_title TEXT;
BEGIN
  -- Only post when stream becomes live
  IF NEW.is_live = true AND (OLD.is_live IS NULL OR OLD.is_live = false) THEN
    -- Get broadcaster username
    SELECT username INTO v_username
    FROM user_profiles
    WHERE id = NEW.broadcaster_id;
    
    v_stream_title := COALESCE(NEW.title, 'Untitled Stream');
    
    -- Post stream announcement
    INSERT INTO troll_wall_posts (user_id, post_type, content, metadata)
    VALUES (
      NEW.broadcaster_id,
      'stream_announce',
      format('üî¥ @%s is now LIVE: %s', v_username, v_stream_title),
      jsonb_build_object(
        'stream_id', NEW.id,
        'stream_title', v_stream_title
      )
    );
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_post_stream_live"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_remove_verification_on_ban"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF NEW.is_banned = TRUE AND NEW.ban_expires_at IS NULL THEN
    -- Permanent ban - remove verification
    UPDATE user_profiles
    SET 
      is_verified = FALSE,
      verification_date = NULL,
      updated_at = NOW()
    WHERE id = NEW.id;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_remove_verification_on_ban"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_start_court_with_docket"("p_authority_user_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    v_docket_count INTEGER;
    v_session_id UUID;
BEGIN
    -- Check if there are scheduled docket entries
    SELECT COUNT(*)
    INTO v_docket_count
    FROM court_docket
    WHERE status = 'scheduled'
    AND scheduled_at <= NOW() + INTERVAL '1 hour'; -- Within next hour

    -- Only start if there are docket entries to handle
    IF v_docket_count = 0 THEN
        RETURN FALSE;
    END IF;

    -- Try to start court session
    UPDATE court_sessions
    SET
        status = 'live',
        started_by = p_authority_user_id,
        started_at = NOW(),
        updated_at = NOW()
    WHERE status = 'waiting';

    -- Get the session ID
    SELECT id INTO v_session_id
    FROM court_sessions
    WHERE status = 'live'
    ORDER BY started_at DESC
    LIMIT 1;

    -- Update docket entries to in_session
    UPDATE court_docket
    SET
        status = 'in_session',
        court_session_id = v_session_id,
        updated_at = NOW()
    WHERE status = 'scheduled'
    AND scheduled_at <= NOW() + INTERVAL '1 hour';

    RETURN FOUND;
END;
$$;


ALTER FUNCTION "public"."auto_start_court_with_docket"("p_authority_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."auto_start_court_with_docket"("p_authority_user_id" "uuid") IS 'Auto-starts court when authority is present and docket entries exist';



CREATE TABLE IF NOT EXISTS "public"."system_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "payout_lock_enabled" boolean DEFAULT true,
    "payout_lock_reason" "text",
    "payout_unlock_at" timestamp with time zone,
    "trial_started_at" timestamp with time zone,
    "trial_started_by" "uuid",
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."system_settings" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."system_settings" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_unlock_payouts"() RETURNS "public"."system_settings"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_settings public.system_settings;
BEGIN
  UPDATE public.system_settings
  SET payout_lock_enabled = FALSE,
      updated_at = now()
  WHERE payout_lock_enabled = TRUE AND payout_unlock_at IS NOT NULL AND now() >= payout_unlock_at;
  SELECT * INTO v_settings FROM public.system_settings ORDER BY updated_at DESC LIMIT 1;
  RETURN v_settings;
END
$$;


ALTER FUNCTION "public"."auto_unlock_payouts"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_upgrade_influencer_tier"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF NEW.is_verified = TRUE AND (OLD.is_verified IS NULL OR OLD.is_verified = FALSE) THEN
    -- Check if user qualifies for influencer tier
    PERFORM check_influencer_eligibility(NEW.id);
    -- This can be called from application logic
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_upgrade_influencer_tier"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."award_birthday_bonus"("p_user_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  user_birthday DATE;
  is_verified BOOLEAN;
  last_award DATE;
  current_date DATE := CURRENT_DATE;
  current_year INTEGER := EXTRACT(YEAR FROM current_date);
BEGIN
  -- Get user birthday info
  SELECT date_of_birth, verified_birthday, last_birthday_award
  INTO user_birthday, is_verified, last_award
  FROM user_profiles
  WHERE id = p_user_id;

  -- Check if birthday is today and verified
  IF user_birthday IS NOT NULL AND is_verified = TRUE AND
     EXTRACT(MONTH FROM user_birthday) = EXTRACT(MONTH FROM current_date) AND
     EXTRACT(DAY FROM user_birthday) = EXTRACT(DAY FROM current_date) THEN

    -- Check if not already awarded this year
    IF last_award IS NULL OR EXTRACT(YEAR FROM last_award) != current_year THEN
      -- Award 10,000 trollmonds (free_coin_balance)
      UPDATE user_profiles
      SET free_coin_balance = free_coin_balance + 10000,
          last_birthday_award = current_date
      WHERE id = p_user_id;

      -- Log the transaction
      INSERT INTO coin_transactions (
        user_id,
        amount,
        transaction_type,
        description,
        created_at
      ) VALUES (
        p_user_id,
        10000,
        'birthday_bonus',
        'Happy Birthday! 10,000 Trollmonds awarded',
        NOW()
      );

      RETURN TRUE;
    END IF;
  END IF;

  RETURN FALSE;
END;
$$;


ALTER FUNCTION "public"."award_birthday_bonus"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."award_birthday_coins_if_eligible"("p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_profile RECORD;
  v_birthday DATE;
  v_today DATE;
  v_coins_awarded INTEGER := 1000;
  v_result JSONB;
BEGIN
  -- Get user profile
  SELECT * INTO v_profile
  FROM public.user_profiles
  WHERE id = p_user_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;

  -- Check if user has date_of_birth
  IF v_profile.date_of_birth IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'No birthday set');
  END IF;

  v_birthday := v_profile.date_of_birth;
  v_today := CURRENT_DATE;

  -- Check if today is user's birthday (month and day match)
  IF EXTRACT(MONTH FROM v_birthday) = EXTRACT(MONTH FROM v_today) 
     AND EXTRACT(DAY FROM v_birthday) = EXTRACT(DAY FROM v_today) THEN
    
    -- Check if already awarded today (check last_birthday_coins_awarded)
    IF v_profile.last_birthday_coins_awarded IS NOT NULL 
       AND v_profile.last_birthday_coins_awarded::DATE = v_today THEN
      RETURN jsonb_build_object('success', false, 'error', 'Already awarded today');
    END IF;

    -- Award coins
    UPDATE public.user_profiles
    SET 
      paid_coin_balance = COALESCE(paid_coin_balance, 0) + v_coins_awarded,
      last_birthday_coins_awarded = v_today,
      updated_at = NOW()
    WHERE id = p_user_id;

    RETURN jsonb_build_object(
      'success', true,
      'coins_awarded', v_coins_awarded,
      'message', 'Birthday coins awarded!'
    );
  ELSE
    RETURN jsonb_build_object('success', false, 'error', 'Not your birthday today');
  END IF;
END;
$$;


ALTER FUNCTION "public"."award_birthday_coins_if_eligible"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."award_birthday_coins_if_eligible"("p_user_id" "uuid") IS 'Awards 1000 troll_coins to user when they go live on their birthday (once per day)';



CREATE OR REPLACE FUNCTION "public"."award_empire_reward"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare
  v_reward empire_rewards;
begin
  -- If no recruiter, nothing to do
  if new.recruited_by is null then
    return new;
  end if;

  -- Fetch empire reward settings
  select * into v_reward
  from empire_rewards
  where trigger_event = 'user_join'
  and active = true
  limit 1;

  if not found then
    return new; -- safety off-switch
  end if;

  -- Add reward to wallet
  update wallets
  set trollmonds = trollmonds + v_reward.reward_amount
  where user_id = new.recruited_by;

  -- Log ledger entry
  insert into trollmond_ledger (user_id, amount, currency, reason)
  values (
    new.recruited_by,
    v_reward.reward_amount,
    v_reward.reward_currency,
    'Recruitment bonus: new user joined under Empire Partner program'
  );

  return new;
end;
$$;


ALTER FUNCTION "public"."award_empire_reward"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."award_family_badge"("p_family_id" "uuid", "p_badge_type" "text", "p_level" integer) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_badge_id uuid;
BEGIN
  SELECT id INTO v_badge_id
  FROM public.badge_definitions
  WHERE badge_type = p_badge_type AND level = p_level
  LIMIT 1;

  IF v_badge_id IS NOT NULL THEN
    INSERT INTO public.family_badges_earned(family_id, badge_id)
    VALUES (p_family_id, v_badge_id)
    ON CONFLICT (family_id, badge_id) DO NOTHING;
  END IF;
END;
$$;


ALTER FUNCTION "public"."award_family_badge"("p_family_id" "uuid", "p_badge_type" "text", "p_level" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."award_owc_for_session"("p_session_id" "uuid", "p_user_id" "uuid", "p_hours_worked" numeric, "p_officer_level" integer) RETURNS bigint
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_owc_per_hour BIGINT;
  v_owc_earned BIGINT;
BEGIN
  v_owc_per_hour := get_owc_per_hour(p_officer_level);
  v_owc_earned := FLOOR(v_owc_per_hour * p_hours_worked);

  -- Update session
  UPDATE officer_work_sessions
  SET owc_earned = v_owc_earned
  WHERE id = p_session_id;

  -- Update user profile
  UPDATE user_profiles
  SET 
    owc_balance = owc_balance + v_owc_earned,
    total_owc_earned = total_owc_earned + v_owc_earned
  WHERE id = p_user_id;

  -- Log transaction
  INSERT INTO owc_transactions (user_id, amount, transaction_type, source, session_id)
  VALUES (p_user_id, v_owc_earned, 'earned', 'shift', p_session_id);

  RETURN v_owc_earned;
END;
$$;


ALTER FUNCTION "public"."award_owc_for_session"("p_session_id" "uuid", "p_user_id" "uuid", "p_hours_worked" numeric, "p_officer_level" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."award_troll_coins"("user_id" "uuid", "stream_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  -- give 10 paid coins
  update user_profiles
  set paid_coin_balance = paid_coin_balance + 10
  where id = user_id;

  -- log transaction
  insert into coin_transactions (sender_id, receiver_id, amount, stream_id, type)
  values (user_id, user_id, 10, stream_id, 'troll_bonus');
end;
$$;


ALTER FUNCTION "public"."award_troll_coins"("user_id" "uuid", "stream_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."award_user_badge"("p_user_id" "uuid", "p_badge_type" "text", "p_level" integer) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_badge_id uuid;
BEGIN
  SELECT id INTO v_badge_id
  FROM public.badge_definitions
  WHERE badge_type = p_badge_type AND level = p_level
  LIMIT 1;

  IF v_badge_id IS NOT NULL THEN
    INSERT INTO public.user_badges_earned(user_id, badge_id)
    VALUES (p_user_id, v_badge_id)
    ON CONFLICT (user_id, badge_id) DO NOTHING;
  END IF;
END;
$$;


ALTER FUNCTION "public"."award_user_badge"("p_user_id" "uuid", "p_badge_type" "text", "p_level" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."ban_ip_address"("p_ip_address" "inet", "p_ban_reason" "text", "p_officer_id" "uuid", "p_ban_details" "text" DEFAULT NULL::"text", "p_banned_until" timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_officer_profile user_profiles%ROWTYPE;
  v_existing_ban ip_bans%ROWTYPE;
  v_affected_users integer;
BEGIN
  SELECT * INTO v_officer_profile
  FROM user_profiles
  WHERE id = p_officer_id
    AND (
      is_admin = true
      OR is_troll_officer = true
      OR is_lead_officer = true
      OR role IN ('admin', 'troll_officer', 'lead_troll_officer')
    );

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'You do not have permission to ban IP addresses.'
    );
  END IF;

  SELECT * INTO v_existing_ban
  FROM ip_bans
  WHERE ip_address = p_ip_address
    AND is_active = true
  ORDER BY created_at DESC
  LIMIT 1;

  SELECT COUNT(*) INTO v_affected_users
  FROM user_profiles
  WHERE last_known_ip = p_ip_address;

  IF FOUND THEN
    UPDATE ip_bans
    SET
      ban_reason = p_ban_reason,
      ban_details = COALESCE(p_ban_details, ban_details),
      banned_until = COALESCE(p_banned_until, banned_until),
      banned_by = p_officer_id,
      updated_at = now()
    WHERE id = v_existing_ban.id;

    RETURN jsonb_build_object(
      'success', true,
      'message', 'IP ban updated',
      'ban_id', v_existing_ban.id,
      'affected_users', v_affected_users
    );
  END IF;

  INSERT INTO ip_bans (
    ip_address,
    banned_by,
    ban_reason,
    ban_details,
    banned_until
  ) VALUES (
    p_ip_address,
    p_officer_id,
    p_ban_reason,
    p_ban_details,
    p_banned_until
  );

  RETURN jsonb_build_object(
    'success', true,
    'message', 'IP address banned successfully',
    'affected_users', v_affected_users
  );
END;
$$;


ALTER FUNCTION "public"."ban_ip_address"("p_ip_address" "inet", "p_ban_reason" "text", "p_officer_id" "uuid", "p_ban_details" "text", "p_banned_until" timestamp with time zone) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."ban_ip_address"("p_ip_address" "inet", "p_ban_reason" "text", "p_officer_id" "uuid", "p_ban_details" "text", "p_banned_until" timestamp with time zone) IS 'Allows officers to ban IP addresses for violations';



CREATE OR REPLACE FUNCTION "public"."ban_officer"("p_user_id" "uuid", "p_reason" "text" DEFAULT NULL::"text", "p_expires_at" timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_officer RECORD;
  v_actor RECORD;
BEGIN
  -- Get actor (must be admin or lead officer)
  SELECT * INTO v_actor
  FROM user_profiles
  WHERE id = auth.uid()
    AND (role = 'admin' OR is_admin = true OR is_lead_officer = true);

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Only admins and lead officers can ban officers');
  END IF;

  -- Get officer to ban
  SELECT * INTO v_officer
  FROM user_profiles
  WHERE id = p_user_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Officer not found');
  END IF;

  -- Ban the officer
  UPDATE user_profiles
  SET 
    is_banned = TRUE,
    banned_until = p_expires_at,
    is_officer_active = FALSE, -- Deactivate officer status
    updated_at = NOW()
  WHERE id = p_user_id;
  
  -- Store ban reason in metadata if metadata column exists
  BEGIN
    UPDATE user_profiles
    SET metadata = COALESCE(metadata, '{}'::jsonb) || jsonb_build_object('ban_reason', p_reason)
    WHERE id = p_user_id;
  EXCEPTION WHEN OTHERS THEN
    -- metadata column might not exist, ignore
    NULL;
  END;

  -- Log the action (if officer_actions table exists)
  BEGIN
    INSERT INTO officer_actions (
      officer_id,
      target_user_id,
      action_type,
      reason
    ) VALUES (
      auth.uid(), -- The officer performing the action
      p_user_id,  -- The target officer being banned
      'ban',
      p_reason
    );
  EXCEPTION WHEN OTHERS THEN
    -- Table might not exist or have different schema, ignore
    NULL;
  END;

  RETURN jsonb_build_object('success', TRUE, 'message', 'Officer banned successfully');
END;
$$;


ALTER FUNCTION "public"."ban_officer"("p_user_id" "uuid", "p_reason" "text", "p_expires_at" timestamp with time zone) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."ban_officer"("p_user_id" "uuid", "p_reason" "text", "p_expires_at" timestamp with time zone) IS 'Bans an officer (lead officers and admins only)';



CREATE OR REPLACE FUNCTION "public"."ban_user"("p_user_id" "uuid", "p_until" timestamp with time zone) RETURNS "void"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  UPDATE user_profiles SET no_ban_until = p_until, updated_at = now() WHERE id = p_user_id;
$$;


ALTER FUNCTION "public"."ban_user"("p_user_id" "uuid", "p_until" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."ban_user"("target" "uuid", "minutes" integer, "reason" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare
  v_actor_role text;
  v_is_admin boolean;
  v_is_lead boolean;
  v_is_officer boolean;
  v_target_is_admin boolean;
  v_until timestamptz;
begin
  -- Actor permissions
  select role, is_admin, is_lead_officer, is_troll_officer
  into v_actor_role, v_is_admin, v_is_lead, v_is_officer
  from public.user_profiles
  where id = auth.uid();

  if not (v_is_admin or v_is_lead or v_is_officer or v_actor_role in ('admin','lead_troll_officer','troll_officer')) then
    insert into public.moderation_actions(actor_id, target_user_id, action_type, reason, status, error_message)
    values (auth.uid(), target, 'ban_user', reason, 'failed', 'Not authorized');
    return jsonb_build_object('status','error','message','Not authorized');
  end if;

  -- Block banning admin
  select (role = 'admin' or is_admin = true)
  into v_target_is_admin
  from public.user_profiles
  where id = target;

  if v_target_is_admin then
    insert into public.moderation_actions(actor_id, target_user_id, action_type, reason, status, error_message)
    values (auth.uid(), target, 'ban_user', reason, 'failed', 'Cannot ban admin');
    return jsonb_build_object('status','error','message','Cannot ban admin');
  end if;

  -- Duration
  v_until := case when minutes > 0 then now() + (minutes || ' minutes')::interval else null end;

  update public.user_profiles
  set
    is_banned = true,
    banned_until = v_until,
    metadata = coalesce(metadata, '{}'::jsonb) || jsonb_build_object('ban_reason', reason),
    updated_at = now()
  where id = target;

  insert into public.moderation_actions(actor_id, target_user_id, action_type, reason, payload, status)
  values (
    auth.uid(),
    target,
    'ban_user',
    reason,
    jsonb_build_object('minutes', minutes, 'banned_until', v_until),
    'completed'
  );

  return jsonb_build_object('status','ok','banned_until', v_until);

exception when others then
  insert into public.moderation_actions(actor_id, target_user_id, action_type, reason, status, error_message)
  values (auth.uid(), target, 'ban_user', reason, 'failed', sqlerrm);
  return jsonb_build_object('status','error','message','Ban failed','error', sqlerrm);
end;
$$;


ALTER FUNCTION "public"."ban_user"("target" "uuid", "minutes" integer, "reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."block_cashouts_when_locked"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  lock_enabled boolean;
  unlock_at timestamptz;
BEGIN
  SELECT payout_lock_enabled, payout_unlock_at
  INTO lock_enabled, unlock_at
  FROM public.system_settings
  ORDER BY updated_at DESC
  LIMIT 1;

  IF lock_enabled = true AND now() < unlock_at THEN
    RAISE EXCEPTION 'Payouts are locked during Launch Trial Mode. Unlocks at %', unlock_at;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."block_cashouts_when_locked"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."broadcast_seats_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."broadcast_seats_updated_at"() OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."streams" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "broadcaster_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "category" "text",
    "status" "text" DEFAULT 'live'::"text",
    "start_time" timestamp with time zone DEFAULT "now"(),
    "end_time" timestamp with time zone,
    "current_viewers" integer DEFAULT 0,
    "total_gifts_coins" bigint DEFAULT 0,
    "total_unique_gifters" integer DEFAULT 0,
    "total_free_gifts" bigint DEFAULT 0,
    "total_earnings_usd" numeric(12,2) DEFAULT 0,
    "final_viewers" integer,
    "final_total_coins" bigint,
    "final_earnings_usd" numeric(12,2),
    "thumbnail_url" "text",
    "agora_channel" "text",
    "agora_token" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "owner_id" "uuid",
    "livekit_url" "text",
    "user_id" "uuid",
    "room_name" "text",
    "is_live" boolean DEFAULT false,
    "max_beams" integer DEFAULT 1,
    "current_participants" integer DEFAULT 1,
    "started_at" timestamp with time zone DEFAULT "now"(),
    "ended_at" timestamp with time zone,
    "duration" interval GENERATED ALWAYS AS (("ended_at" - "started_at")) STORED,
    "livekit_room_name" "text",
    "is_testing_mode" boolean DEFAULT false,
    "popularity" integer DEFAULT 0 NOT NULL,
    "viewer_count" integer DEFAULT 0 NOT NULL,
    "streamer_id" "uuid",
    "livekit_room" "text",
    "recording_url" "text",
    "recording_storage_path" "text",
    "save_requested" boolean DEFAULT false,
    "save_requested_by" "uuid",
    "save_requested_at" timestamp with time zone,
    "saved_to_admin_archive" boolean DEFAULT false,
    "saved_at" timestamp with time zone,
    "audience_type" "text" DEFAULT 'public'::"text",
    "is_paid" boolean DEFAULT false,
    "entry_price_coins" bigint DEFAULT 0,
    "allow_gifts" boolean DEFAULT true,
    "max_guest_slots" integer DEFAULT 0,
    "description" "text",
    "pricing_type" "text" DEFAULT 'free'::"text",
    "pricing_value" integer DEFAULT 0,
    "gift_multiplier" "text" DEFAULT 'off'::"text",
    "like_price" "text" DEFAULT '1'::"text",
    "family_xp_bonus" boolean DEFAULT false,
    "family_coin_bonus" boolean DEFAULT false,
    "notify_followers" boolean DEFAULT false,
    "notify_family" boolean DEFAULT false,
    "allow_officer_free_join" boolean DEFAULT true,
    "moderator_mode" boolean DEFAULT false,
    "total_likes" integer DEFAULT 0,
    "host_user_id" "uuid",
    "is_private" boolean DEFAULT false,
    "box_count" integer DEFAULT 0
);

ALTER TABLE ONLY "public"."streams" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."streams" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."build_recording_path"("stream_record" "public"."streams") RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  started timestamptz;
  ts text;
BEGIN
  started := COALESCE(stream_record.started_at, NOW());
  ts := to_char(started, 'YYYY-MM-DD_HH24MISS');
  RETURN 'recordings/' || stream_record.streamer_id || '/' || ts || '_' || stream_record.id || '.mp4';
END;
$$;


ALTER FUNCTION "public"."build_recording_path"("stream_record" "public"."streams") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."buy_broadcast_theme"("p_theme_slug" "text", "p_set_active" boolean DEFAULT true) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
declare
  v_user_id uuid := auth.uid();
  v_theme record;
  v_balance integer;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select *
  into v_theme
  from public.broadcast_background_themes
  where slug = p_theme_slug
    and is_active = true;

  if not found then
    raise exception 'Theme not found or inactive';
  end if;

  -- already owned?
  if exists (
    select 1 from public.user_broadcast_theme_purchases
    where user_id = v_user_id and theme_id = v_theme.id
  ) then
    return jsonb_build_object(
      'ok', true,
      'already_owned', true,
      'theme_id', v_theme.id,
      'slug', v_theme.slug
    );
  end if;

  -- get and lock user row (prevents race)
  select coin_balance
  into v_balance
  from public.profiles
  where id = v_user_id
  for update;

  if v_balance is null then
    raise exception 'Profile not found';
  end if;

  if v_balance < v_theme.price_coins then
    raise exception 'Insufficient coins';
  end if;

  -- deduct
  update public.profiles
  set coin_balance = coin_balance - v_theme.price_coins
  where id = v_user_id;

  -- record purchase
  insert into public.user_broadcast_theme_purchases(user_id, theme_id)
  values (v_user_id, v_theme.id);

  -- log coin spend
  insert into public.coin_transactions(user_id, delta, reason, meta)
  values (
    v_user_id,
    -v_theme.price_coins,
    'broadcast_theme_purchase',
    jsonb_build_object('theme_id', v_theme.id, 'theme_slug', v_theme.slug)
  );

  -- set active (optional)
  if p_set_active then
    insert into public.user_broadcast_theme_state(user_id, active_theme_id, updated_at)
    values (v_user_id, v_theme.id, now())
    on conflict (user_id)
    do update set active_theme_id = excluded.active_theme_id, updated_at = now();
  end if;

  return jsonb_build_object(
    'ok', true,
    'purchased', true,
    'theme_id', v_theme.id,
    'slug', v_theme.slug,
    'price_coins', v_theme.price_coins
  );
end;
$$;


ALTER FUNCTION "public"."buy_broadcast_theme"("p_theme_slug" "text", "p_set_active" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."buy_entrance_effect"("effect_uuid" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare
  v_price int;
  v_balance int;
begin
  select price_coins into v_price
  from public.entrance_effects
  where id = effect_uuid and is_active = true;

  if v_price is null then
    return jsonb_build_object('status','error','message','Effect not found');
  end if;

  -- example wallet storage (CHANGE THIS TO YOUR REAL BALANCE COLUMN)
  select troll_coins into v_balance
  from public.user_profiles
  where id = auth.uid();

  if v_balance < v_price then
    return jsonb_build_object('status','error','message','Not enough coins');
  end if;

  update public.user_profiles
  set troll_coins = troll_coins - v_price
  where id = auth.uid();

  insert into public.user_entrance_effects(user_id, effect_id)
  values(auth.uid(), effect_uuid)
  on conflict do nothing;

  return jsonb_build_object('status','ok','message','Purchased');
end;
$$;


ALTER FUNCTION "public"."buy_entrance_effect"("effect_uuid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."buy_live_snack"("p_stream_id" "uuid", "p_snack_key" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_actor uuid;
  v_stream record;
  v_profile record;
  v_is_broadcaster boolean := false;
  v_base_cost bigint;
  v_cost bigint;
  v_delta integer;
  v_before integer;
  v_after integer;
  v_last_purchase timestamptz;
  v_cooldown_seconds integer := 30;
  v_global_cooldown_seconds integer := 12;
  v_effect text := NULL;
BEGIN
  v_actor := auth.uid();
  IF v_actor IS NULL THEN
    RAISE EXCEPTION 'Authentication required';
  END IF;

  SELECT id, broadcaster_id, is_live
  INTO v_stream
  FROM public.streams
  WHERE id = p_stream_id;

  IF v_stream IS NULL OR v_stream.is_live IS DISTINCT FROM true THEN
    RETURN jsonb_build_object('success', false, 'error', 'Stream is not live');
  END IF;

  SELECT id, paid_coin_balance
  INTO v_profile
  FROM public.user_profiles
  WHERE id = v_actor;

  IF v_profile IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Profile not found');
  END IF;

  v_is_broadcaster := (v_stream.broadcaster_id = v_actor);

  -- Cooldowns
  SELECT MAX(created_at)
  INTO v_last_purchase
  FROM public.stream_snack_purchases
  WHERE user_id = v_actor
    AND stream_id = p_stream_id;

  IF v_last_purchase IS NOT NULL
     AND v_last_purchase > now() - make_interval(secs => v_global_cooldown_seconds) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Slow down (cooldown)');
  END IF;

  SELECT MAX(created_at)
  INTO v_last_purchase
  FROM public.stream_snack_purchases
  WHERE user_id = v_actor
    AND stream_id = p_stream_id
    AND snack_key = p_snack_key;

  IF v_last_purchase IS NOT NULL
     AND v_last_purchase > now() - make_interval(secs => v_cooldown_seconds) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Snack on cooldown');
  END IF;

  -- Snack definitions
  IF p_snack_key = 'small' THEN
    v_base_cost := 50;
    v_delta := 10;
  ELSIF p_snack_key = 'medium' THEN
    v_base_cost := 120;
    v_delta := 25;
  ELSIF p_snack_key = 'large' THEN
    v_base_cost := 250;
    v_delta := 100;
  ELSIF p_snack_key = 'mystery' THEN
    v_base_cost := 150;
    v_delta := 5 + FLOOR(random() * 46)::integer;
    v_effect := (ARRAY['confetti','fire','neon_wave','crowd_roar'])[1 + FLOOR(random() * 4)::integer];
  ELSE
    RETURN jsonb_build_object('success', false, 'error', 'Unknown snack');
  END IF;

  v_cost := v_base_cost;

  IF v_is_broadcaster THEN
    v_cost := CEIL(v_base_cost * 1.6)::bigint;
    v_delta := FLOOR(v_delta * 0.7)::integer;
  ELSE
    v_delta := CEIL(v_delta * 1.2)::integer;
  END IF;

  UPDATE public.user_profiles
  SET paid_coin_balance = paid_coin_balance - v_cost,
      updated_at = now()
  WHERE id = v_actor
    AND paid_coin_balance >= v_cost;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Insufficient coins');
  END IF;

  v_before := public.apply_stream_momentum_decay(p_stream_id);

  IF p_snack_key = 'large' THEN
    v_after := 100;
  ELSE
    v_after := LEAST(100, GREATEST(0, v_before + v_delta));
  END IF;

  UPDATE public.stream_momentum
  SET momentum = v_after,
      updated_at = now()
  WHERE stream_id = p_stream_id;

  INSERT INTO public.stream_snack_purchases (
    stream_id,
    user_id,
    snack_key,
    coins_spent,
    momentum_delta,
    metadata
  )
  VALUES (
    p_stream_id,
    v_actor,
    p_snack_key,
    v_cost,
    v_after - v_before,
    jsonb_build_object(
      'is_broadcaster_purchase', v_is_broadcaster,
      'mystery_effect', v_effect
    )
  );

  RETURN jsonb_build_object(
    'success', true,
    'stream_id', p_stream_id,
    'snack_key', p_snack_key,
    'coins_spent', v_cost,
    'momentum_before', v_before,
    'momentum_after', v_after,
    'mystery_effect', v_effect
  );
END;
$$;


ALTER FUNCTION "public"."buy_live_snack"("p_stream_id" "uuid", "p_snack_key" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."buy_troll_pass"() RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_user_id uuid := auth.uid();
  v_profile record;
  v_cost bigint := 1500;
  v_now timestamptz := now();
  v_purchase_month date := date_trunc('month', now())::date;
  v_expires timestamptz := now() + interval '30 days';
BEGIN
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Authentication required');
  END IF;

  -- Lock row to prevent race/double-spend.
  SELECT
    id,
    role,
    is_admin,
    is_broadcaster,
    is_troll_officer,
    is_lead_officer,
    officer_role,
    paid_coin_balance,
    troll_pass_expires_at,
    troll_pass_last_purchased_at
  INTO v_profile
  FROM public.user_profiles
  WHERE id = v_user_id
  FOR UPDATE;

  IF v_profile IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Profile not found');
  END IF;

  -- Viewer-only enforcement: Troll Pass does not grant streaming/officer power.
  IF v_profile.is_admin = true OR v_profile.role = 'admin' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Admins cannot purchase Troll Pass');
  END IF;

  IF v_profile.is_troll_officer = true
     OR v_profile.role = 'troll_officer'
     OR v_profile.is_lead_officer = true
     OR v_profile.officer_role IS NOT NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Officers cannot purchase Troll Pass');
  END IF;

  IF v_profile.is_broadcaster = true OR v_profile.role = 'broadcaster' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Broadcasters cannot purchase Troll Pass');
  END IF;

  -- Must not already have an active pass.
  IF v_profile.troll_pass_expires_at IS NOT NULL
     AND v_profile.troll_pass_expires_at > v_now THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Troll Pass is already active',
      'expires_at', v_profile.troll_pass_expires_at
    );
  END IF;

  -- One-time per calendar month, even if expiration is edited.
  IF v_profile.troll_pass_last_purchased_at IS NOT NULL
     AND date_trunc('month', v_profile.troll_pass_last_purchased_at) = date_trunc('month', v_now) THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Troll Pass can only be purchased once per month'
    );
  END IF;

  IF COALESCE(v_profile.paid_coin_balance, 0) < v_cost THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Insufficient paid coins',
      'required', v_cost
    );
  END IF;

  -- Deduct paid coins (no refunds).
  UPDATE public.user_profiles
  SET
    paid_coin_balance = paid_coin_balance - v_cost,
    troll_pass_active = true,
    troll_pass_expires_at = v_expires,
    troll_pass_last_purchased_at = v_now,
    updated_at = v_now
  WHERE id = v_user_id
    AND paid_coin_balance >= v_cost;

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Insufficient paid coins',
      'required', v_cost
    );
  END IF;

  BEGIN
    INSERT INTO public.troll_pass_purchases (
      user_id,
      purchase_month,
      coins_spent,
      purchased_at,
      expires_at
    )
    VALUES (
      v_user_id,
      v_purchase_month,
      v_cost,
      v_now,
      v_expires
    );
  EXCEPTION
    WHEN unique_violation THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'Troll Pass can only be purchased once per month'
      );
  END;

  -- Best-effort coin transaction log
  BEGIN
    INSERT INTO public.coin_transactions (
      user_id,
      type,
      amount,
      coin_type,
      description,
      metadata,
      created_at
    )
    VALUES (
      v_user_id,
      'troll_pass_purchase',
      -v_cost,
      'paid',
      'Troll Pass (30 days)',
      jsonb_build_object('expires_at', v_expires),
      v_now
    );
  EXCEPTION
    WHEN undefined_table THEN NULL;
    WHEN insufficient_privilege THEN NULL;
    WHEN check_violation THEN NULL;
  END;

  RETURN jsonb_build_object(
    'success', true,
    'active', true,
    'expires_at', v_expires,
    'coins_spent', v_cost
  );
END;
$$;


ALTER FUNCTION "public"."buy_troll_pass"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_eviction_risk"("p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) RETURNS integer
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT GREATEST(0, 50 -
    (
      COALESCE((SELECT SUM(risk_reduction) FROM public.trollstown_upgrade_config WHERE upgrade_type='materials'  AND level <= p_materials_level), 0) +
      COALESCE((SELECT SUM(risk_reduction) FROM public.trollstown_upgrade_config WHERE upgrade_type='furniture'  AND level <= p_furniture_level), 0) +
      COALESCE((SELECT SUM(risk_reduction) FROM public.trollstown_upgrade_config WHERE upgrade_type='appliances' AND level <= p_appliances_level), 0) +
      COALESCE((SELECT SUM(risk_reduction) FROM public.trollstown_upgrade_config WHERE upgrade_type='security'   AND level <= p_security_level), 0)
    )
  )::INTEGER;
$$;


ALTER FUNCTION "public"."calculate_eviction_risk"("p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_eviction_risk"("p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) IS 'Calculates eviction risk based on upgrade levels';



CREATE OR REPLACE FUNCTION "public"."calculate_level"("xp" bigint) RETURNS integer
    LANGUAGE "plpgsql" IMMUTABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF xp >= 400000 THEN RETURN 30;
  ELSIF xp >= 250000 THEN RETURN 25;
  ELSIF xp >= 150000 THEN RETURN 20;
  ELSIF xp >= 70000 THEN RETURN 15;
  ELSIF xp >= 30000 THEN RETURN 10;
  ELSIF xp >= 23000 THEN RETURN 9;
  ELSIF xp >= 17000 THEN RETURN 8;
  ELSIF xp >= 12000 THEN RETURN 7;
  ELSIF xp >= 8000 THEN RETURN 6;
  ELSIF xp >= 5000 THEN RETURN 5;
  ELSIF xp >= 3000 THEN RETURN 4;
  ELSIF xp >= 1500 THEN RETURN 3;
  ELSIF xp >= 500 THEN RETURN 2;
  ELSE RETURN 1;
  END IF;
END;
$$;


ALTER FUNCTION "public"."calculate_level"("xp" bigint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_lucky_multiplier"("spent_coins" bigint) RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  base_roll real;
  scale real := 1.0;
  result integer := NULL;
BEGIN
  -- Input validation
  IF spent_coins <= 0 THEN
    RETURN NULL;
  END IF;

  -- Apply scaling based on gift cost
  IF spent_coins > 2500 THEN
    scale := 0.25;
  ELSIF spent_coins > 500 THEN
    scale := 0.6;
  END IF;

  -- Generate random roll (0-100)
  base_roll := random() * 100;

  -- Check against scaled probabilities
  IF base_roll < (0.01 * scale) THEN
    result := 10000;  -- 0.01% base ‚Üí 0.0025% scaled for high spenders
  ELSIF base_roll < (0.26 * scale) THEN
    result := 1000;   -- 0.25% base ‚Üí 0.065% scaled for high spenders
  ELSIF base_roll < (1.26 * scale) THEN
    result := 500;    -- 1.0% base ‚Üí 0.25% scaled for high spenders
  ELSIF base_roll < (3.76 * scale) THEN
    result := 200;    -- 2.5% base ‚Üí 0.625% scaled for high spenders
  ELSIF base_roll < (9.76 * scale) THEN
    result := 100;    -- 6.0% base ‚Üí 1.5% scaled for high spenders
  END IF;

  RETURN result;
END;
$$;


ALTER FUNCTION "public"."calculate_lucky_multiplier"("spent_coins" bigint) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_lucky_multiplier"("spent_coins" bigint) IS 'Calculates lucky multiplier based on spent coins with scaling';



CREATE OR REPLACE FUNCTION "public"."calculate_property_value"("p_base_value" integer, "p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) RETURNS integer
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT ROUND(p_base_value *
    (1 +
      COALESCE((SELECT SUM(value_multiplier - 1) FROM public.trollstown_upgrade_config WHERE upgrade_type='materials'  AND level <= p_materials_level), 0) +
      COALESCE((SELECT SUM(value_multiplier - 1) FROM public.trollstown_upgrade_config WHERE upgrade_type='furniture'  AND level <= p_furniture_level), 0) +
      COALESCE((SELECT SUM(value_multiplier - 1) FROM public.trollstown_upgrade_config WHERE upgrade_type='appliances' AND level <= p_appliances_level), 0) +
      COALESCE((SELECT SUM(value_multiplier - 1) FROM public.trollstown_upgrade_config WHERE upgrade_type='security'   AND level <= p_security_level), 0)
    )
  )::INTEGER;
$$;


ALTER FUNCTION "public"."calculate_property_value"("p_base_value" integer, "p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_property_value"("p_base_value" integer, "p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) IS 'Calculates property value based on upgrade levels';



CREATE OR REPLACE FUNCTION "public"."calculate_rent"("p_base_rent" integer, "p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) RETURNS integer
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT ROUND(p_base_rent *
    (1 +
      COALESCE((SELECT SUM(rent_multiplier - 1) FROM public.trollstown_upgrade_config WHERE upgrade_type='materials'  AND level <= p_materials_level), 0) +
      COALESCE((SELECT SUM(rent_multiplier - 1) FROM public.trollstown_upgrade_config WHERE upgrade_type='furniture'  AND level <= p_furniture_level), 0) +
      COALESCE((SELECT SUM(rent_multiplier - 1) FROM public.trollstown_upgrade_config WHERE upgrade_type='appliances' AND level <= p_appliances_level), 0) +
      COALESCE((SELECT SUM(rent_multiplier - 1) FROM public.trollstown_upgrade_config WHERE upgrade_type='security'   AND level <= p_security_level), 0)
    )
  )::INTEGER;
$$;


ALTER FUNCTION "public"."calculate_rent"("p_base_rent" integer, "p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_rent"("p_base_rent" integer, "p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) IS 'Calculates rent based on upgrade levels';



CREATE OR REPLACE FUNCTION "public"."calculate_stream_ranking"("p_stream_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("stream_id" "uuid", "final_score" numeric, "rank_position" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    stream_record RECORD;
    viewer_score DECIMAL := 0;
    gift_score DECIMAL := 0;
    engagement_score DECIMAL := 0;
    trending_score DECIMAL := 0;
    freshness_score DECIMAL := 0;
    reputation_score DECIMAL := 0;
    total_score DECIMAL := 0;
BEGIN
    -- If specific stream provided, calculate for that one
    IF p_stream_id IS NOT NULL THEN
        SELECT * INTO stream_record FROM streams WHERE id = p_stream_id AND is_live = TRUE;

        IF FOUND THEN
            -- Calculate viewer score (0-20 points)
            viewer_score := LEAST(stream_record.current_viewers / 10.0, 20.0);

            -- Calculate gift velocity score (0-25 points) - gifts per minute
            SELECT COALESCE(SUM(amount) / GREATEST(EXTRACT(EPOCH FROM (NOW() - stream_record.created_at)) / 60, 1), 0)
            INTO gift_score
            FROM gifts
            WHERE stream_id = p_stream_id
            AND created_at >= NOW() - INTERVAL '10 minutes';

            gift_score := LEAST(gift_score * 2, 25.0);

            -- Calculate engagement score (0-15 points) - chat messages per minute
            SELECT COALESCE(COUNT(*) / GREATEST(EXTRACT(EPOCH FROM (NOW() - stream_record.created_at)) / 60, 1), 0)
            INTO engagement_score
            FROM messages
            WHERE stream_id = p_stream_id
            AND created_at >= NOW() - INTERVAL '5 minutes';

            engagement_score := LEAST(engagement_score * 0.5, 15.0);

            -- Calculate trending score (0-15 points) - recent viewer growth
            SELECT COALESCE(AVG(current_viewers), 0) INTO trending_score
            FROM stream_viewer_history
            WHERE stream_id = p_stream_id
            AND recorded_at >= NOW() - INTERVAL '5 minutes';

            trending_score := LEAST(trending_score / 20.0, 15.0);

            -- Calculate freshness bonus (0-10 points) - newer streams get bonus
            SELECT EXTRACT(EPOCH FROM (NOW() - stream_record.created_at)) / 3600 INTO freshness_score;
            freshness_score := GREATEST(10.0 - freshness_score, 0);

            -- Calculate creator reputation score (0-15 points)
            SELECT COALESCE(current_score / 10.0, 5.0) INTO reputation_score
            FROM user_reputation
            WHERE user_id = stream_record.broadcaster_id;

            reputation_score := LEAST(reputation_score, 15.0);

            -- Calculate final score
            total_score := viewer_score + gift_score + engagement_score + trending_score + freshness_score + reputation_score;

            -- Update ranking record
            INSERT INTO stream_ranking (
                stream_id, viewer_count, gift_velocity, engagement_score,
                trending_score, freshness_bonus, creator_reputation, final_score
            ) VALUES (
                p_stream_id, stream_record.current_viewers, gift_score, engagement_score,
                trending_score, freshness_score, reputation_score, total_score
            ) ON CONFLICT (stream_id) DO UPDATE SET
                viewer_count = stream_record.current_viewers,
                gift_velocity = gift_score,
                engagement_score = engagement_score,
                trending_score = trending_score,
                freshness_bonus = freshness_score,
                creator_reputation = reputation_score,
                final_score = total_score,
                last_updated = NOW();

            RETURN QUERY SELECT p_stream_id, total_score, 0;
        END IF;
    ELSE
        -- Calculate rankings for all live streams
        FOR stream_record IN SELECT * FROM streams WHERE is_live = TRUE ORDER BY created_at DESC LOOP
            -- Calculate scores for each stream (same logic as above)
            viewer_score := LEAST(stream_record.current_viewers / 10.0, 20.0);

            SELECT COALESCE(SUM(amount) / GREATEST(EXTRACT(EPOCH FROM (NOW() - stream_record.created_at)) / 60, 1), 0)
            INTO gift_score
            FROM gifts
            WHERE stream_id = stream_record.id
            AND created_at >= NOW() - INTERVAL '10 minutes';

            gift_score := LEAST(gift_score * 2, 25.0);

            SELECT COALESCE(COUNT(*) / GREATEST(EXTRACT(EPOCH FROM (NOW() - stream_record.created_at)) / 60, 1), 0)
            INTO engagement_score
            FROM messages
            WHERE stream_id = stream_record.id
            AND created_at >= NOW() - INTERVAL '5 minutes';

            engagement_score := LEAST(engagement_score * 0.5, 15.0);

            SELECT EXTRACT(EPOCH FROM (NOW() - stream_record.created_at)) / 3600 INTO freshness_score;
            freshness_score := GREATEST(10.0 - freshness_score, 0);

            SELECT COALESCE(current_score / 10.0, 5.0) INTO reputation_score
            FROM user_reputation
            WHERE user_id = stream_record.broadcaster_id;

            reputation_score := LEAST(reputation_score, 15.0);

            total_score := viewer_score + gift_score + engagement_score + trending_score + freshness_score + reputation_score;

            -- Update ranking record
            INSERT INTO stream_ranking (
                stream_id, viewer_count, gift_velocity, engagement_score,
                trending_score, freshness_bonus, creator_reputation, final_score
            ) VALUES (
                stream_record.id, stream_record.current_viewers, gift_score, engagement_score,
                trending_score, freshness_score, reputation_score, total_score
            ) ON CONFLICT (stream_id) DO UPDATE SET
                viewer_count = stream_record.current_viewers,
                gift_velocity = gift_score,
                engagement_score = engagement_score,
                trending_score = trending_score,
                freshness_bonus = freshness_score,
                creator_reputation = reputation_score,
                final_score = total_score,
                last_updated = NOW();

            RETURN QUERY SELECT stream_record.id, total_score, 0;
        END LOOP;

        -- Update rank positions
        UPDATE stream_ranking
        SET rank_position = ranked.position
        FROM (
            SELECT id, ROW_NUMBER() OVER (ORDER BY final_score DESC) as position
            FROM stream_ranking
            WHERE last_updated >= NOW() - INTERVAL '5 minutes'
        ) ranked
        WHERE stream_ranking.id = ranked.id;
    END IF;
END;
$$;


ALTER FUNCTION "public"."calculate_stream_ranking"("p_stream_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."can_ban"() RETURNS boolean
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT (public.get_effective_privileges()).can_ban_users;
$$;


ALTER FUNCTION "public"."can_ban"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cancel_cashout_request"("p_request_id" "uuid", "p_user_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_request RECORD;
  cashout_coin_col text;
  coin_amount bigint;
  sql_text text;
BEGIN

  -- Detect coin column
  SELECT column_name INTO cashout_coin_col
  FROM information_schema.columns
  WHERE table_schema='public'
    AND table_name='cashout_requests'
    AND column_name IN (
      'requested_coins',
      'amount_coins',
      'coins',
      'coin_amount',
      'troll_coins',
      'requested_amount',
      'requested_troll_coins'
    )
  ORDER BY CASE column_name
    WHEN 'requested_coins' THEN 1
    WHEN 'amount_coins' THEN 2
    WHEN 'coins' THEN 3
    WHEN 'coin_amount' THEN 4
    WHEN 'troll_coins' THEN 5
    WHEN 'requested_amount' THEN 6
    WHEN 'requested_troll_coins' THEN 7
    ELSE 999
  END
  LIMIT 1;

  IF cashout_coin_col IS NULL THEN
    RAISE EXCEPTION 'No coin amount column found in cashout_requests';
  END IF;

  sql_text := format(
    'SELECT *, %I as coin_amount FROM public.cashout_requests WHERE id=$1 AND user_id=$2',
    cashout_coin_col
  );

  EXECUTE sql_text INTO v_request USING p_request_id, p_user_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Request not found or access denied';
  END IF;

  IF v_request.status != 'pending' THEN
    RAISE EXCEPTION 'Only pending requests can be cancelled';
  END IF;

  coin_amount := v_request.coin_amount;

  UPDATE public.user_profiles
  SET reserved_troll_coins = GREATEST(0, COALESCE(reserved_troll_coins, 0) - coin_amount)
  WHERE id = p_user_id;

  UPDATE public.cashout_requests
  SET status = 'cancelled', updated_at = now()
  WHERE id = p_request_id;
END;
$_$;


ALTER FUNCTION "public"."cancel_cashout_request"("p_request_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_concurrent_login"("p_user_id" "uuid", "p_current_session_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    active_session_count INTEGER;
BEGIN
    -- Count active sessions for this user, excluding the current session
    SELECT COUNT(*) INTO active_session_count
    FROM active_sessions
    WHERE user_id = p_user_id
      AND session_id != p_current_session_id
      AND is_active = TRUE
      AND created_at > NOW() - INTERVAL '30 minutes';
    
    -- Return true if there are other active sessions (concurrent login detected)
    RETURN active_session_count > 0;
END;
$$;


ALTER FUNCTION "public"."check_concurrent_login"("p_user_id" "uuid", "p_current_session_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."check_concurrent_login"("p_user_id" "uuid", "p_current_session_id" "uuid") IS 'Check if user has active sessions on other devices';



CREATE OR REPLACE FUNCTION "public"."check_daily_login"("p_user_id" "uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  today date := current_date;
  row_exists boolean;
  already_claimed boolean := false;
  new_streak int := 1;
  reward int := 250; -- daily reward amount (change if needed)
begin
  -- Ensure row exists
  select exists(select 1 from daily_logins where user_id = p_user_id)
  into row_exists;

  if not row_exists then
    insert into daily_logins (user_id, last_login_date, streak)
    values (p_user_id, today, 1);

  else
    -- If last login was today, already claimed
    if (select last_login_date from daily_logins where user_id = p_user_id) = today then
      already_claimed := true;
    else
      -- Update streak
      if (select last_login_date from daily_logins where user_id = p_user_id) = today - interval '1 day' then
        new_streak := (select streak from daily_logins where user_id = p_user_id) + 1;
      else
        new_streak := 1;
      end if;

      update daily_logins
      set last_login_date = today,
          streak = new_streak,
          updated_at = now()
      where user_id = p_user_id;
    end if;
  end if;

  -- If not already claimed, reward coins
  if not already_claimed then
    update user_profiles
    set troll_coins = coalesce(troll_coins,0) + reward
    where user_id = p_user_id;
  end if;

  return json_build_object(
    'claimed', not already_claimed,
    'reward', case when already_claimed then 0 else reward end,
    'streak', (select streak from daily_logins where user_id = p_user_id)
  );
end;
$$;


ALTER FUNCTION "public"."check_daily_login"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_family_admin"("check_family_id" "uuid", "check_user_id" "uuid") RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT EXISTS (
    SELECT 1 FROM family_members 
    WHERE family_id = check_family_id 
    AND user_id = check_user_id
    AND role IN ('leader', 'officer', 'royal_troll', 'founder')
  );
$$;


ALTER FUNCTION "public"."check_family_admin"("check_family_id" "uuid", "check_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_family_membership"("check_family_id" "uuid", "check_user_id" "uuid") RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT EXISTS (
    SELECT 1 FROM family_members 
    WHERE family_id = check_family_id 
    AND user_id = check_user_id
  );
$$;


ALTER FUNCTION "public"."check_family_membership"("check_family_id" "uuid", "check_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_influencer_eligibility"("p_user_id" "uuid") RETURNS json
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_followers_count INTEGER;
  v_coins_received INTEGER;
  v_is_verified BOOLEAN;
BEGIN
  SELECT 
    is_verified,
    (SELECT COUNT(*) FROM follows WHERE following_id = p_user_id) as followers,
    (SELECT COALESCE(SUM(coins), 0) FROM coin_transactions WHERE user_id = p_user_id AND type = 'gift_received')
  INTO v_is_verified, v_followers_count, v_coins_received
  FROM user_profiles
  WHERE id = p_user_id;

  IF v_is_verified = TRUE AND v_followers_count >= 200 AND v_coins_received >= 5000 THEN
    RETURN json_build_object(
      'eligible', true,
      'followers', v_followers_count,
      'coins_received', v_coins_received
    );
  END IF;

  RETURN json_build_object(
    'eligible', false,
    'followers', v_followers_count,
    'coins_received', v_coins_received,
    'needs_verified', NOT v_is_verified,
    'needs_followers', v_followers_count < 200,
    'needs_coins', v_coins_received < 5000
  );
END;
$$;


ALTER FUNCTION "public"."check_influencer_eligibility"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_insurance_expiry"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF NEW.expires_at <= NOW() THEN
    NEW.is_active = false;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."check_insurance_expiry"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_missed_court_appearances"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    missed_count INTEGER := 0;
    docket_record RECORD;
BEGIN
    FOR docket_record IN
        SELECT id
        FROM court_docket
        WHERE status = 'scheduled'
        AND scheduled_at < NOW() - INTERVAL '15 minutes' -- 15 minute grace period
    LOOP
        PERFORM process_missed_court(docket_record.id);
        missed_count := missed_count + 1;
    END LOOP;

    RETURN missed_count;
END;
$$;


ALTER FUNCTION "public"."check_missed_court_appearances"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."check_missed_court_appearances"() IS 'Processes missed court appearances (run by cron job)';



CREATE OR REPLACE FUNCTION "public"."check_perk_expiry"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF NEW.expires_at <= NOW() THEN
    NEW.is_active = false;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."check_perk_expiry"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_user_liked_post"("p_post_id" "uuid", "p_user_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN EXISTS(
    SELECT 1 FROM troll_wall_likes
    WHERE post_id = p_post_id AND user_id = p_user_id
  );
END;
$$;


ALTER FUNCTION "public"."check_user_liked_post"("p_post_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_violation_escalation"("p_user_id" "uuid", "p_violation_type" character varying, "p_severity_level" integer DEFAULT 1) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    violation_count INTEGER;
    applicable_rule RECORD;
    result JSONB;
BEGIN
    -- Count violations in the relevant time window
    SELECT COUNT(*) INTO violation_count
    FROM user_history
    WHERE user_id = p_user_id
      AND event_type = 'violation'
      AND metadata->>'violation_type' = p_violation_type
      AND (SELECT time_window_days FROM escalation_matrix
           WHERE violation_type = p_violation_type
           AND severity_level = p_severity_level
           ORDER BY violation_count_threshold DESC LIMIT 1) = 0
      OR created_at >= NOW() - INTERVAL '1 day' * (
          SELECT time_window_days FROM escalation_matrix
          WHERE violation_type = p_violation_type
          AND severity_level = p_severity_level
          ORDER BY violation_count_threshold DESC LIMIT 1
      );

    -- Find applicable escalation rule
    SELECT * INTO applicable_rule
    FROM escalation_matrix
    WHERE violation_type = p_violation_type
      AND severity_level = p_severity_level
      AND violation_count_threshold <= violation_count
      AND is_active = TRUE
    ORDER BY violation_count_threshold DESC
    LIMIT 1;

    IF applicable_rule IS NULL THEN
        -- No escalation needed
        RETURN jsonb_build_object(
            'escalate', FALSE,
            'violation_count', violation_count
        );
    END IF;

    -- Return escalation details
    RETURN jsonb_build_object(
        'escalate', TRUE,
        'consequence_type', applicable_rule.consequence_type,
        'consequence_duration_minutes', applicable_rule.consequence_duration_minutes,
        'court_required', applicable_rule.court_required,
        'auto_escalate', applicable_rule.auto_escalate,
        'points_deducted', applicable_rule.points_deducted,
        'violation_count', violation_count,
        'rule_id', applicable_rule.id
    );
END;
$$;


ALTER FUNCTION "public"."check_violation_escalation"("p_user_id" "uuid", "p_violation_type" character varying, "p_severity_level" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."claim_broadcast_seat"("p_room" "text", "p_seat_index" integer, "p_user_id" "uuid", "p_username" "text", "p_avatar_url" "text", "p_role" "text", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS TABLE("room" "text", "seat_index" integer, "user_id" "uuid", "username" "text", "avatar_url" "text", "role" "text", "metadata" "jsonb", "assigned_at" timestamp with time zone, "created" boolean, "is_owner" boolean)
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  existing_seat public.broadcast_seats%ROWTYPE;
  user_existing_seat public.broadcast_seats%ROWTYPE;
BEGIN
  LOCK public.broadcast_seats IN SHARE ROW EXCLUSIVE MODE;

  -- Check if user already has a seat in this room
  SELECT * INTO user_existing_seat
  FROM public.broadcast_seats bs
  WHERE bs.room = p_room AND bs.user_id = p_user_id
  FOR UPDATE;

  IF FOUND THEN
    room := user_existing_seat.room;
    seat_index := user_existing_seat.seat_index;
    user_id := user_existing_seat.user_id;
    username := user_existing_seat.username;
    avatar_url := user_existing_seat.avatar_url;
    role := user_existing_seat.role;
    metadata := user_existing_seat.metadata;
    assigned_at := user_existing_seat.assigned_at;
    created := FALSE;
    is_owner := TRUE;
    RETURN NEXT;
    RETURN;
  END IF;

  -- Check if the specific seat is already taken
  SELECT * INTO existing_seat
  FROM public.broadcast_seats bs
  WHERE bs.room = p_room AND bs.seat_index = p_seat_index
  FOR UPDATE;

  IF FOUND THEN
    room := existing_seat.room;
    seat_index := existing_seat.seat_index;
    user_id := existing_seat.user_id;
    username := existing_seat.username;
    avatar_url := existing_seat.avatar_url;
    role := existing_seat.role;
    metadata := existing_seat.metadata;
    assigned_at := existing_seat.assigned_at;
    created := FALSE;
    is_owner := (existing_seat.user_id = p_user_id);
    RETURN NEXT;
    RETURN;
  END IF;

  -- Seat is available, claim it
  INSERT INTO public.broadcast_seats AS bs (
    room, seat_index, user_id, username, avatar_url, role, metadata
  ) VALUES (
    p_room, p_seat_index, p_user_id, p_username, p_avatar_url, p_role, COALESCE(p_metadata, '{}'::JSONB)
  )
  RETURNING
    bs.room, bs.seat_index, bs.user_id, bs.username, bs.avatar_url, bs.role, bs.metadata, bs.assigned_at
  INTO
    room, seat_index, user_id, username, avatar_url, role, metadata, assigned_at;

  created := TRUE;
  is_owner := TRUE;
  RETURN NEXT;
END;
$$;


ALTER FUNCTION "public"."claim_broadcast_seat"("p_room" "text", "p_seat_index" integer, "p_user_id" "uuid", "p_username" "text", "p_avatar_url" "text", "p_role" "text", "p_metadata" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."claim_troll_event"("p_event_id" "uuid", "p_user_id" "uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  event_record RECORD;
  claim_count INTEGER;
  new_balance INTEGER;
BEGIN
  -- Get event details
  SELECT * INTO event_record
  FROM troll_events
  WHERE id = p_event_id AND active = true AND expires_at > NOW();

  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'error', 'Event not found or expired');
  END IF;

  -- Check if user already claimed
  SELECT COUNT(*) INTO claim_count
  FROM troll_event_claims
  WHERE event_id = p_event_id AND user_id = p_user_id;

  IF claim_count > 0 THEN
    RETURN json_build_object('success', false, 'error', 'Already claimed');
  END IF;

  -- Get user profile
  SELECT troll_coins INTO new_balance
  FROM user_profiles
  WHERE id = p_user_id;

  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'error', 'User not found');
  END IF;

  -- Record claim
  INSERT INTO troll_event_claims (event_id, user_id)
  VALUES (p_event_id, p_user_id);

  -- Add reward to user balance
  UPDATE user_profiles
  SET troll_coins = troll_coins + event_record.reward_amount
  WHERE id = p_user_id;

  -- Record transaction
  INSERT INTO coin_transactions (user_id, type, amount, description)
  VALUES (p_user_id, 'troll_event', event_record.reward_amount, 'Troll event reward');

  RETURN json_build_object(
    'success', true,
    'reward_amount', event_record.reward_amount,
    'new_balance', new_balance + event_record.reward_amount
  );
END;
$$;


ALTER FUNCTION "public"."claim_troll_event"("p_event_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cleanup_inactive_sessions"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    -- Delete sessions older than 30 days
    DELETE FROM active_sessions
    WHERE created_at < NOW() - INTERVAL '30 days';
    
    -- Delete inactive sessions older than 1 hour
    DELETE FROM active_sessions
    WHERE is_active = FALSE AND last_active < NOW() - INTERVAL '1 hour';
END;
$$;


ALTER FUNCTION "public"."cleanup_inactive_sessions"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."cleanup_inactive_sessions"() IS 'Cleanup old and inactive sessions';



CREATE OR REPLACE FUNCTION "public"."clear_expired_username_effects"() RETURNS "void"
    LANGUAGE "sql"
    AS $$
  update user_profiles
  set username_effect = null,
      username_effect_expires_at = null
  where username_effect is not null
    and username_effect_expires_at is not null
    and username_effect_expires_at <= now();
$$;


ALTER FUNCTION "public"."clear_expired_username_effects"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."clear_top_streams"() RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- Clear any top streams tracking (if you have a top_streams table)
  -- Or reset stream rankings
  UPDATE streams
  SET is_featured = FALSE,
      featured_until = NULL
  WHERE is_featured = TRUE;

  RETURN jsonb_build_object('success', TRUE, 'message', 'Top streams cleared');
END;
$$;


ALTER FUNCTION "public"."clear_top_streams"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."clock_in_from_slot"("p_slot_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_slot RECORD;
  v_officer_id UUID;
  v_shift_start TIMESTAMPTZ;
BEGIN
  -- Get slot details
  SELECT * INTO v_slot
  FROM officer_shift_slots
  WHERE id = p_slot_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Shift slot not found');
  END IF;

  -- Verify officer
  v_officer_id := auth.uid();
  IF v_slot.officer_id != v_officer_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Unauthorized');
  END IF;

  -- Check if slot is in the past
  IF (v_slot.shift_date || ' ' || v_slot.shift_start_time)::TIMESTAMPTZ < NOW() THEN
    RETURN jsonb_build_object('success', false, 'error', 'Cannot clock in to past shift');
  END IF;

  -- Check if already has active shift
  IF EXISTS (
    SELECT 1 FROM officer_shift_logs
    WHERE officer_id = v_officer_id AND shift_end IS NULL
  ) THEN
    RETURN jsonb_build_object('success', false, 'error', 'You already have an active shift');
  END IF;

  -- Create shift log entry
  v_shift_start := (v_slot.shift_date || ' ' || v_slot.shift_start_time)::TIMESTAMPTZ;
  
  INSERT INTO officer_shift_logs (
    officer_id,
    shift_start,
    last_activity
  ) VALUES (
    v_officer_id,
    v_shift_start,
    NOW()
  );

  -- Update slot status to active
  UPDATE officer_shift_slots
  SET status = 'active', updated_at = NOW()
  WHERE id = p_slot_id;

  RETURN jsonb_build_object(
    'success', true,
    'message', 'Clocked in successfully',
    'shift_start', v_shift_start
  );
END;
$$;


ALTER FUNCTION "public"."clock_in_from_slot"("p_slot_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."clock_in_from_slot"("p_officer_id" "uuid", "p_slot_id" "uuid") RETURNS TABLE("shift_id" "uuid", "officer_id" "uuid", "slot_start" timestamp with time zone, "slot_end" timestamp with time zone, "clock_in" timestamp with time zone)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_slot officer_shift_slots%ROWTYPE;
  v_officer user_profiles%ROWTYPE;
BEGIN
  -- Load slot into v_slot
  SELECT *
  INTO v_slot
  FROM officer_shift_slots s
  WHERE s.id = p_slot_id;

  -- Load officer into v_officer
  SELECT up.*
  INTO v_officer
  FROM user_profiles up
  WHERE up.id = p_officer_id;

  -- Insert shift log
  RETURN QUERY
  INSERT INTO officer_shift_logs (
    officer_id,
    shift_start,
    shift_end,
    clock_in
  )
  VALUES (
    p_officer_id,
    v_slot.slot_start,
    v_slot.slot_end,
    NOW()
  )
  RETURNING id, officer_id, shift_start, shift_end, clock_in;

END;
$$;


ALTER FUNCTION "public"."clock_in_from_slot"("p_officer_id" "uuid", "p_slot_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."clock_out_and_complete_slot"("p_slot_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_slot RECORD;
  v_shift_log RECORD;
  v_hours_worked NUMERIC;
  v_coins_earned INTEGER;
BEGIN
  -- Get slot details
  SELECT * INTO v_slot
  FROM officer_shift_slots
  WHERE id = p_slot_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Shift slot not found');
  END IF;

  -- Verify officer
  IF v_slot.officer_id != auth.uid() THEN
    RETURN jsonb_build_object('success', false, 'error', 'Unauthorized');
  END IF;

  -- Find active shift log
  SELECT * INTO v_shift_log
  FROM officer_shift_logs
  WHERE officer_id = v_slot.officer_id
    AND shift_end IS NULL
  ORDER BY shift_start DESC
  LIMIT 1;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'No active shift found');
  END IF;

  -- Calculate hours worked
  v_hours_worked := EXTRACT(EPOCH FROM (NOW() - v_shift_log.shift_start)) / 3600.0;
  v_coins_earned := FLOOR(v_hours_worked * 10000000); -- 10 million coins per hour

  -- Update shift log
  UPDATE officer_shift_logs
  SET 
    shift_end = NOW(),
    hours_worked = v_hours_worked,
    coins_earned = v_coins_earned,
    updated_at = NOW()
  WHERE id = v_shift_log.id;

  -- Update slot status to completed
  UPDATE officer_shift_slots
  SET status = 'completed', updated_at = NOW()
  WHERE id = p_slot_id;

  RETURN jsonb_build_object(
    'success', true,
    'message', 'Clocked out successfully',
    'hours_worked', v_hours_worked,
    'coins_earned', v_coins_earned
  );
END;
$$;


ALTER FUNCTION "public"."clock_out_and_complete_slot"("p_slot_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."clock_out_and_complete_slot"("p_slot_id" "uuid") IS 'Clocks out an officer and awards coins (excludes admins)';



CREATE OR REPLACE FUNCTION "public"."complete_court_case"("p_docket_id" "uuid", "p_verdict" "text" DEFAULT 'resolved'::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    v_user_id UUID;
BEGIN
    -- Update docket status
    UPDATE court_docket
    SET
        status = 'completed',
        completed_at = NOW(),
        updated_at = NOW(),
        notes = COALESCE(notes, '') || ' Verdict: ' || p_verdict
    WHERE id = p_docket_id
    RETURNING user_id INTO v_user_id;

    -- Restore some reputation points for attending
    UPDATE user_profiles
    SET court_reputation_score = LEAST(100, court_reputation_score + 2)
    WHERE id = v_user_id;

    -- Create notification
    INSERT INTO notifications (
        user_id,
        type,
        title,
        message,
        metadata
    ) VALUES (
        v_user_id,
        'court_completed',
        'Court Case Resolved',
        'Your court case has been resolved.',
        jsonb_build_object(
            'docket_id', p_docket_id,
            'verdict', p_verdict
        )
    );
END;
$$;


ALTER FUNCTION "public"."complete_court_case"("p_docket_id" "uuid", "p_verdict" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."complete_court_case"("p_docket_id" "uuid", "p_verdict" "text") IS 'Marks a court case as completed with verdict';



CREATE OR REPLACE FUNCTION "public"."complete_orientation"("p_user_id" "uuid", "p_passed" boolean) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF p_passed THEN
    UPDATE officer_orientations
    SET status='passed', completed_at=now(), updated_at=now()
    WHERE user_id = p_user_id;

    UPDATE user_profiles
    SET is_officer_active = TRUE, updated_at = now()
    WHERE id = p_user_id;
  ELSE
    UPDATE officer_orientations
    SET status='failed', updated_at=now()
    WHERE user_id = p_user_id;
  END IF;
END;
$$;


ALTER FUNCTION "public"."complete_orientation"("p_user_id" "uuid", "p_passed" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."confirm_coin_purchase"("p_tx_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_user uuid;
  v_coins bigint;
BEGIN
  SELECT user_id, coins INTO v_user, v_coins FROM coin_transactions WHERE id = p_tx_id;
  IF v_user IS NULL THEN RETURN; END IF;
  UPDATE coin_transactions SET status = 'completed' WHERE id = p_tx_id;
  UPDATE user_profiles SET paid_coin_balance = paid_coin_balance + COALESCE(v_coins,0), updated_at = now() WHERE id = v_user;
END;
$$;


ALTER FUNCTION "public"."confirm_coin_purchase"("p_tx_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."contribute_trollmonds_pool"("p_stream_id" "uuid", "p_sender_id" "uuid", "p_base_paid_coins" bigint, "p_gift_id" "uuid" DEFAULT NULL::"uuid", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS bigint
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_actor uuid := auth.uid();
  v_role text := auth.role();
  v_enabled boolean;
  v_bp int;
  v_amount bigint := 0;
BEGIN
  IF p_stream_id IS NULL OR p_sender_id IS NULL THEN
    RETURN 0;
  END IF;

  IF p_base_paid_coins IS NULL OR p_base_paid_coins <= 0 THEN
    RETURN 0;
  END IF;

  IF v_role <> 'service_role'
     AND (v_actor IS NULL OR v_actor <> p_sender_id) THEN
    RAISE EXCEPTION 'Unauthorized';
  END IF;

  v_enabled := public.get_config_bool('trollmonds_enabled', true);
  IF NOT v_enabled THEN
    RETURN 0;
  END IF;

  v_bp := public.get_config_int('trollmonds_basis_points', 400);
  v_bp := GREATEST(0, LEAST(v_bp, 1000));

  v_amount := floor((p_base_paid_coins::numeric * v_bp) / 10000)::bigint;
  IF v_amount <= 0 THEN
    RETURN 0;
  END IF;

  INSERT INTO public.trollmonds_pools (stream_id, balance, last_contribution_at, updated_at)
  VALUES (p_stream_id, v_amount, now(), now())
  ON CONFLICT (stream_id)
  DO UPDATE SET
    balance = public.trollmonds_pools.balance + EXCLUDED.balance,
    last_contribution_at = now(),
    updated_at = now();

  INSERT INTO public.trollmonds_pool_contributions (
    stream_id, sender_id, gift_id,
    base_paid_coins, contributed_trollmonds, metadata
  )
  VALUES (
    p_stream_id, p_sender_id, p_gift_id,
    p_base_paid_coins, v_amount,
    COALESCE(p_metadata, '{}'::jsonb)
  );

  RETURN v_amount;
END;
$$;


ALTER FUNCTION "public"."contribute_trollmonds_pool"("p_stream_id" "uuid", "p_sender_id" "uuid", "p_base_paid_coins" bigint, "p_gift_id" "uuid", "p_metadata" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."convert_free_to_trollmonds"("p_user" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare
  v_wallet public.wallets;
  v_delta bigint;
begin
  select * into v_wallet from public.wallets where user_id = p_user for update;
  if not found or v_wallet.free_coins <= 0 then
    return;
  end if;
  v_delta := v_wallet.free_coins * 3;
  update public.wallets
    set trollmonds = trollmonds + v_delta,
        free_coins = 0,
        updated_at = now()
    where user_id = p_user;
  insert into public.trollmond_ledger(user_id, delta, reason)
  values (p_user, v_delta, 'conversion');
end;
$$;


ALTER FUNCTION "public"."convert_free_to_trollmonds"("p_user" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."convert_owc_to_paid"("p_user_id" "uuid", "p_owc_amount" bigint) RETURNS json
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_current_owc BIGINT;
  v_officer_level INTEGER;
  v_conversion_rate NUMERIC;
  v_base_troll_coins BIGINT;
  v_bonus_coins BIGINT;
  v_total_troll_coins BIGINT;
BEGIN
  -- Get current OWC balance and officer level
  SELECT owc_balance, officer_level
  INTO v_current_owc, v_officer_level
  FROM user_profiles
  WHERE id = p_user_id;

  IF v_current_owc < p_owc_amount THEN
    RETURN json_build_object('success', false, 'error', 'Insufficient OWC balance');
  END IF;

  IF v_officer_level IS NULL OR v_officer_level < 1 THEN
    RETURN json_build_object('success', false, 'error', 'Invalid officer level');
  END IF;

  -- Calculate conversion
  v_conversion_rate := get_owc_conversion_rate(v_officer_level);
  v_base_troll_coins := FLOOR(p_owc_amount * v_conversion_rate);
  v_bonus_coins := FLOOR(v_base_troll_coins * 0.10); -- 10% bonus
  v_total_troll_coins := v_base_troll_coins + v_bonus_coins;

  -- Deduct OWC and add troll_coins
  UPDATE user_profiles
  SET 
    owc_balance = owc_balance - p_owc_amount,
    troll_coins = COALESCE(troll_coins, 0) + v_total_troll_coins
  WHERE id = p_user_id;

  -- Log conversion transaction
  INSERT INTO owc_transactions (
    user_id, 
    amount, 
    transaction_type, 
    source, 
    conversion_rate, 
    troll_coins_received
  )
  VALUES (
    p_user_id, 
    -p_owc_amount, 
    'converted', 
    'manual_conversion', 
    v_conversion_rate, 
    v_total_troll_coins
  );

  -- Log bonus transaction
  INSERT INTO owc_transactions (
    user_id, 
    amount, 
    transaction_type, 
    source, 
    troll_coins_received
  )
  VALUES (
    p_user_id, 
    v_bonus_coins, 
    'bonus', 
    'conversion_bonus', 
    v_bonus_coins
  );

  RETURN json_build_object(
    'success', true,
    'owc_converted', p_owc_amount,
    'base_troll_coins', v_base_troll_coins,
    'bonus_coins', v_bonus_coins,
    'total_troll_coins', v_total_troll_coins,
    'conversion_rate', v_conversion_rate
  );
END;
$$;


ALTER FUNCTION "public"."convert_owc_to_paid"("p_user_id" "uuid", "p_owc_amount" bigint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."convert_owc_to_paid_coins"("p_owc" bigint, "p_level" integer) RETURNS bigint
    LANGUAGE "plpgsql" IMMUTABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_conversion_rate NUMERIC;
  v_base_paid_coins BIGINT;
  v_bonus_coins BIGINT;
BEGIN
  v_conversion_rate := get_owc_conversion_rate(p_level);
  v_base_paid_coins := FLOOR(p_owc * v_conversion_rate);
  v_bonus_coins := FLOOR(v_base_paid_coins * 0.10); -- 10% bonus
  RETURN v_base_paid_coins + v_bonus_coins;
END;
$$;


ALTER FUNCTION "public"."convert_owc_to_paid_coins"("p_owc" bigint, "p_level" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."convert_owc_to_troll_coins"("p_owc" bigint, "p_level" integer) RETURNS bigint
    LANGUAGE "plpgsql" IMMUTABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_conversion_rate NUMERIC;
  v_base_troll_coins BIGINT;
  v_bonus_coins BIGINT;
BEGIN
  v_conversion_rate := get_owc_conversion_rate(p_level);
  v_base_troll_coins := FLOOR(p_owc * v_conversion_rate);
  v_bonus_coins := FLOOR(v_base_troll_coins * 0.10); -- 10% bonus
  RETURN v_base_troll_coins + v_bonus_coins;
END;
$$;


ALTER FUNCTION "public"."convert_owc_to_troll_coins"("p_owc" bigint, "p_level" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."convert_paid_coins_to_trollmonds"("p_user_id" "uuid", "p_paid_coins" integer) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  user_record RECORD;
  trollmonds_to_add BIGINT;
BEGIN
  -- Validate input
  IF p_paid_coins <= 0 OR p_paid_coins % 100 != 0 THEN
    RETURN json_build_object('success', false, 'error', 'Invalid conversion amount. Must be multiples of 100.');
  END IF;

  -- Get user record
  SELECT * INTO user_record FROM user_profiles WHERE id = p_user_id;
  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'error', 'User not found.');
  END IF;

  -- Check balance
  IF (user_record.paid_coin_balance < p_paid_coins) THEN
    RETURN json_build_object('success', false, 'error', 'Insufficient paid coins.');
  END IF;

  -- Calculate trollmonds
  trollmonds_to_add := p_paid_coins * 100;

  -- Atomic update
  UPDATE user_profiles
  SET
    paid_coin_balance = paid_coin_balance - p_paid_coins,
    trollmond_balance = trollmond_balance + trollmonds_to_add
  WHERE id = p_user_id;

  -- Log transaction
  INSERT INTO trollmond_transactions (user_id, type, paid_coins_spent, trollmonds_added)
  VALUES (p_user_id, 'convert', p_paid_coins, trollmonds_to_add);

  RETURN json_build_object('success', true);
END;
$$;


ALTER FUNCTION "public"."convert_paid_coins_to_trollmonds"("p_user_id" "uuid", "p_paid_coins" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_appeal_docket"("p_user_id" "uuid", "p_appeal_reason" "text", "p_appeal_id" "uuid" DEFAULT NULL::"uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    v_docket_id UUID;
    v_scheduled_at TIMESTAMPTZ;
    v_next_slot TIMESTAMPTZ;
BEGIN
    -- Find next available court slot (next hour from now, avoiding conflicts)
    SELECT MIN(scheduled_at)
    INTO v_next_slot
    FROM court_docket
    WHERE scheduled_at > NOW()
    AND status = 'scheduled';

    IF v_next_slot IS NULL THEN
        v_scheduled_at := NOW() + INTERVAL '1 hour';
    ELSE
        -- Schedule 30 minutes after the next slot
        v_scheduled_at := v_next_slot + INTERVAL '30 minutes';
    END IF;

    -- Create docket entry
    INSERT INTO court_docket (user_id, case_type, scheduled_at, notes, appeal_id)
    VALUES (p_user_id, 'appeal', v_scheduled_at, p_appeal_reason, p_appeal_id)
    RETURNING id INTO v_docket_id;

    -- Create notification
    INSERT INTO notifications (
        user_id,
        type,
        title,
        message,
        metadata
    ) VALUES (
        p_user_id,
        'court_docket',
        'Appeal Hearing Scheduled',
        'Your appeal has been scheduled for court review.',
        jsonb_build_object(
            'docket_id', v_docket_id,
            'scheduled_at', v_scheduled_at,
            'case_type', 'appeal'
        )
    );

    RETURN v_docket_id;
END;
$$;


ALTER FUNCTION "public"."create_appeal_docket"("p_user_id" "uuid", "p_appeal_reason" "text", "p_appeal_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."create_appeal_docket"("p_user_id" "uuid", "p_appeal_reason" "text", "p_appeal_id" "uuid") IS 'Creates a docket entry when a user submits an appeal';



CREATE OR REPLACE FUNCTION "public"."create_city_event"("p_event_type" character varying, "p_title" character varying, "p_description" "text", "p_start_time" timestamp with time zone, "p_end_time" timestamp with time zone, "p_global_announcement" boolean DEFAULT false, "p_event_config" "jsonb" DEFAULT '{}'::"jsonb", "p_rewards_config" "jsonb" DEFAULT '{}'::"jsonb", "p_created_by" "uuid" DEFAULT NULL::"uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    event_id UUID;
BEGIN
    INSERT INTO city_events (
        event_type, title, description, start_time, end_time,
        global_announcement, event_config, rewards_config, created_by
    ) VALUES (
        p_event_type, p_title, p_description, p_start_time, p_end_time,
        p_global_announcement, p_event_config, p_rewards_config, p_created_by
    ) RETURNING id INTO event_id;

    -- Send global announcement if requested
    IF p_global_announcement THEN
        PERFORM send_notification(
            NULL, -- broadcast to all
            'city_event',
            'üéâ ' || p_title,
            p_description,
            jsonb_build_object(
                'event_id', event_id,
                'event_type', p_event_type,
                'start_time', p_start_time,
                'end_time', p_end_time
            )
        );
    END IF;

    RETURN event_id;
END;
$$;


ALTER FUNCTION "public"."create_city_event"("p_event_type" character varying, "p_title" character varying, "p_description" "text", "p_start_time" timestamp with time zone, "p_end_time" timestamp with time zone, "p_global_announcement" boolean, "p_event_config" "jsonb", "p_rewards_config" "jsonb", "p_created_by" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_court_case"("p_case_type" "text", "p_plaintiff_id" "uuid", "p_defendant_id" "uuid", "p_description" "text" DEFAULT NULL::"text", "p_court_session_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    v_template case_templates%ROWTYPE;
    v_case_id UUID;
    v_severity TEXT;
BEGIN
    -- Get Template
    SELECT * INTO v_template FROM case_templates WHERE case_type = p_case_type;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Invalid Case Type';
    END IF;
    
    v_severity := v_template.default_severity;

    -- Create Case
    INSERT INTO court_cases (
        case_type, severity, title, plaintiff_id, defendant_id, court_session_id, status
    ) VALUES (
        p_case_type, v_severity, p_case_type || ' Case', p_plaintiff_id, p_defendant_id, p_court_session_id, 'pending'
    ) RETURNING id INTO v_case_id;

    -- Add Participants
    -- Plaintiff
    INSERT INTO case_participants (case_id, user_id, role, permissions)
    VALUES (v_case_id, p_plaintiff_id, 'Plaintiff', '{"can_speak": true, "can_chat": true, "can_upload": true}');

    -- Defendant
    IF p_defendant_id IS NOT NULL THEN
        INSERT INTO case_participants (case_id, user_id, role, permissions)
        VALUES (v_case_id, p_defendant_id, 'Defendant', '{"can_speak": true, "can_chat": true, "can_upload": true}');
    END IF;
    
    -- Log Creation
    INSERT INTO case_audit_logs (case_id, actor_id, action, details)
    VALUES (v_case_id, p_plaintiff_id, 'Case Created', jsonb_build_object('type', p_case_type, 'severity', v_severity));

    RETURN jsonb_build_object('success', true, 'case_id', v_case_id);
END;
$$;


ALTER FUNCTION "public"."create_court_case"("p_case_type" "text", "p_plaintiff_id" "uuid", "p_defendant_id" "uuid", "p_description" "text", "p_court_session_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_family_stats_row"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  INSERT INTO public.family_stats (family_id)
  VALUES (NEW.id)
  ON CONFLICT (family_id) DO NOTHING;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."create_family_stats_row"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_family_tasks"("p_family_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  has_task_title BOOLEAN;
  has_title BOOLEAN;
BEGIN
  -- Verify caller is authorized (leader/officer/royal_troll) in either members table
  IF NOT (
    EXISTS (
      SELECT 1 FROM troll_family_members 
      WHERE family_id = p_family_id AND user_id = auth.uid() 
      AND role IN ('leader', 'officer', 'royal_troll')
    )
    OR
    EXISTS (
      SELECT 1 FROM family_members 
      WHERE family_id = p_family_id AND user_id = auth.uid() 
      AND role IN ('leader', 'officer', 'founder', 'admin')
    )
  ) THEN
    RAISE EXCEPTION 'Not authorized to create family tasks';
  END IF;

  -- Avoid duplicate active task sets
  IF EXISTS (
    SELECT 1 FROM family_tasks 
    WHERE family_id = p_family_id AND status = 'active'
  ) THEN
    RETURN jsonb_build_object('success', true, 'message', 'Active tasks already exist');
  END IF;

  -- Detect schema variant
  SELECT EXISTS(SELECT 1 FROM information_schema.columns WHERE table_name='family_tasks' AND column_name='task_title') INTO has_task_title;
  SELECT EXISTS(SELECT 1 FROM information_schema.columns WHERE table_name='family_tasks' AND column_name='title') INTO has_title;

  IF has_task_title THEN
    -- New schema: task_title/task_description + reward_family_* + metrics
    INSERT INTO family_tasks (
      family_id, task_title, task_description,
      reward_family_coins, reward_family_xp,
      goal_value, current_value, metric, status, expires_at
    ) VALUES
    (
      p_family_id,
      'Recruit New Trolls',
      'Grow your family by recruiting 3 new members this week.',
      500, 100,
      3, 0, 'family_members_recruited', 'active',
      NOW() + INTERVAL '7 days'
    ),
    (
      p_family_id,
      'Host a Clan Stream',
      'Start a live stream representing your family.',
      200, 50,
      1, 0, 'streams_started', 'active',
      NOW() + INTERVAL '3 days'
    ),
    (
      p_family_id,
      'Gift Raid',
      'Send 5 gifts to support other trolls.',
      300, 75,
      5, 0, 'gifts_sent', 'active',
      NOW() + INTERVAL '5 days'
    );
  ELSIF has_title THEN
    -- Legacy schema: title/description/category/reward_coins/reward_xp
    INSERT INTO family_tasks (
      family_id, title, description, category,
      reward_coins, reward_xp,
      status, expires_at
    ) VALUES
    (
      p_family_id,
      'Recruit New Trolls',
      'Grow your family by recruiting 3 new members this week.',
      'General',
      500, 100,
      'active',
      NOW() + INTERVAL '7 days'
    ),
    (
      p_family_id,
      'Host a Clan Stream',
      'Start a live stream representing your family.',
      'General',
      200, 50,
      'active',
      NOW() + INTERVAL '3 days'
    ),
    (
      p_family_id,
      'Gift Raid',
      'Send 5 gifts to support other trolls.',
      'General',
      300, 75,
      'active',
      NOW() + INTERVAL '5 days'
    );
  ELSE
    RAISE EXCEPTION 'family_tasks schema not recognized';
  END IF;

  RETURN jsonb_build_object('success', true);
END;
$$;


ALTER FUNCTION "public"."create_family_tasks"("p_family_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_gifter_leaderboard_snapshot"("p_type" "text", "p_start" "date", "p_end" "date") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_lb_id uuid;
BEGIN
  -- Create leaderboard row
  INSERT INTO public.gift_leaderboards (leaderboard_type, start_date, end_date)
  VALUES (p_type, p_start, p_end)
  RETURNING id INTO v_lb_id;

  -- Insert top 100 gifters by total coins spent in range
  INSERT INTO public.gift_leaderboard_entries (
    leaderboard_id, user_id, rank, score, coins_spent, gifts_sent
  )
  SELECT
    v_lb_id,
    sender_id,
    ROW_NUMBER() OVER (ORDER BY SUM(coins_spent) DESC) AS rank,
    SUM(coins_spent) AS score,
    SUM(coins_spent) AS coins_spent,
    COUNT(*) AS gifts_sent
  FROM public.gift_transactions
  WHERE created_at >= p_start::timestamptz
    AND created_at < (p_end + INTERVAL '1 day')::timestamptz
  GROUP BY sender_id
  ORDER BY SUM(coins_spent) DESC
  LIMIT 100;

  RETURN v_lb_id;
END;
$$;


ALTER FUNCTION "public"."create_gifter_leaderboard_snapshot"("p_type" "text", "p_start" "date", "p_end" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_message_receipts"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
begin
  insert into public.message_receipts (message_id, user_id)
  select new.id, cm.user_id
  from public.conversation_members cm
  where cm.conversation_id = new.conversation_id
    and cm.user_id <> new.sender_id
  on conflict (message_id, user_id) do nothing;

  return new;
end;
$$;


ALTER FUNCTION "public"."create_message_receipts"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_notification"("recipient" "uuid", "message" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  insert into public.notifications (recipient_id, message)
  values (recipient, message);
end;
$$;


ALTER FUNCTION "public"."create_notification"("recipient" "uuid", "message" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_notification"("p_user_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_notification_id UUID;
BEGIN
  INSERT INTO notifications (user_id, type, title, message, metadata)
  VALUES (p_user_id, p_type, p_title, p_message, p_metadata)
  RETURNING id INTO v_notification_id;
  
  RETURN v_notification_id;
END;
$$;


ALTER FUNCTION "public"."create_notification"("p_user_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_metadata" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_profile_for_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  insert into public.profiles (id, email, username, avatar_url)
  values (new.id, new.email, split_part(new.email, '@', 1), null);
  return new;
end;
$$;


ALTER FUNCTION "public"."create_profile_for_new_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_tromody_session"("p_creator" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare sid uuid;
begin
  insert into public.tromody_sessions (created_by, status)
  values (p_creator, 'waiting')
  returning id into sid;
  return sid;
end;
$$;


ALTER FUNCTION "public"."create_tromody_session"("p_creator" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_violation_docket"("p_user_id" "uuid", "p_case_type" "text" DEFAULT 'violation'::"text", "p_notes" "text" DEFAULT ''::"text", "p_delay_hours" integer DEFAULT 24) RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    v_docket_id UUID;
    v_scheduled_at TIMESTAMPTZ;
BEGIN
    -- Calculate scheduled time
    v_scheduled_at := NOW() + (p_delay_hours || ' hours')::INTERVAL;

    -- Create docket entry
    INSERT INTO court_docket (user_id, case_type, scheduled_at, notes)
    VALUES (p_user_id, p_case_type, v_scheduled_at, p_notes)
    RETURNING id INTO v_docket_id;

    -- Deduct reputation points for violations
    UPDATE user_profiles
    SET court_reputation_score = GREATEST(0, court_reputation_score - 5)
    WHERE id = p_user_id;

    -- Create notification
    INSERT INTO notifications (
        user_id,
        type,
        title,
        message,
        metadata
    ) VALUES (
        p_user_id,
        'court_docket',
        'Court Docket Scheduled',
        'You have been scheduled for a court hearing regarding a recent violation.',
        jsonb_build_object(
            'docket_id', v_docket_id,
            'scheduled_at', v_scheduled_at,
            'case_type', p_case_type
        )
    );

    RETURN v_docket_id;
END;
$$;


ALTER FUNCTION "public"."create_violation_docket"("p_user_id" "uuid", "p_case_type" "text", "p_notes" "text", "p_delay_hours" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."create_violation_docket"("p_user_id" "uuid", "p_case_type" "text", "p_notes" "text", "p_delay_hours" integer) IS 'Creates a docket entry when a user receives a violation/warning';



CREATE OR REPLACE FUNCTION "public"."create_wall_post_reply"("p_original_post_id" "uuid", "p_content" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_reply_id UUID;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  INSERT INTO troll_wall_posts (user_id, post_type, content, reply_to_post_id)
  VALUES (v_user_id, 'text', p_content, p_original_post_id)
  RETURNING id INTO v_reply_id;

  RETURN v_reply_id;
END;
$$;


ALTER FUNCTION "public"."create_wall_post_reply"("p_original_post_id" "uuid", "p_content" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_wall_post_reply"("p_original_post_id" "uuid", "p_user_id" "uuid", "p_content" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE v_reply_id UUID;
BEGIN
  INSERT INTO troll_wall_posts (user_id, post_type, content, reply_to_post_id)
  VALUES (p_user_id, 'text', p_content, p_original_post_id)
  RETURNING id INTO v_reply_id;
  RETURN v_reply_id;
END;
$$;


ALTER FUNCTION "public"."create_wall_post_reply"("p_original_post_id" "uuid", "p_user_id" "uuid", "p_content" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_wallet_for_user"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  insert into wallets (user_id)
  values (new.id)
  on conflict (user_id) do nothing;

  return new;
end;
$$;


ALTER FUNCTION "public"."create_wallet_for_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."credit_coinback_bonus"("p_user_id" "uuid", "p_base_paid_coins" bigint, "p_source" "text", "p_related_gift_id" "uuid" DEFAULT NULL::"uuid", "p_related_external_id" "text" DEFAULT NULL::"text", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS bigint
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_actor uuid := auth.uid();
  v_role text := auth.role();
  v_enabled boolean;
  v_bp int;
  v_bonus bigint := 0;
BEGIN
  IF p_user_id IS NULL THEN
    RETURN 0;
  END IF;

  IF v_role <> 'service_role'
     AND (v_actor IS NULL OR v_actor <> p_user_id) THEN
    RAISE EXCEPTION 'Unauthorized';
  END IF;

  IF p_base_paid_coins IS NULL OR p_base_paid_coins <= 0 THEN
    RETURN 0;
  END IF;

  v_enabled := public.get_config_bool('coinback_enabled', true);
  IF NOT v_enabled THEN
    RETURN 0;
  END IF;

  v_bp := public.get_config_int('coinback_basis_points', 100);
  v_bp := GREATEST(0, LEAST(v_bp, 500));

  v_bonus := floor((p_base_paid_coins::numeric * v_bp) / 10000)::bigint;
  IF v_bonus <= 0 THEN
    RETURN 0;
  END IF;

  UPDATE public.user_profiles
  SET bonus_coin_balance = bonus_coin_balance + v_bonus,
      updated_at = now()
  WHERE id = p_user_id;

  INSERT INTO public.coinback_log (
    user_id, source, base_paid_coins, bonus_coins,
    related_gift_id, related_external_id, metadata
  )
  VALUES (
    p_user_id, p_source, p_base_paid_coins, v_bonus,
    p_related_gift_id, p_related_external_id,
    COALESCE(p_metadata, '{}'::jsonb)
  );

  RETURN v_bonus;
END;
$$;


ALTER FUNCTION "public"."credit_coinback_bonus"("p_user_id" "uuid", "p_base_paid_coins" bigint, "p_source" "text", "p_related_gift_id" "uuid", "p_related_external_id" "text", "p_metadata" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."credit_coins"("p_user_id" "uuid", "p_coins" integer, "p_paypal_capture_id" "text", "p_paypal_order_id" "text" DEFAULT NULL::"text", "p_package_id" "uuid" DEFAULT NULL::"uuid", "p_amount_usd" numeric DEFAULT NULL::numeric) RETURNS TABLE("success" boolean, "new_balance" integer, "error_message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_new_balance INTEGER;
  v_error_msg TEXT := NULL;
  v_success BOOLEAN := FALSE;
BEGIN
  -- Check if capture_id already exists (prevent double-credit)
  IF EXISTS (SELECT 1 FROM coin_transactions WHERE paypal_capture_id = p_paypal_capture_id) THEN
    v_error_msg := 'Transaction already processed';
    RETURN QUERY SELECT FALSE, 0::INTEGER, v_error_msg;
    RETURN;
  END IF;

  -- Start transaction
  BEGIN
    -- Insert transaction record
    INSERT INTO coin_transactions (
      user_id,
      package_id,
      paypal_order_id,
      paypal_capture_id,
      paypal_status,
      amount_usd,
      coins_granted
    ) VALUES (
      p_user_id,
      p_package_id,
      p_paypal_order_id,
      p_paypal_capture_id,
      'COMPLETED',
      p_amount_usd,
      p_coins
    );

    -- Credit coins to user profile
    UPDATE user_profiles
    SET 
      troll_coins = troll_coins + p_coins,
      updated_at = now()
    WHERE id = p_user_id;

    -- Get new balance
    SELECT troll_coins INTO v_new_balance FROM user_profiles WHERE id = p_user_id;

    v_success := TRUE;
    RETURN QUERY SELECT v_success, v_new_balance, NULL::TEXT;

  EXCEPTION WHEN OTHERS THEN
    v_error_msg := SQLERRM;
    RETURN QUERY SELECT FALSE, 0::INTEGER, v_error_msg;
  END;
END;
$$;


ALTER FUNCTION "public"."credit_coins"("p_user_id" "uuid", "p_coins" integer, "p_paypal_capture_id" "text", "p_paypal_order_id" "text", "p_package_id" "uuid", "p_amount_usd" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."deactivate_expired_perks"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_count INTEGER;
BEGIN
  UPDATE user_perks
  SET is_active = false, updated_at = NOW()
  WHERE is_active = true
    AND expires_at <= NOW();

  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$;


ALTER FUNCTION "public"."deactivate_expired_perks"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."deduct_call_minutes"("p_user_id" "uuid", "p_minutes" integer, "p_type" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_current_audio INTEGER := 0;
  v_current_video INTEGER := 0;
  v_new_audio INTEGER;
  v_new_video INTEGER;
BEGIN
  -- Get current balance
  SELECT COALESCE(audio_minutes, 0), COALESCE(video_minutes, 0)
  INTO v_current_audio, v_current_video
  FROM call_minutes
  WHERE user_id = p_user_id;

  -- Calculate new balances
  IF p_type = 'audio' THEN
    v_new_audio := GREATEST(0, v_current_audio - p_minutes);
    v_new_video := v_current_video;
  ELSE -- video uses 2x minutes
    v_new_audio := v_current_audio;
    v_new_video := GREATEST(0, v_current_video - (p_minutes * 2));
  END IF;

  -- Update balance
  UPDATE call_minutes
  SET 
    audio_minutes = v_new_audio,
    video_minutes = v_new_video,
    updated_at = NOW()
  WHERE user_id = p_user_id;
  
  -- Handle case where no row existed (shouldn't happen for deduction usually, but good to be safe)
  IF NOT FOUND THEN
    INSERT INTO call_minutes (user_id, audio_minutes, video_minutes)
    VALUES (p_user_id, 0, 0);
    v_new_audio := 0;
    v_new_video := 0;
  END IF;

  -- Return result
  RETURN jsonb_build_object(
    'success', true,
    'has_minutes', CASE WHEN p_type = 'audio' THEN v_new_audio > 0 ELSE v_new_video > 0 END,
    'audio_minutes', v_new_audio,
    'video_minutes', v_new_video
  );
END;
$$;


ALTER FUNCTION "public"."deduct_call_minutes"("p_user_id" "uuid", "p_minutes" integer, "p_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."deduct_coins"("p_user_id" "uuid", "p_amount" bigint, "p_coin_type" "text" DEFAULT 'paid'::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_current_balance bigint;
  v_coin_type text;
BEGIN
  IF p_user_id IS NULL THEN
    RAISE EXCEPTION 'Missing user_id';
  END IF;
  IF p_amount IS NULL OR p_amount <= 0 THEN
    RAISE EXCEPTION 'Invalid amount';
  END IF;

  v_coin_type := LOWER(COALESCE(p_coin_type, 'paid'));
  IF v_coin_type IN ('troll_coins') THEN
    v_coin_type := 'paid';
  ELSIF v_coin_type IN ('trollmonds') THEN
    v_coin_type := 'free';
  END IF;

  IF v_coin_type NOT IN ('paid', 'free') THEN
    RAISE EXCEPTION 'Invalid coin type';
  END IF;

  IF v_coin_type = 'paid' THEN
    SELECT Troll_coins INTO v_current_balance
    FROM user_profiles
    WHERE id = p_user_id;
  ELSE
    SELECT troll_coins INTO v_current_balance
    FROM user_profiles
    WHERE id = p_user_id;
  END IF;

  IF v_current_balance IS NULL THEN
    RAISE EXCEPTION 'User not found';
  END IF;

  IF v_current_balance < p_amount THEN
    RAISE EXCEPTION 'Insufficient % coins. Required: %, Available: %', v_coin_type, p_amount, v_current_balance;
  END IF;

  IF v_coin_type = 'paid' THEN
    UPDATE user_profiles
    SET Troll_coins = Troll_coins - p_amount,
        total_spent_coins = COALESCE(total_spent_coins, 0) + p_amount,
        updated_at = now()
    WHERE id = p_user_id;
  ELSE
    UPDATE user_profiles
    SET troll_coins = troll_coins - p_amount,
        total_spent_coins = COALESCE(total_spent_coins, 0) + p_amount,
        updated_at = now()
    WHERE id = p_user_id;
  END IF;
END;
$$;


ALTER FUNCTION "public"."deduct_coins"("p_user_id" "uuid", "p_amount" bigint, "p_coin_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."deduct_troll_coins"("p_user_id" "uuid", "p_amount" bigint) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  PERFORM deduct_coins(p_user_id, p_amount, 'troll_coins');
END;
$$;


ALTER FUNCTION "public"."deduct_troll_coins"("p_user_id" "uuid", "p_amount" bigint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."deduct_user_coins"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text", "p_appeal_id" "uuid", "p_verdict" "text") RETURNS json
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_current_balance INTEGER;
  v_deducted INTEGER;
BEGIN
  SELECT free_coin_balance INTO v_current_balance
  FROM user_profiles
  WHERE id = p_user_id;

  v_deducted := LEAST(v_current_balance, p_amount);

  UPDATE user_profiles
  SET free_coin_balance = GREATEST(free_coin_balance - p_amount, 0)
  WHERE id = p_user_id;

  INSERT INTO punishment_transactions (user_id, coins_deducted, reason, appeal_id, verdict)
  VALUES (p_user_id, v_deducted, p_reason, p_appeal_id, p_verdict);

  RETURN json_build_object(
    'success', true,
    'deducted', v_deducted,
    'remaining', GREATEST(v_current_balance - p_amount, 0)
  );
END;
$$;


ALTER FUNCTION "public"."deduct_user_coins"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text", "p_appeal_id" "uuid", "p_verdict" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."deduct_user_paid_coins"("p_user_id" "uuid", "p_amount" bigint, "p_coin_type" "text" DEFAULT 'troll_coins'::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  PERFORM deduct_coins(p_user_id => p_user_id, p_amount => p_amount, p_coin_type => p_coin_type);
END;
$$;


ALTER FUNCTION "public"."deduct_user_paid_coins"("p_user_id" "uuid", "p_amount" bigint, "p_coin_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."deduct_user_troll_coins"("p_user_id" "uuid", "p_amount" bigint) RETURNS bigint
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  current_balance bigint;
BEGIN
  IF p_amount IS NULL OR p_amount <= 0 THEN
    RAISE EXCEPTION 'Amount must be greater than zero';
  END IF;

  SELECT troll_coins INTO current_balance
  FROM public.user_profiles
  WHERE id = p_user_id
  FOR UPDATE;

  IF current_balance IS NULL THEN
    RAISE EXCEPTION 'User profile not found';
  END IF;

  IF current_balance < p_amount THEN
    RAISE EXCEPTION 'Insufficient Troll Coins';
  END IF;

  UPDATE public.user_profiles
  SET troll_coins = troll_coins - p_amount,
      updated_at = now()
  WHERE id = p_user_id;

  SELECT troll_coins INTO current_balance
  FROM public.user_profiles
  WHERE id = p_user_id;

  RETURN current_balance;
END;
$$;


ALTER FUNCTION "public"."deduct_user_troll_coins"("p_user_id" "uuid", "p_amount" bigint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."deduct_user_troll_coins"("p_user_id" "uuid", "p_amount" bigint, "p_coin_type" "text" DEFAULT 'troll_coins'::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  PERFORM deduct_coins(p_user_id => p_user_id, p_amount => p_amount, p_coin_type => p_coin_type);
END;
$$;


ALTER FUNCTION "public"."deduct_user_troll_coins"("p_user_id" "uuid", "p_amount" bigint, "p_coin_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."delete_payout_request"("p_payout_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_payout payout_requests%ROWTYPE;
  v_actor record;
  v_coins bigint;
  v_should_refund boolean;
BEGIN
  SELECT role, is_admin, officer_role, is_lead_officer
  INTO v_actor
  FROM user_profiles
  WHERE id = auth.uid();

  IF v_actor IS NULL THEN
    RAISE EXCEPTION 'Authentication required';
  END IF;

  IF NOT (
    v_actor.role = 'admin'
    OR v_actor.is_admin = TRUE
    OR v_actor.officer_role = 'lead_officer'
    OR v_actor.is_lead_officer = TRUE
  ) THEN
    RAISE EXCEPTION 'Only admins or lead officers can delete payout requests';
  END IF;

  SELECT *
  INTO v_payout
  FROM payout_requests
  WHERE id = p_payout_id;

  IF v_payout IS NULL THEN
    RAISE EXCEPTION 'Payout request not found';
  END IF;

  IF v_payout.status = 'paid' THEN
    RAISE EXCEPTION 'Cannot delete a paid payout';
  END IF;

  v_coins := COALESCE(v_payout.coins_redeemed, v_payout.requested_coins, v_payout.coin_amount, 0);
  v_should_refund := COALESCE(v_payout.coins_reserved, false) IS TRUE AND v_coins > 0;

  IF v_should_refund THEN
    UPDATE public.user_profiles
    SET
      paid_coin_balance = paid_coin_balance + v_coins,
      updated_at = now()
    WHERE id = v_payout.user_id;

    BEGIN
      INSERT INTO public.coin_transactions (
        user_id,
        type,
        amount,
        description,
        metadata
      ) VALUES (
        v_payout.user_id,
        'payout_refund',
        v_coins,
        format('Payout request deleted: %s coins refunded', v_coins),
        jsonb_build_object('payout_request_id', p_payout_id, 'deleted_by', auth.uid())
      );
    EXCEPTION
      WHEN undefined_table THEN NULL;
      WHEN insufficient_privilege THEN NULL;
    END;

    UPDATE public.payout_requests
    SET coins_reserved = false
    WHERE id = p_payout_id;
  END IF;

  DELETE FROM public.payout_requests
  WHERE id = p_payout_id;
END;
$$;


ALTER FUNCTION "public"."delete_payout_request"("p_payout_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."delete_user_account"("p_user_id" "uuid", "p_pay_early_fee" boolean DEFAULT false) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_early_fee integer := 500; -- $5 = 500 coins
  v_user_balance integer;
  v_cooldown_until timestamptz;
BEGIN
  IF p_pay_early_fee THEN
    SELECT paid_coin_balance
    INTO v_user_balance
    FROM public.user_profiles
    WHERE id = p_user_id;

    IF NOT FOUND THEN
      RETURN jsonb_build_object('success', false, 'error', 'User profile not found.');
    END IF;

    IF v_user_balance < v_early_fee THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', format('Insufficient troll_coins. Need %s troll_coins ($5) to skip cooldown.', v_early_fee)
      );
    END IF;

    UPDATE public.user_profiles
    SET
      paid_coin_balance = paid_coin_balance - v_early_fee,
      account_deleted_at = now(),
      account_deletion_cooldown_until = NULL
    WHERE id = p_user_id;

    RETURN jsonb_build_object(
      'success', true,
      'message', 'Account deleted. You can create a new account immediately.'
    );
  ELSE
    v_cooldown_until := now() + interval '7 days';

    UPDATE public.user_profiles
    SET
      account_deleted_at = now(),
      account_deletion_cooldown_until = v_cooldown_until
    WHERE id = p_user_id;

    RETURN jsonb_build_object(
      'success', true,
      'cooldown_until', v_cooldown_until,
      'message', 'Account deletion scheduled. You must wait 7 days before creating a new account, or pay $5 to skip the cooldown.'
    );
  END IF;
END;
$_$;


ALTER FUNCTION "public"."delete_user_account"("p_user_id" "uuid", "p_pay_early_fee" boolean) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."delete_user_account"("p_user_id" "uuid", "p_pay_early_fee" boolean) IS 'Deletes user account with 7-day cooldown or $5 early fee';



CREATE OR REPLACE FUNCTION "public"."delete_user_as_admin"("target_user_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'auth'
    AS $$
      DECLARE
        v_operator_role TEXT;
        v_is_admin BOOLEAN;
      BEGIN
        -- Check if operator is admin
        -- We check both role column and is_admin column if it exists
        -- Using COALESCE to handle potential missing columns or nulls gracefully in logic if needed,
        -- but here we select into variables. If column doesn't exist, this query might fail.
        -- To be safe, we'll just check role first, which we know exists from initial schema.
        
        SELECT role INTO v_operator_role
        FROM public.user_profiles
        WHERE id = auth.uid();

        -- Also try to get is_admin if possible, but let's rely on role='admin' primarily for now
        -- or we can do a robust check.
        
        IF v_operator_role <> 'admin' THEN
           -- If role is not admin, strict check. 
           -- (If you have is_admin column, we could check that too, but let's stick to role for simplicity and safety)
           RAISE EXCEPTION 'Unauthorized: Only admins can delete users.';
        END IF;

        -- Delete from auth.users (cascades to public tables)
        DELETE FROM auth.users WHERE id = target_user_id;
      END;
      $$;


ALTER FUNCTION "public"."delete_user_as_admin"("target_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."deny_application"("p_app_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  update applications
  set 
    status = 'denied',
    reviewed_at = now(),
    reviewed_by = auth.uid()
  where id = p_app_id;
end;
$$;


ALTER FUNCTION "public"."deny_application"("p_app_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."deny_application"("p_app_id" "uuid", "p_reviewer_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_application RECORD;
  v_reviewer RECORD;
BEGIN
  -- Verify reviewer is admin
  SELECT * INTO v_reviewer
  FROM user_profiles
  WHERE id = p_reviewer_id;

  IF NOT (v_reviewer.role = 'admin' OR v_reviewer.is_admin = TRUE) THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Only admins can deny applications');
  END IF;

  -- Fetch application
  SELECT * INTO v_application
  FROM applications
  WHERE id = p_app_id AND status = 'pending';

  IF v_application IS NULL THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Application not found or already processed');
  END IF;

  -- Update application
  UPDATE applications
  SET 
    status = 'denied',
    reviewed_by = p_reviewer_id,
    reviewed_at = NOW(),
    updated_at = NOW()
  WHERE id = p_app_id;

  -- Notification
  INSERT INTO notifications (
    user_id,
    type,
    title,
    message,
    metadata
  ) VALUES (
    v_application.user_id,
    'application_denied',
    'Application Denied',
    'Your application was not approved. You may apply again anytime.',
    jsonb_build_object('link', '/application')
  );

  RETURN jsonb_build_object(
    'success', TRUE,
    'message', 'Application denied successfully.'
  );
END;
$$;


ALTER FUNCTION "public"."deny_application"("p_app_id" "uuid", "p_reviewer_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."deny_application"("p_app_id" "uuid", "p_reviewer_id" "uuid", "p_reason" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_application RECORD;
  v_reviewer RECORD;
BEGIN
  -- Check if reviewer is admin
  SELECT * INTO v_reviewer
  FROM user_profiles
  WHERE id = p_reviewer_id;

  IF NOT (v_reviewer.role = 'admin' OR v_reviewer.is_admin = TRUE) THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Only admins can deny applications');
  END IF;

  -- Get application
  SELECT * INTO v_application
  FROM applications
  WHERE id = p_app_id AND status = 'pending';

  IF v_application IS NULL THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Application not found or already processed');
  END IF;

  -- Update status
  UPDATE applications
  SET 
    status = 'rejected',
    reviewed_by = p_reviewer_id,
    reviewed_at = NOW(),
    updated_at = NOW(),
    data = COALESCE(data, '{}'::jsonb) || jsonb_build_object('rejection_reason', p_reason)
  WHERE id = p_app_id;

  -- Notification
  INSERT INTO notifications (
    user_id,
    type,
    title,
    message,
    metadata
  ) VALUES (
    v_application.user_id,
    'application_rejected',
    'Application Rejected',
    format(
      'Your %s application has been rejected.%s', 
      v_application.type,
      CASE WHEN p_reason IS NOT NULL THEN ' Reason: ' || p_reason ELSE '' END
    ),
    jsonb_build_object('link', '/profile')
  );

  RETURN jsonb_build_object('success', TRUE, 'message', 'Application rejected successfully');
END;
$$;


ALTER FUNCTION "public"."deny_application"("p_app_id" "uuid", "p_reviewer_id" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."detect_ghost_inactivity"() RETURNS TABLE("officer_id" "uuid", "session_id" "uuid")
    LANGUAGE "sql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
SELECT
  ola.officer_id,
  ows.id AS session_id
FROM officer_live_assignments ola
JOIN officer_work_sessions ows ON ola.officer_id = ows.officer_id AND ows.clock_out IS NULL
WHERE ola.ghost_mode_active = TRUE
AND ola.last_activity < NOW() - INTERVAL '20 minutes'
AND ola.status = 'active';
$$;


ALTER FUNCTION "public"."detect_ghost_inactivity"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."economy_summary"() RETURNS json
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare
  total_users int;
  total_streams int;
  total_gift_coins int;
  total_free_coins int;
begin
  select count(*) into total_users from user_profiles;
  select count(*) into total_streams from streams where is_live = true;
  select sum(total_gifts_coins) into total_gift_coins from streams;
  select sum(free_coin_balance) into total_free_coins from user_profiles;

  return json_build_object(
    'total_users', total_users,
    'live_streams', total_streams,
    'total_gift_coins', coalesce(total_gift_coins, 0),
    'total_free_coins', coalesce(total_free_coins, 0)
  );
end;
$$;


ALTER FUNCTION "public"."economy_summary"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."end_court_session"() RETURNS "void"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT public.end_court_session(current_setting('app.court_session_id'));
$$;


ALTER FUNCTION "public"."end_court_session"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."end_court_session"("p_session_id" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- Update session
  UPDATE court_sessions
  SET status = 'ended', ended_at = NOW()
  WHERE id = p_session_id::uuid;

  -- Update related docket items
  UPDATE court_docket
  SET status = 'processed', updated_at = NOW()
  WHERE court_session_id = p_session_id::uuid AND status = 'in_session';
END;
$$;


ALTER FUNCTION "public"."end_court_session"("p_session_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."end_home_feature_cycle"("p_cycle_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  winner_id UUID;
  total_spent BIGINT;
BEGIN
  -- Get total spent
  SELECT total_spent_coins INTO total_spent
  FROM home_feature_cycles
  WHERE id = p_cycle_id;

  -- If total < 10,000, just mark winner without payout
  IF total_spent < 10000 THEN
    -- Find top spender
    SELECT user_id INTO winner_id
    FROM home_feature_spend
    WHERE cycle_id = p_cycle_id
    GROUP BY user_id
    ORDER BY SUM(coins_spent) DESC
    LIMIT 1;

    UPDATE home_feature_cycles
    SET winner_user_id = winner_id
    WHERE id = p_cycle_id;

    RETURN;
  END IF;

  -- Find top spender and payout
  SELECT user_id INTO winner_id
  FROM home_feature_spend
  WHERE cycle_id = p_cycle_id
  GROUP BY user_id
  ORDER BY SUM(coins_spent) DESC
  LIMIT 1;

  -- Credit 1,000 paid coins via existing logic (assuming deduct_coins can be negative for credit)
  -- Actually, use a separate function or direct insert
  -- For now, insert transaction
  INSERT INTO coin_transactions (user_id, coins, usd_amount, source, external_id, payer_email, payment_status, payment_method, metadata)
  VALUES (winner_id, 1000, 0, 'platform_bonus', 'home_feature_reward_' || p_cycle_id, NULL, 'completed', 'platform', json_build_object('cycle_id', p_cycle_id));

  -- Update user balance
  UPDATE user_profiles
  SET paid_coin_balance = paid_coin_balance + 1000
  WHERE id = winner_id;

  -- Mark cycle as paid
  UPDATE home_feature_cycles
  SET winner_user_id = winner_id, reward_paid = true
  WHERE id = p_cycle_id;
END;
$$;


ALTER FUNCTION "public"."end_home_feature_cycle"("p_cycle_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."end_stream"("p_stream_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  UPDATE streams SET status = 'ended', end_time = now(), updated_at = now() WHERE id = p_stream_id;
END;
$$;


ALTER FUNCTION "public"."end_stream"("p_stream_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."end_trial_early"() RETURNS "public"."system_settings"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_settings public.system_settings;
BEGIN
  UPDATE public.system_settings
  SET payout_lock_enabled = FALSE,
      updated_at = now()
  WHERE TRUE;
  SELECT * INTO v_settings FROM public.system_settings ORDER BY updated_at DESC LIMIT 1;
  RETURN v_settings;
END
$$;


ALTER FUNCTION "public"."end_trial_early"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."end_tromody_session"("p_session" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare 
  s public.tromody_sessions;
  total_left bigint;
  total_right bigint;
  total_all bigint;
  win_side text;
  win_user uuid;
begin
  select * into s from public.tromody_sessions 
  where id = p_session for update;

  if not found then
    raise exception 'Session not found';
  end if;

  if s.status = 'ended' then
    return;
  end if;

  total_left := s.left_gifts_paid + s.left_gifts_free;
  total_right := s.right_gifts_paid + s.right_gifts_free;
  total_all := total_left + total_right;

  if total_left > total_right then
    win_side := 'left';
    win_user := s.left_user_id;
  elsif total_right > total_left then
    win_side := 'right';
    win_user := s.right_user_id;
  else
    win_side := 'tie';
    win_user := null;
  end if;

  if win_user is not null then
    update public.wallets
    set paid_coins = paid_coins + total_all
    where user_id = win_user;
  end if;

  update public.tromody_sessions
  set status = 'ended',
      ended_at = now(),
      winner_side = win_side,
      winner_user_id = win_user
  where id = p_session;
end;
$$;


ALTER FUNCTION "public"."end_tromody_session"("p_session" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."enforce_two_secretaries_max"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  sec_count int;
BEGIN
  SELECT COUNT(*) INTO sec_count FROM public.secretary_assignments;
  IF sec_count >= 2 THEN
    RAISE EXCEPTION 'Only 2 secretaries can be assigned';
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."enforce_two_secretaries_max"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."ensure_payout_not_locked"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF public.is_payout_locked() THEN
    RAISE EXCEPTION 'Payouts are locked during Launch Trial Mode.';
  END IF;
  RETURN NEW;
END
$$;


ALTER FUNCTION "public"."ensure_payout_not_locked"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."ensure_payout_window_open"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF NOT public.is_payout_window_open() THEN
    RAISE EXCEPTION 'Payouts are available Mondays and Fridays starting at 1:00 AM UTC.';
  END IF;
  RETURN NEW;
END
$$;


ALTER FUNCTION "public"."ensure_payout_window_open"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."ensure_stream_momentum"("p_stream_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_stream record;
BEGIN
  SELECT id, start_time
  INTO v_stream
  FROM public.streams
  WHERE id = p_stream_id;

  IF v_stream IS NULL THEN
    RETURN;
  END IF;

  INSERT INTO public.stream_momentum (
    stream_id,
    momentum,
    last_gift_at,
    last_decay_at,
    updated_at
  )
  VALUES (
    p_stream_id,
    100,
    COALESCE(v_stream.start_time, now()),
    COALESCE(v_stream.start_time, now()),
    now()
  )
  ON CONFLICT (stream_id) DO NOTHING;
END;
$$;


ALTER FUNCTION "public"."ensure_stream_momentum"("p_stream_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."escalate_to_admin"("p_report_id" "uuid", "p_officer_id" "uuid", "p_reason" "text", "p_description" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_report RECORD;
  v_admin_id UUID;
BEGIN
  -- Verify officer
  IF NOT EXISTS (
    SELECT 1 FROM user_profiles
    WHERE id = p_officer_id AND (is_troll_officer = true OR role = 'troll_officer')
  ) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Unauthorized: Officer access required');
  END IF;

  -- Get report
  SELECT * INTO v_report
  FROM moderation_reports
  WHERE id = p_report_id;

  IF v_report IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Report not found');
  END IF;

  -- Find an admin
  SELECT id INTO v_admin_id
  FROM user_profiles
  WHERE (role = 'admin' OR is_admin = true)
    AND is_banned = false
  ORDER BY created_at ASC
  LIMIT 1;

  IF v_admin_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'No available admins');
  END IF;

  -- Create escalation
  INSERT INTO escalation_reports (
    original_report_id,
    escalated_by,
    escalated_to,
    escalation_level,
    reason,
    description,
    status
  ) VALUES (
    p_report_id,
    p_officer_id,
    v_admin_id,
    'admin',
    p_reason,
    p_description,
    'pending'
  );

  -- Create notification for admin
  INSERT INTO notifications (
    user_id,
    type,
    title,
    message,
    metadata
  ) VALUES (
    v_admin_id,
    'moderation_action',
    'Report Escalated by Officer',
    format('An officer has escalated a report to you: %s', p_reason),
    jsonb_build_object('report_id', p_report_id, 'escalation_id', (SELECT id FROM escalation_reports WHERE original_report_id = p_report_id ORDER BY created_at DESC LIMIT 1))
  );

  RETURN jsonb_build_object('success', true, 'message', 'Report escalated to admin');
END;
$$;


ALTER FUNCTION "public"."escalate_to_admin"("p_report_id" "uuid", "p_officer_id" "uuid", "p_reason" "text", "p_description" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."escalate_to_officer"("p_report_id" "uuid", "p_escalator_id" "uuid", "p_reason" "text", "p_description" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_report RECORD;
  v_officer_id UUID;
BEGIN
  -- Get report
  SELECT * INTO v_report
  FROM moderation_reports
  WHERE id = p_report_id;

  IF v_report IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Report not found');
  END IF;

  -- Find an available officer (first active officer)
  SELECT id INTO v_officer_id
  FROM user_profiles
  WHERE (is_troll_officer = true OR role = 'troll_officer')
    AND is_officer_active = true
    AND is_banned = false
  ORDER BY created_at ASC
  LIMIT 1;

  IF v_officer_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'No available officers');
  END IF;

  -- Create escalation
  INSERT INTO escalation_reports (
    original_report_id,
    escalated_by,
    escalated_to,
    escalation_level,
    reason,
    description,
    status
  ) VALUES (
    p_report_id,
    p_escalator_id,
    v_officer_id,
    'officer',
    p_reason,
    p_description,
    'pending'
  );

  -- Create notification for officer
  INSERT INTO notifications (
    user_id,
    type,
    title,
    message,
    metadata
  ) VALUES (
    v_officer_id,
    'moderation_action',
    'Report Escalated',
    format('A user has escalated a report to you: %s', p_reason),
    jsonb_build_object('report_id', p_report_id, 'escalation_id', (SELECT id FROM escalation_reports WHERE original_report_id = p_report_id ORDER BY created_at DESC LIMIT 1))
  );

  RETURN jsonb_build_object('success', true, 'message', 'Report escalated to officer');
END;
$$;


ALTER FUNCTION "public"."escalate_to_officer"("p_report_id" "uuid", "p_escalator_id" "uuid", "p_reason" "text", "p_description" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."exec_sql"("sql" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    result JSON;
BEGIN
    EXECUTE sql;
    result := json_build_object('success', true, 'message', 'SQL executed successfully');
    RETURN result;
EXCEPTION
    WHEN OTHERS THEN
        result := json_build_object('success', false, 'error', SQLERRM);
        RETURN result;
END;
$$;


ALTER FUNCTION "public"."exec_sql"("sql" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."execute_sql"("sql" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  EXECUTE sql;
END;
$$;


ALTER FUNCTION "public"."execute_sql"("sql" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."expire_active_items"() RETURNS "void"
    LANGUAGE "sql"
    AS $$
  update user_active_items
  set is_active = false
  where is_active = true
    and expires_at is not null
    and expires_at <= now();
$$;


ALTER FUNCTION "public"."expire_active_items"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."expire_perks"() RETURNS "void"
    LANGUAGE "sql"
    AS $$
  -- deactivate expired perk activations
  update user_perks
  set is_active = false
  where is_active = true
    and expires_at <= now();

  -- clear expired username effects
  update user_profiles
  set username_effect = null,
      username_effect_expires_at = null
  where username_effect is not null
    and username_effect_expires_at is not null
    and username_effect_expires_at <= now();
$$;


ALTER FUNCTION "public"."expire_perks"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."expire_user_items"() RETURNS "void"
    LANGUAGE "sql"
    AS $$
  update user_active_items
  set is_active = false
  where is_active = true
  and expires_at is not null
  and expires_at <= now();
$$;


ALTER FUNCTION "public"."expire_user_items"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."family_purchase_item"("p_family_id" "uuid", "p_item_id" "uuid", "p_quantity" integer DEFAULT 1) RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_price_coins int;
  v_price_xp int;
  v_total_coins int;
  v_total_xp int;
  v_purchase_id uuid;
BEGIN
  SELECT price_family_coins, price_family_xp
  INTO v_price_coins, v_price_xp
  FROM public.family_shop_items
  WHERE id = p_item_id AND is_active = true;

  IF v_price_coins IS NULL THEN
    RAISE EXCEPTION 'Item not found or inactive';
  END IF;

  v_total_coins := v_price_coins * p_quantity;
  v_total_xp := v_price_xp * p_quantity;

  -- Ensure family has enough coins
  IF (SELECT family_coins FROM public.family_stats WHERE family_id = p_family_id) < v_total_coins THEN
    RAISE EXCEPTION 'Not enough family coins';
  END IF;

  -- Deduct coins/xp
  UPDATE public.family_stats
  SET family_coins = family_coins - v_total_coins,
      family_xp = family_xp - v_total_xp,
      updated_at = now()
  WHERE family_id = p_family_id;

  -- Create purchase record
  INSERT INTO public.family_shop_purchases (
    family_id, item_id, purchased_by, quantity,
    total_cost_family_coins, total_cost_family_xp
  )
  VALUES (
    p_family_id, p_item_id, auth.uid(), p_quantity,
    v_total_coins, v_total_xp
  )
  RETURNING id INTO v_purchase_id;

  RETURN v_purchase_id;
END;
$$;


ALTER FUNCTION "public"."family_purchase_item"("p_family_id" "uuid", "p_item_id" "uuid", "p_quantity" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."finalize_redemption_on_sent"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- When moving to "sent", deduct coins and release reserved coins
  IF NEW.status = 'sent' AND OLD.status <> 'sent' THEN

    -- Deduct from paid coins
    UPDATE user_profiles
    SET paid_coins = paid_coins - NEW.tier_coins_required,
        reserved_paid_coins = reserved_paid_coins - NEW.tier_coins_required
    WHERE id = NEW.user_id;

  -- If denied, release reserved coins
  ELSIF NEW.status = 'denied' AND OLD.status <> 'denied' THEN

    UPDATE user_profiles
    SET reserved_paid_coins = reserved_paid_coins - NEW.tier_coins_required
    WHERE id = NEW.user_id;

  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."finalize_redemption_on_sent"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."finalize_redemption_status"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- When marked SENT: deduct real coins + release reserve
  IF NEW.status = 'sent' AND OLD.status <> 'sent' THEN

    UPDATE user_profiles
    SET troll_coins = troll_coins - NEW.tier_coins_required,
        reserved_troll_coins = reserved_troll_coins - NEW.tier_coins_required
    WHERE id = NEW.user_id;

  -- When marked DENIED: release reserve only
  ELSIF NEW.status = 'denied' AND OLD.status <> 'denied' THEN

    UPDATE user_profiles
    SET reserved_troll_coins = reserved_troll_coins - NEW.tier_coins_required
    WHERE id = NEW.user_id;

  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."finalize_redemption_status"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."find_tromody_match"() RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  player1 RECORD;
  player2 RECORD;
  match_uuid UUID;
  room_name TEXT;
BEGIN
  -- Find two searching players
  SELECT * INTO player1 FROM tromody_queue WHERE status = 'searching' ORDER BY created_at LIMIT 1 FOR UPDATE SKIP LOCKED;
  IF NOT FOUND THEN
    RETURN NULL;
  END IF;

  SELECT * INTO player2 FROM tromody_queue WHERE status = 'searching' AND user_id != player1.user_id ORDER BY created_at LIMIT 1 FOR UPDATE SKIP LOCKED;
  IF NOT FOUND THEN
    RETURN NULL;
  END IF;

  -- Create match
  match_uuid := gen_random_uuid();
  room_name := 'tromody_match_' || match_uuid::text;

  INSERT INTO tromody_matches (id, player1_id, player2_id, room_name)
  VALUES (match_uuid, player1.user_id, player2.user_id, room_name);

  -- Update queue entries
  UPDATE tromody_queue SET status = 'matched', match_id = match_uuid, updated_at = NOW() WHERE user_id IN (player1.user_id, player2.user_id);

  RETURN match_uuid;
END;
$$;


ALTER FUNCTION "public"."find_tromody_match"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fire_officer"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  update user_profiles
  set officer_role = 'applicant'
  where id = p_user_id;

  insert into officer_actions (officer_id, action_type, acted_by, reason)
  values (p_user_id, 'fired', p_acted_by, p_reason);
end;
$$;


ALTER FUNCTION "public"."fire_officer"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."fire_officer"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") IS 'Allows lead officers and admins to fire/downgrade troll officers to regular users';



CREATE OR REPLACE FUNCTION "public"."fn_apply_coin_ledger"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  is_credit boolean := NEW.direction = 'credit';
  is_paid boolean := NEW.coin_type = 'paid';
  delta bigint := NEW.coins;
BEGIN
  PERFORM fn_ensure_wallet(NEW.user_id);

  IF is_paid THEN
    UPDATE public.user_wallets
    SET paid_coins = paid_coins + (CASE WHEN is_credit THEN delta ELSE -delta END)
    WHERE user_id = NEW.user_id;
  ELSE
    UPDATE public.user_wallets
    SET free_coins = free_coins + (CASE WHEN is_credit THEN delta ELSE -delta END)
    WHERE user_id = NEW.user_id;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_apply_coin_ledger"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_ensure_wallet"("p_user_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.user_wallets WHERE user_id = p_user_id) THEN
    INSERT INTO public.user_wallets (user_id) VALUES (p_user_id);
  END IF;
END;
$$;


ALTER FUNCTION "public"."fn_ensure_wallet"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_touch_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_touch_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."force_end_all_court_sessions"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- End all active sessions
  UPDATE court_sessions
  SET status = 'ended', ended_at = NOW()
  WHERE status IN ('live', 'active', 'waiting');

  -- Update docket items
  UPDATE court_docket
  SET status = 'processed', updated_at = NOW()
  WHERE status = 'in_session';
END;
$$;


ALTER FUNCTION "public"."force_end_all_court_sessions"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fulfill_cashout_request"("p_request_id" "uuid", "p_admin_id" "uuid", "p_notes" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_request RECORD;
  cashout_coin_col text;
  coin_amount bigint;
  sql_text text;
BEGIN

  -- Ensure function only used via backend/service role
  IF auth.role() != 'service_role' THEN
    RAISE EXCEPTION 'Unauthorized';
  END IF;

  -- Detect coin column
  SELECT column_name INTO cashout_coin_col
  FROM information_schema.columns
  WHERE table_schema='public'
    AND table_name='cashout_requests'
    AND column_name IN (
      'requested_coins',
      'amount_coins',
      'coins',
      'coin_amount',
      'troll_coins',
      'requested_amount',
      'requested_troll_coins'
    )
  ORDER BY CASE column_name
    WHEN 'requested_coins' THEN 1
    WHEN 'amount_coins' THEN 2
    WHEN 'coins' THEN 3
    WHEN 'coin_amount' THEN 4
    WHEN 'troll_coins' THEN 5
    WHEN 'requested_amount' THEN 6
    WHEN 'requested_troll_coins' THEN 7
    ELSE 999
  END
  LIMIT 1;

  IF cashout_coin_col IS NULL THEN
    RAISE EXCEPTION 'No coin amount column found in cashout_requests';
  END IF;

  sql_text := format(
    'SELECT *, %I as coin_amount FROM public.cashout_requests WHERE id=$1',
    cashout_coin_col
  );

  EXECUTE sql_text INTO v_request USING p_request_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Request not found';
  END IF;

  IF v_request.status != 'pending' AND v_request.status != 'processing' THEN
    RAISE EXCEPTION 'Request is not pending or processing';
  END IF;

  coin_amount := v_request.coin_amount;

  UPDATE public.user_profiles
  SET
    troll_coins = troll_coins - coin_amount,
    reserved_troll_coins = GREATEST(0, COALESCE(reserved_troll_coins, 0) - coin_amount)
  WHERE id = v_request.user_id;

  UPDATE public.cashout_requests
  SET
    status = 'fulfilled',
    fulfilled_by = p_admin_id,
    fulfilled_at = now(),
    notes = p_notes,
    updated_at = now()
  WHERE id = p_request_id;
END;
$_$;


ALTER FUNCTION "public"."fulfill_cashout_request"("p_request_id" "uuid", "p_admin_id" "uuid", "p_notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fulfill_visa_redemption"("p_redemption_id" "uuid", "p_giftcard_code" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_admin_id uuid := auth.uid();
  v_role text;
  v_row public.visa_redemptions;
  v_reserved bigint;
  v_available_before bigint;
  v_reserved_before bigint;
BEGIN
  IF v_admin_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT role INTO v_role FROM public.user_profiles WHERE id = v_admin_id;
  IF v_role NOT IN ('admin','secretary') THEN
    RAISE EXCEPTION 'Not authorized';
  END IF;

  SELECT * INTO v_row FROM public.visa_redemptions WHERE id = p_redemption_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Redemption not found';
  END IF;

  IF v_row.status IN ('fulfilled','rejected') THEN
    RAISE EXCEPTION 'Redemption already processed';
  END IF;

  SELECT COALESCE(troll_coins,0) - COALESCE(reserved_troll_coins,0),
         COALESCE(reserved_troll_coins,0)
    INTO v_available_before, v_reserved_before
  FROM public.user_profiles
  WHERE id = v_row.user_id;

  UPDATE public.user_profiles
  SET troll_coins = GREATEST(0, COALESCE(troll_coins,0) - v_row.coins_reserved),
      reserved_troll_coins = GREATEST(0, COALESCE(reserved_troll_coins,0) - v_row.coins_reserved),
      updated_at = now()
  WHERE id = v_row.user_id;

  UPDATE public.visa_redemptions
  SET status = 'fulfilled',
      giftcard_code = p_giftcard_code,
      fulfilled_at = now(),
      fulfilled_by = v_admin_id,
      updated_at = now()
  WHERE id = p_redemption_id;

  BEGIN
    PERFORM create_notification(
      v_row.user_id,
      'gift_card',
      'Visa eGift Delivered',
      format('You received a %s Visa eGift. Code: %s\nRedemption ID: %s\nFulfilled: %s',
        v_row.usd_amount, p_giftcard_code, p_redemption_id, to_char(now(),'YYYY-MM-DD HH24:MI:SS')),
      jsonb_build_object(
        'usd_amount', v_row.usd_amount,
        'redemption_id', p_redemption_id,
        'fulfilled_at', now()
      )
    );
  EXCEPTION WHEN OTHERS THEN
    INSERT INTO notifications (user_id, type, title, message, metadata, created_at)
    VALUES (
      v_row.user_id,
      'gift_card',
      'Visa eGift Delivered',
      format('You received a %s Visa eGift. Code: %s\nRedemption ID: %s\nFulfilled: %s',
        v_row.usd_amount, p_giftcard_code, p_redemption_id, to_char(now(),'YYYY-MM-DD HH24:MI:SS')),
      jsonb_build_object(
        'usd_amount', v_row.usd_amount,
        'redemption_id', p_redemption_id,
        'fulfilled_at', now()
      ),
      now()
    );
  END;

  RETURN jsonb_build_object(
    'success', true,
    'RedemptionStatus', 'fulfilled',
    'WalletBefore', jsonb_build_object(
      'available', v_available_before,
      'reserved', v_reserved_before
    ),
    'WalletAfter', jsonb_build_object(
      'available', v_available_before,
      'reserved', GREATEST(0, v_reserved_before - v_row.coins_reserved)
    )
  );
END;
$$;


ALTER FUNCTION "public"."fulfill_visa_redemption"("p_redemption_id" "uuid", "p_giftcard_code" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_active_perks"("p_user_id" "uuid") RETURNS TABLE("perk_id" "text", "expires_at" timestamp with time zone, "metadata" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    up.perk_id,
    up.expires_at,
    up.metadata
  FROM user_perks up
  WHERE up.user_id = p_user_id
    AND up.is_active = true
    AND up.expires_at > NOW()
  ORDER BY up.expires_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_active_perks"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_active_perks"("p_user_id" "uuid") IS 'Returns all active perks for a user';



CREATE OR REPLACE FUNCTION "public"."get_admin_finance_dashboard"("p_range" "text" DEFAULT '30d'::"text") RETURNS TABLE("provider" "text", "current_cost" numeric, "projected_monthly_cost" numeric, "next_payment_due" timestamp with time zone, "status" "text", "last_synced_at" timestamp with time zone)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select
    provider::text,
    current_cost,
    projected_monthly_cost,
    next_payment_due,
    status::text,
    last_synced_at
  from public.provider_costs
  order by projected_monthly_cost desc;
$$;


ALTER FUNCTION "public"."get_admin_finance_dashboard"("p_range" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_all_docket_entries"() RETURNS TABLE("id" "uuid", "user_id" "uuid", "username" "text", "case_type" "text", "scheduled_at" timestamp with time zone, "status" "text", "assigned_officer" "uuid", "officer_username" "text", "notes" "text", "court_session_id" "uuid")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        cd.id,
        cd.user_id,
        up.username,
        cd.case_type,
        cd.scheduled_at,
        cd.status,
        cd.assigned_officer,
        officer.username as officer_username,
        cd.notes,
        cd.court_session_id
    FROM court_docket cd
    LEFT JOIN user_profiles up ON cd.user_id = up.id
    LEFT JOIN user_profiles officer ON cd.assigned_officer = officer.id
    ORDER BY cd.scheduled_at ASC;
END;
$$;


ALTER FUNCTION "public"."get_all_docket_entries"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_all_docket_entries"() IS 'Returns all docket entries with user details (admin only)';



CREATE OR REPLACE FUNCTION "public"."get_battle_and_net_earnings"() RETURNS TABLE("day" "date", "battle_earnings" numeric, "net_earnings" numeric)
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select
    date_trunc('day', created_at)::date as day,
    sum(case when action = 'battle_win' then amount else 0 end) as battle_earnings,
    sum(amount) as net_earnings
  from public.activity_log
  group by 1
  order by 1;
$$;


ALTER FUNCTION "public"."get_battle_and_net_earnings"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_cached_home_rankings_30m"() RETURNS TABLE("id" "uuid", "title" "text", "category" "text", "current_viewers" integer, "is_live" boolean, "room_name" "text", "livekit_url" "text", "start_time" timestamp with time zone, "broadcaster_id" "uuid", "thumbnail_url" "text", "popularity_score" numeric, "paid_coins_received" bigint, "chat_messages" bigint, "reactions" bigint, "user_profiles" "jsonb", "stream_momentum" "jsonb")
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  WITH w AS (
    SELECT * FROM public.get_cycle_window_30m(now())
  )
  SELECT
    s.id,
    s.title,
    s.category,
    s.current_viewers,
    s.is_live,
    s.room_name,
    s.livekit_url,
    s.start_time,
    s.broadcaster_id,
    s.thumbnail_url,
    bcs.popularity_score,
    bcs.paid_coins_received,
    bcs.chat_messages,
    bcs.reactions,
    jsonb_build_object(
      'username', up.username,
      'avatar_url', up.avatar_url,
      'date_of_birth', up.date_of_birth
    ) AS user_profiles,
    jsonb_build_object(
      'momentum', sm.momentum,
      'last_gift_at', sm.last_gift_at,
      'last_decay_at', sm.last_decay_at
    ) AS stream_momentum
  FROM w
  JOIN public.broadcast_cycle_stats bcs
    ON bcs.cycle_start = w.cycle_start
  JOIN public.streams s
    ON s.id = bcs.stream_id
  LEFT JOIN public.user_profiles up
    ON up.id = s.broadcaster_id
  LEFT JOIN public.stream_momentum sm
    ON sm.stream_id = s.id
  WHERE s.is_live = true
  ORDER BY bcs.popularity_score DESC
  LIMIT 30;
$$;


ALTER FUNCTION "public"."get_cached_home_rankings_30m"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_call_balances"("p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_audio INTEGER := 0;
  v_video INTEGER := 0;
BEGIN
  SELECT COALESCE(audio_minutes, 0), COALESCE(video_minutes, 0)
  INTO v_audio, v_video
  FROM call_minutes
  WHERE user_id = p_user_id;

  RETURN jsonb_build_object(
    'audio_minutes', v_audio,
    'video_minutes', v_video
  );
END;
$$;


ALTER FUNCTION "public"."get_call_balances"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_case_details"("p_case_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    v_case court_cases%ROWTYPE;
    v_participants JSONB;
    v_evidence JSONB;
    v_logs JSONB;
    v_template JSONB;
BEGIN
    SELECT * INTO v_case FROM court_cases WHERE id = p_case_id;
    
    SELECT jsonb_agg(to_jsonb(cp.*)) INTO v_participants 
    FROM case_participants cp WHERE case_id = p_case_id;
    
    SELECT jsonb_agg(to_jsonb(ce.*)) INTO v_evidence 
    FROM case_evidence ce WHERE case_id = p_case_id;

    SELECT jsonb_agg(to_jsonb(cal.*)) INTO v_logs
    FROM case_audit_logs cal WHERE case_id = p_case_id ORDER BY created_at DESC;
    
    SELECT to_jsonb(ct.*) INTO v_template
    FROM case_templates ct WHERE case_type = v_case.case_type;

    RETURN jsonb_build_object(
        'case', to_jsonb(v_case),
        'template', v_template,
        'participants', COALESCE(v_participants, '[]'::jsonb),
        'evidence', COALESCE(v_evidence, '[]'::jsonb),
        'logs', COALESCE(v_logs, '[]'::jsonb)
    );
END;
$$;


ALTER FUNCTION "public"."get_case_details"("p_case_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_config_bool"("p_key" "text", "p_default" boolean) RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT COALESCE(
    (SELECT (c.value::boolean) FROM public.config c WHERE c.key = p_key),
    p_default
  );
$$;


ALTER FUNCTION "public"."get_config_bool"("p_key" "text", "p_default" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_config_int"("p_key" "text", "p_default" integer) RETURNS integer
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT COALESCE(
    (SELECT (c.value::int) FROM public.config c WHERE c.key = p_key),
    p_default
  );
$$;


ALTER FUNCTION "public"."get_config_int"("p_key" "text", "p_default" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_creator_earnings"() RETURNS TABLE("id" "uuid", "content" "text", "created_at" timestamp with time zone, "total_views" bigint, "total_comments" bigint, "total_reactions" bigint, "free_coins_earned" integer, "paid_gift_coins" integer)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
select
  p.id,
  p.content,
  p.created_at,
  coalesce((select count(*) from troll_post_views    where post_id = p.id), 0) as total_views,
  coalesce((select count(*) from troll_post_comments where post_id = p.id), 0) as total_comments,
  coalesce((select count(*) from troll_post_reactions where post_id = p.id), 0) as total_reactions,
  coalesce(p.free_coins_earned, 0) as free_coins_earned,
  coalesce(p.coins_earned, 0)      as paid_gift_coins
from troll_posts p
where p.user_id = auth.uid()
order by p.created_at desc;
$$;


ALTER FUNCTION "public"."get_creator_earnings"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_creator_stats"() RETURNS TABLE("total_streams" bigint, "total_viewers" bigint, "avg_viewers_per_stream" numeric, "stream_duration_hours" numeric, "total_gifts" bigint, "unique_gifters" bigint, "avg_gift_per_viewer" numeric)
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  WITH stream_stats AS (
    SELECT
      COUNT(*) AS total_streams,
      COALESCE(SUM(current_viewers), 0) AS total_viewers,
      AVG(current_viewers) AS avg_viewers_per_stream,
      COALESCE(
        SUM(
          EXTRACT(
            EPOCH FROM (COALESCE(end_time, now()) - start_time)
          ) / 3600
        ),
        0
      ) AS stream_duration_hours
    FROM streams
    WHERE broadcaster_id = auth.uid()
  ),
  gift_stats AS (
    SELECT
      COUNT(*) AS total_gifts,
      COUNT(DISTINCT sender_id) AS unique_gifters,
      AVG(coins) AS avg_gift_per_viewer
    FROM gift_ledger
    WHERE receiver_id = auth.uid()
  )
  SELECT
    ss.total_streams,
    ss.total_viewers,
    ss.avg_viewers_per_stream,
    ss.stream_duration_hours,
    gs.total_gifts,
    gs.unique_gifters,
    gs.avg_gift_per_viewer
  FROM stream_stats ss, gift_stats gs;
$$;


ALTER FUNCTION "public"."get_creator_stats"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_creator_stats"() IS 'Returns comprehensive creator statistics including streams and viewer data';



CREATE OR REPLACE FUNCTION "public"."get_cycle_end_30m"("p_now" timestamp with time zone DEFAULT "now"()) RETURNS timestamp with time zone
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT date_trunc('hour', p_now)
       + make_interval(mins => (floor(extract(minute from p_now) / 30) * 30)::int);
$$;


ALTER FUNCTION "public"."get_cycle_end_30m"("p_now" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_cycle_window_30m"("p_now" timestamp with time zone DEFAULT "now"()) RETURNS TABLE("cycle_start" timestamp with time zone, "cycle_end" timestamp with time zone)
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT
    public.get_cycle_end_30m(p_now) - interval '30 minutes' AS cycle_start,
    public.get_cycle_end_30m(p_now) AS cycle_end;
$$;


ALTER FUNCTION "public"."get_cycle_window_30m"("p_now" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_daily_earnings_series"("days_back" integer) RETURNS TABLE("day" "date", "total_earnings" numeric)
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select
    date_trunc('day', created_at)::date as day,
    sum(amount) as total_earnings
  from public.activity_log
  where created_at >= now() - (days_back || ' days')::interval
  group by 1
  order by 1;
$$;


ALTER FUNCTION "public"."get_daily_earnings_series"("days_back" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_daily_earnings_series"("days_back" integer) IS 'Returns daily earnings data for the specified number of days';



CREATE OR REPLACE FUNCTION "public"."get_daily_giveaway_stats"() RETURNS json
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
        DECLARE
            total_awarded INTEGER;
            total_trollmonds BIGINT;
            jackpot_count INTEGER;
        BEGIN
            SELECT
                COUNT(*),
                COALESCE(SUM(trollmonds_awarded), 0),
                COUNT(*) FILTER (WHERE trollmonds_awarded = 1000)
            INTO total_awarded, total_trollmonds, jackpot_count
            FROM daily_giveaways
            WHERE giveaway_date = CURRENT_DATE;

            RETURN json_build_object(
                'giveaway_date', CURRENT_DATE,
                'total_users_awarded', total_awarded,
                'total_trollmonds_distributed', total_trollmonds,
                'jackpot_winners', jackpot_count,
                'has_run_today', has_daily_giveaway_run_today()
            );
        END;
        $$;


ALTER FUNCTION "public"."get_daily_giveaway_stats"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_district_onboarding_tour"("p_district_name" character varying) RETURNS TABLE("step_number" integer, "title" character varying, "description" "text", "target_feature" character varying, "route_path" character varying, "action_type" character varying)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- Return onboarding steps based on district
  CASE p_district_name
    WHEN 'main_plaza' THEN
      RETURN QUERY VALUES
        (1, 'Welcome to Main Plaza', 'This is the heart of Troll City! Here you can watch live streams, browse the marketplace, and connect with the community.', 'live_streams', '/live', 'highlight'),
        (2, 'Live Streams', 'Watch your favorite creators and discover new talent in real-time.', 'live_streams', '/live', 'navigate'),
        (3, 'Marketplace', 'Buy and sell items with other Troll City members.', 'marketplace', '/marketplace', 'navigate'),
        (4, 'Leaderboard', 'See how you rank among the Troll City elite.', 'leaderboard', '/leaderboard', 'navigate'),
        (5, 'Troll City Wall', 'Share posts and connect with the community.', 'wall', '/wall', 'navigate');

    WHEN 'commerce_district' THEN
      RETURN QUERY VALUES
        (1, 'Commerce District', 'Welcome to the shopping hub of Troll City! Here you can buy coins, browse items, and manage your inventory.', 'coin_store', '/store', 'highlight'),
        (2, 'Coin Store', 'Purchase Troll Coins to enhance your experience.', 'coin_store', '/store', 'navigate'),
        (3, 'Marketplace', 'Discover unique items from fellow Trolls.', 'marketplace', '/marketplace', 'navigate'),
        (4, 'Your Inventory', 'Manage your purchased items and digital goods.', 'inventory', '/inventory', 'navigate'),
        (5, 'Start Selling', 'Turn your creativity into coins by selling on Troll City.', 'sell_on_troll_city', '/sell', 'navigate');

    WHEN 'officer_quarters' THEN
      RETURN QUERY VALUES
        (1, 'Officer Quarters', 'Welcome to the Troll Officer headquarters! This is where law enforcement and moderation happens.', 'officer_lounge', '/officer/lounge', 'highlight'),
        (2, 'Officer Lounge', 'Connect with fellow officers and access exclusive resources.', 'officer_lounge', '/officer/lounge', 'navigate'),
        (3, 'Moderation Tools', 'Help maintain Troll City by moderating content and users.', 'moderation', '/officer/moderation', 'navigate'),
        (4, 'Officer Dashboard', 'Track your performance and access officer-specific features.', 'officer_dashboard', '/officer/dashboard', 'navigate');

    WHEN 'family_neighborhood' THEN
      RETURN QUERY VALUES
        (1, 'Family Neighborhood', 'Welcome to the exclusive Troll Family community! Connect with your family and compete in epic wars.', 'family_lounge', '/family/lounge', 'highlight'),
        (2, 'Family Lounge', 'Hang out with your family members and plan your next move.', 'family_lounge', '/family/lounge', 'navigate'),
        (3, 'War Hub', 'Join family wars and battle for supremacy!', 'family_wars', '/family/wars-hub', 'navigate'),
        (4, 'Family Shop', 'Purchase exclusive family items and upgrades.', 'family_shop', '/family/shop', 'navigate');

    ELSE
      -- Default empty tour
      RETURN QUERY SELECT 1, 'Welcome!', 'Explore this district and discover its features.', '', '', 'highlight'::VARCHAR(50) LIMIT 0;
  END CASE;
END;
$$;


ALTER FUNCTION "public"."get_district_onboarding_tour"("p_district_name" character varying) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_district_onboarding_tour"("p_district_name" character varying) IS 'Returns onboarding tour steps for a specific district';



CREATE OR REPLACE FUNCTION "public"."get_earnings_overview"() RETURNS json
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select public.get_earnings_overview(auth.uid());
$$;


ALTER FUNCTION "public"."get_earnings_overview"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_earnings_overview"() IS 'Returns total coins earned and payout information';



CREATE OR REPLACE FUNCTION "public"."get_earnings_overview"("p_user_id" "uuid") RETURNS json
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select json_build_object(
    'user_id', p_user_id
  );
$$;


ALTER FUNCTION "public"."get_earnings_overview"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_effective_privileges"() RETURNS TABLE("role" "text", "officer_status" "text", "probation_ends_at" timestamp with time zone, "can_moderate_chat" boolean, "can_hold_court" boolean, "can_ban_users" boolean, "can_demote_officers" boolean, "can_promote_officers" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  urole text;
  ustatus text;
  pend timestamptz;
BEGIN
  -- Auto-refresh probation status for this user (so status flips right when time ends)
  UPDATE public.profiles
  SET officer_status = 'active'
  WHERE id = auth.uid()
    AND officer_status = 'probation'
    AND probation_ends_at IS NOT NULL
    AND probation_ends_at <= now();

  -- Pull role + status
  SELECT p.role, p.officer_status, p.probation_ends_at
  INTO urole, ustatus, pend
  FROM public.profiles p
  WHERE p.id = auth.uid();

  IF urole IS NULL THEN
    RAISE EXCEPTION 'No profile found for user';
  END IF;

  -- Base privileges from role table
  RETURN QUERY
  SELECT
    urole,
    ustatus,
    pend,
    rp.can_moderate_chat,
    rp.can_hold_court,
    CASE
      -- probation restriction: NO bans while on probation
      WHEN ustatus = 'probation' THEN false
      ELSE rp.can_ban_users
    END AS can_ban_users,
    rp.can_demote_officers,
    rp.can_promote_officers
  FROM public.role_privileges rp
  WHERE rp.role = urole;

END;
$$;


ALTER FUNCTION "public"."get_effective_privileges"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_family_members_with_family"() RETURNS TABLE("member_id" "uuid", "user_id" "uuid", "role" "text", "rank_name" "text", "family_id" "uuid", "family_name" "text", "family_tag" "text", "family_logo_url" "text", "family_level" integer, "family_xp" bigint)
    LANGUAGE "sql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select 
    fm.id,
    fm.user_id,
    fm.role,
    fm.rank_name,
    tf.id,
    tf.family_name,
    tf.family_tag,
    tf.family_logo_url,
    tf.level,
    tf.xp
  from family_members fm
  join troll_families tf 
    on tf.id = fm.family_id;
$$;


ALTER FUNCTION "public"."get_family_members_with_family"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_hourly_activity"() RETURNS TABLE("hour" timestamp with time zone, "activity_count" bigint)
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select
    date_trunc('hour', created_at) as hour,
    count(*) as activity_count
  from public.activity_log
  group by 1
  order by 1;
$$;


ALTER FUNCTION "public"."get_hourly_activity"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_hourly_activity"() IS 'Returns hourly activity patterns for the last 7 days';



CREATE OR REPLACE FUNCTION "public"."get_hourly_activity"("hours_back" integer) RETURNS TABLE("hour" timestamp with time zone, "activity_count" bigint)
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select
    date_trunc('hour', created_at) as hour,
    count(*) as activity_count
  from public.activity_log
  where created_at >= now() - (hours_back || ' hours')::interval
  group by 1
  order by 1;
$$;


ALTER FUNCTION "public"."get_hourly_activity"("hours_back" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_ip_ban_history"("p_ip_address" "inet" DEFAULT NULL::"inet", "p_officer_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("id" "uuid", "ip_address" "inet", "banned_by" "uuid", "ban_reason" "text", "ban_details" "text", "banned_until" timestamp with time zone, "is_active" boolean, "created_at" timestamp with time zone, "officer_username" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ib.id,
    ib.ip_address,
    ib.banned_by,
    ib.ban_reason,
    ib.ban_details,
    ib.banned_until,
    ib.is_active,
    ib.created_at,
    up.username as officer_username
  FROM ip_bans ib
  LEFT JOIN user_profiles up ON ib.banned_by = up.id
  WHERE 
    (p_ip_address IS NULL OR ib.ip_address = p_ip_address)
    AND (p_officer_id IS NULL OR ib.banned_by = p_officer_id)
  ORDER BY ib.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_ip_ban_history"("p_ip_address" "inet", "p_officer_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_lucky_stats"("p_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("total_spent" bigint, "total_trollmonds_won" bigint, "total_wins" bigint, "win_rate" real, "biggest_win" bigint, "last_win_at" timestamp with time zone, "multiplier_counts" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF p_user_id IS NULL THEN
    p_user_id := auth.uid();
  END IF;

  -- Check permissions (users can view their own, admins can view anyone's)
  IF p_user_id != auth.uid() THEN
    IF NOT EXISTS (
      SELECT 1 FROM user_profiles
      WHERE id = auth.uid() AND role = 'admin'
    ) THEN
      RAISE EXCEPTION 'Access denied';
    END IF;
  END IF;

  RETURN QUERY
  SELECT
    COALESCE(SUM(spent_paid_coins), 0)::bigint as total_spent,
    COALESCE(SUM(trollmonds_awarded), 0)::bigint as total_trollmonds_won,
    COUNT(*) FILTER (WHERE multiplier IS NOT NULL)::bigint as total_wins,
    CASE
      WHEN COUNT(*) > 0 THEN (COUNT(*) FILTER (WHERE multiplier IS NOT NULL)::real / COUNT(*)::real) * 100
      ELSE 0
    END as win_rate,
    COALESCE(MAX(trollmonds_awarded), 0)::bigint as biggest_win,
    MAX(created_at) FILTER (WHERE multiplier IS NOT NULL) as last_win_at,
    jsonb_build_object(
      'x100', COUNT(*) FILTER (WHERE multiplier = 100),
      'x200', COUNT(*) FILTER (WHERE multiplier = 200),
      'x500', COUNT(*) FILTER (WHERE multiplier = 500),
      'x1000', COUNT(*) FILTER (WHERE multiplier = 1000),
      'x10000', COUNT(*) FILTER (WHERE multiplier = 10000)
    ) as multiplier_counts
  FROM lucky_trollmond_events
  WHERE user_id = p_user_id;
END;
$$;


ALTER FUNCTION "public"."get_lucky_stats"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_lucky_stats"("p_user_id" "uuid") IS 'Returns user lucky statistics and win rates';



CREATE OR REPLACE FUNCTION "public"."get_monthly_earnings"() RETURNS TABLE("month" "text", "total_coins" bigint)
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select
    to_char(date_trunc('month', redeemed_at), 'YYYY-MM') as month,
    coalesce(sum(coin_amount), 0)::bigint as total_coins
  from public.gift_cards
  where redeemed_by = (select auth.uid())
    and redeemed_at is not null
  group by 1
  order by 1 desc;
$$;


ALTER FUNCTION "public"."get_monthly_earnings"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_monthly_earnings"("p_user_id" "uuid") RETURNS TABLE("month" "text", "coins_earned_from_gifts" bigint, "gift_count" bigint, "unique_gifters" bigint, "troll_coins_earned" bigint, "free_coins_earned" bigint, "usd_equivalent" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    TO_CHAR(DATE_TRUNC('month', g.created_at), 'YYYY-MM') AS month,
    SUM(g.coins_spent)::bigint AS coins_earned_from_gifts,
    COUNT(DISTINCT g.id)::bigint AS gift_count,
    COUNT(DISTINCT g.sender_id)::bigint AS unique_gifters,
    SUM(CASE WHEN g.gift_type = 'paid' THEN g.coins_spent ELSE 0 END)::bigint AS troll_coins_earned,
    SUM(CASE WHEN g.gift_type = 'free' THEN g.coins_spent ELSE 0 END)::bigint AS free_coins_earned,
    (SUM(g.coins_spent)::numeric / 100.0) AS usd_equivalent
  FROM public.gifts g
  WHERE g.receiver_id = p_user_id
  GROUP BY DATE_TRUNC('month', g.created_at)
  ORDER BY DATE_TRUNC('month', g.created_at) DESC
  LIMIT 12;
END;
$$;


ALTER FUNCTION "public"."get_monthly_earnings"("p_user_id" "uuid") OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_weekly_reports" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "lead_officer_id" "uuid" NOT NULL,
    "week_start" "date" NOT NULL,
    "week_end" "date" NOT NULL,
    "report_title" "text" NOT NULL,
    "report_body" "text" NOT NULL,
    "incidents" "jsonb" DEFAULT '[]'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."officer_weekly_reports" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_weekly_reports" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_my_weekly_reports"("p_user_id" "uuid") RETURNS SETOF "public"."officer_weekly_reports"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select *
  from officer_weekly_reports
  where lead_officer_id = p_user_id
  order by created_at desc;
$$;


ALTER FUNCTION "public"."get_my_weekly_reports"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_officer_actions"() RETURNS "jsonb"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', a.id,
        'officer_id', a.officer_id,
        'officer_username', o.username,
        'action_type', a.action_type,
        'acted_by', a.acted_by,
        'acted_by_username', ab.username,
        'reason', a.reason,
        'created_at', a.created_at
      )
      order by a.created_at desc
    ),
    '[]'::jsonb
  )
  from officer_actions a
  join user_profiles o on o.id = a.officer_id
  join user_profiles ab on ab.id = a.acted_by;
$$;


ALTER FUNCTION "public"."get_officer_actions"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_officer_applicants"() RETURNS "jsonb"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', u.id,
        'username', u.username,
        'officer_role', u.officer_role,
        'score', r.score,
        'has_passed', r.has_passed,
        'completed_at', r.completed_at
      ) order by r.completed_at desc nulls last
    ),
    '[]'::jsonb
  )
  from user_profiles u
  left join officer_orientation_results r on r.user_id = u.id
  where u.officer_role = 'applicant';
$$;


ALTER FUNCTION "public"."get_officer_applicants"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_officer_cashout_history"("p_officer_id" "uuid", "p_limit" integer DEFAULT 50) RETURNS TABLE("id" "uuid", "shift_log_id" "uuid", "free_coins_redeemed" bigint, "troll_coins_received" integer, "usd_amount" numeric, "status" "text", "requested_at" timestamp with time zone, "processed_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    op.id,
    op.shift_log_id,
    op.free_coins_redeemed,
    op.troll_coins_received,
    op.usd_amount,
    op.status,
    op.requested_at,
    op.processed_at
  FROM officer_payouts op
  WHERE op.officer_id = p_officer_id
  ORDER BY op.requested_at DESC
  LIMIT p_limit;
END;
$$;


ALTER FUNCTION "public"."get_officer_cashout_history"("p_officer_id" "uuid", "p_limit" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_officer_cashout_history"("p_officer_id" "uuid", "p_limit" integer) IS 'Returns cashout history for an officer';



CREATE OR REPLACE FUNCTION "public"."get_officer_orientation_result"("p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select coalesce(
    to_jsonb(r.*),
    '{}'::jsonb
  )
  from officer_orientation_results r
  where r.user_id = p_user_id;
$$;


ALTER FUNCTION "public"."get_officer_orientation_result"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_officer_orientation_status"("p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_orientation RECORD;
  v_attempts_json JSONB;
BEGIN
  -- Get orientation
  SELECT * INTO v_orientation
  FROM officer_orientations
  WHERE user_id = p_user_id;

  IF v_orientation IS NULL THEN
    RETURN jsonb_build_object(
      'has_orientation', false,
      'status', null
    );
  END IF;

  -- Get recent attempts as JSON
  SELECT COALESCE(jsonb_agg(jsonb_build_object(
    'id', a.id,
    'score', a.score,
    'passed', a.passed,
    'completed_at', a.completed_at
  ) ORDER BY a.completed_at DESC), '[]'::jsonb) INTO v_attempts_json
  FROM officer_quiz_attempts a
  WHERE a.user_id = p_user_id
  LIMIT 5;

  RETURN jsonb_build_object(
    'has_orientation', true,
    'orientation_id', v_orientation.id,
    'status', v_orientation.status,
    'attempts', v_orientation.attempts,
    'max_attempts', v_orientation.max_attempts,
    'assigned_at', v_orientation.assigned_at,
    'started_at', v_orientation.started_at,
    'completed_at', v_orientation.completed_at,
    'recent_attempts', v_attempts_json
  );
END;
$$;


ALTER FUNCTION "public"."get_officer_orientation_status"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_officer_orientation_status"("p_user_id" "uuid") IS 'Gets the current orientation status for a user';



CREATE OR REPLACE FUNCTION "public"."get_officer_performance_summary"("p_officer_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    result JSONB;
BEGIN
    SELECT jsonb_build_object(
        'current_score', current_score,
        'lifetime_score', lifetime_score,
        'performance_rating', performance_rating,
        'cases_handled', cases_handled,
        'successful_resolutions', successful_resolutions,
        'owc_points_earned', owc_points_earned,
        'last_case_date', last_case_date
    ) INTO result
    FROM officer_performance
    WHERE officer_id = p_officer_id;

    RETURN COALESCE(result, jsonb_build_object(
        'current_score', 100,
        'lifetime_score', 100,
        'performance_rating', 'standard',
        'cases_handled', 0,
        'successful_resolutions', 0,
        'owc_points_earned', 0,
        'last_case_date', null
    ));
END;
$$;


ALTER FUNCTION "public"."get_officer_performance_summary"("p_officer_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_officer_quiz_questions"() RETURNS TABLE("id" "uuid", "question_text" "text", "option_a" "text", "option_b" "text", "option_c" "text", "option_d" "text", "category" "text", "order_index" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    q.id,
    q.question_text,
    q.option_a,
    q.option_b,
    q.option_c,
    q.option_d,
    q.category,
    q.order_index
  FROM officer_quiz_questions q
  WHERE q.is_active = true
  ORDER BY q.order_index, q.id;
END;
$$;


ALTER FUNCTION "public"."get_officer_quiz_questions"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_officer_quiz_questions"() IS 'Gets all active quiz questions';



CREATE OR REPLACE FUNCTION "public"."get_officers"() RETURNS "jsonb"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', u.id,
        'username', u.username,
        'officer_role', u.officer_role
      ) order by u.officer_role, u.username
    ),
    '[]'::jsonb
  )
  from user_profiles u
  where u.officer_role in ('officer','lead_officer');
$$;


ALTER FUNCTION "public"."get_officers"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_or_create_active_cycle"() RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  active_cycle_id UUID;
BEGIN
  -- Find active cycle (end_time > now)
  SELECT id INTO active_cycle_id
  FROM home_feature_cycles
  WHERE end_time > now()
  ORDER BY start_time DESC
  LIMIT 1;

  -- If no active cycle, create one
  IF active_cycle_id IS NULL THEN
    INSERT INTO home_feature_cycles (start_time, end_time)
    VALUES (now(), now() + INTERVAL '30 minutes')
    RETURNING id INTO active_cycle_id;
  END IF;

  RETURN active_cycle_id;
END;
$$;


ALTER FUNCTION "public"."get_or_create_active_cycle"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_owc_conversion_rate"("p_level" integer) RETURNS numeric
    LANGUAGE "plpgsql" IMMUTABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN CASE
    WHEN p_level = 1 THEN 0.005  -- 0.5%
    WHEN p_level = 2 THEN 0.007  -- 0.7%
    WHEN p_level = 3 THEN 0.008  -- 0.8%
    WHEN p_level = 4 THEN 0.009  -- 0.9%
    WHEN p_level = 5 THEN 0.011  -- 1.1%
    ELSE 0.005
  END;
END;
$$;


ALTER FUNCTION "public"."get_owc_conversion_rate"("p_level" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_owc_per_hour"("p_level" integer) RETURNS bigint
    LANGUAGE "plpgsql" IMMUTABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN CASE
    WHEN p_level = 1 THEN 1000000  -- Junior Officer
    WHEN p_level = 2 THEN 1500000  -- Senior Officer
    WHEN p_level = 3 THEN 1800000  -- Commander
    WHEN p_level = 4 THEN 2200000  -- Elite Commander
    WHEN p_level = 5 THEN 2600000  -- HQ Master Officer
    ELSE 1000000
  END;
END;
$$;


ALTER FUNCTION "public"."get_owc_per_hour"("p_level" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_public_docket_board"() RETURNS TABLE("case_type" "text", "scheduled_at" timestamp with time zone, "status" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        cd.case_type,
        cd.scheduled_at,
        cd.status
    FROM court_docket cd
    WHERE cd.status IN ('scheduled', 'in_session')
    ORDER BY cd.scheduled_at ASC;
END;
$$;


ALTER FUNCTION "public"."get_public_docket_board"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_public_docket_board"() IS 'Returns anonymized public docket board';



CREATE OR REPLACE FUNCTION "public"."get_recent_users"("limit_count" integer) RETURNS SETOF "public"."user_profiles"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select *
  from public.user_profiles
  order by created_at desc
  limit limit_count;
$$;


ALTER FUNCTION "public"."get_recent_users"("limit_count" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_royal_family_status"("p_admin_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("admin_id" "uuid", "current_wife" "jsonb", "current_husband" "jsonb", "gift_leaderboard" "jsonb", "honorary_members" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- If no admin specified, get all admins with royal families
  IF p_admin_id IS NULL THEN
    RETURN QUERY
    SELECT
      up.id as admin_id,
      -- Current wife
      CASE WHEN wf.user_id IS NOT NULL THEN
        jsonb_build_object(
          'user_id', wf.user_id,
          'username', wf_up.username,
          'total_coins', agt_wife.total_troll_coins,
          'duration_days', wf.duration_days,
          'assigned_at', wf.assigned_at
        )
      ELSE NULL END as current_wife,
      -- Current husband
      CASE WHEN hm.user_id IS NOT NULL THEN
        jsonb_build_object(
          'user_id', hm.user_id,
          'username', hm_up.username,
          'total_coins', agt_husband.total_troll_coins,
          'duration_days', hm.duration_days,
          'assigned_at', hm.assigned_at
        )
      ELSE NULL END as current_husband,
      -- Gift leaderboard (top 10)
      (SELECT jsonb_agg(
        jsonb_build_object(
          'user_id', agt.user_id,
          'username', up_gift.username,
          'total_coins', agt.total_troll_coins,
          'gender', up_gift.gender,
          'last_gift_at', agt.last_gift_at
        )
      ) FROM (
        SELECT * FROM admin_gift_totals
        WHERE admin_id = up.id AND total_troll_coins >= 50000
        ORDER BY total_troll_coins DESC
        LIMIT 10
      ) agt
      LEFT JOIN user_profiles up_gift ON agt.user_id = up_gift.id
      ) as gift_leaderboard,
      -- Honorary members
      (SELECT jsonb_agg(
        jsonb_build_object(
          'user_id', hfm.user_id,
          'username', hfm_up.username,
          'title', hfm.title,
          'assigned_at', hfm.assigned_at
        )
      ) FROM honorary_family_members hfm
      LEFT JOIN user_profiles hfm_up ON hfm.user_id = hfm_up.id
      WHERE hfm.admin_id = up.id AND hfm.is_active = true
      ) as honorary_members
    FROM user_profiles up
    LEFT JOIN royal_family_titles wf ON wf.admin_id = up.id AND wf.title_type = 'wife' AND wf.is_active = true
    LEFT JOIN user_profiles wf_up ON wf.user_id = wf_up.id
    LEFT JOIN admin_gift_totals agt_wife ON agt_wife.user_id = wf.user_id AND agt_wife.admin_id = up.id
    LEFT JOIN royal_family_titles hm ON hm.admin_id = up.id AND hm.title_type = 'husband' AND hm.is_active = true
    LEFT JOIN user_profiles hm_up ON hm.user_id = hm_up.id
    LEFT JOIN admin_gift_totals agt_husband ON agt_husband.user_id = hm.user_id AND agt_husband.admin_id = up.id
    WHERE up.role = 'admin';
  ELSE
    -- Specific admin
    RETURN QUERY
    SELECT
      p_admin_id as admin_id,
      -- Current wife
      CASE WHEN wf.user_id IS NOT NULL THEN
        jsonb_build_object(
          'user_id', wf.user_id,
          'username', wf_up.username,
          'total_coins', agt_wife.total_troll_coins,
          'duration_days', wf.duration_days,
          'assigned_at', wf.assigned_at
        )
      ELSE NULL END as current_wife,
      -- Current husband
      CASE WHEN hm.user_id IS NOT NULL THEN
        jsonb_build_object(
          'user_id', hm.user_id,
          'username', hm_up.username,
          'total_coins', agt_husband.total_troll_coins,
          'duration_days', hm.duration_days,
          'assigned_at', hm.assigned_at
        )
      ELSE NULL END as current_husband,
      -- Gift leaderboard (top 10)
      (SELECT jsonb_agg(
        jsonb_build_object(
          'user_id', agt.user_id,
          'username', up_gift.username,
          'total_coins', agt.total_troll_coins,
          'gender', up_gift.gender,
          'last_gift_at', agt.last_gift_at
        )
      ) FROM (
        SELECT * FROM admin_gift_totals
        WHERE admin_id = p_admin_id AND total_troll_coins >= 50000
        ORDER BY total_troll_coins DESC
        LIMIT 10
      ) agt
      LEFT JOIN user_profiles up_gift ON agt.user_id = up_gift.id
      ) as gift_leaderboard,
      -- Honorary members
      (SELECT jsonb_agg(
        jsonb_build_object(
          'user_id', hfm.user_id,
          'username', hfm_up.username,
          'title', hfm.title,
          'assigned_at', hfm.assigned_at
        )
      ) FROM honorary_family_members hfm
      LEFT JOIN user_profiles hfm_up ON hfm.user_id = hfm_up.id
      WHERE hfm.admin_id = p_admin_id AND hfm.is_active = true
      ) as honorary_members
    FROM user_profiles up
    LEFT JOIN royal_family_titles wf ON wf.admin_id = p_admin_id AND wf.title_type = 'wife' AND wf.is_active = true
    LEFT JOIN user_profiles wf_up ON wf.user_id = wf_up.id
    LEFT JOIN admin_gift_totals agt_wife ON agt_wife.user_id = wf.user_id AND agt_wife.admin_id = p_admin_id
    LEFT JOIN royal_family_titles hm ON hm.admin_id = p_admin_id AND hm.title_type = 'husband' AND hm.is_active = true
    LEFT JOIN user_profiles hm_up ON hm.user_id = hm_up.id
    LEFT JOIN admin_gift_totals agt_husband ON agt_husband.user_id = hm.user_id AND agt_husband.admin_id = p_admin_id
    WHERE up.id = p_admin_id;
  END IF;
END;
$$;


ALTER FUNCTION "public"."get_royal_family_status"("p_admin_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_royal_family_status"("p_admin_id" "uuid") IS 'Returns current royal family status for an admin';



CREATE OR REPLACE FUNCTION "public"."get_seller_reliability_summary"("p_seller_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    result JSONB;
BEGIN
    SELECT jsonb_build_object(
        'current_score', current_score,
        'lifetime_score', lifetime_score,
        'reliability_tier', reliability_tier,
        'orders_fulfilled', orders_fulfilled,
        'orders_cancelled', orders_cancelled,
        'disputes_raised', disputes_raised,
        'is_high_risk', is_high_risk,
        'last_order_date', last_order_date
    ) INTO result
    FROM seller_reliability
    WHERE seller_id = p_seller_id;

    RETURN COALESCE(result, jsonb_build_object(
        'current_score', 100,
        'lifetime_score', 100,
        'reliability_tier', 'standard',
        'orders_fulfilled', 0,
        'orders_cancelled', 0,
        'disputes_raised', 0,
        'is_high_risk', false,
        'last_order_date', null
    ));
END;
$$;


ALTER FUNCTION "public"."get_seller_reliability_summary"("p_seller_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_staff_role"("uid" "uuid") RETURNS "text"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select role
  from public.user_profiles
  where user_id = uid
    and coalesce(is_officer_active, false) = true
  order by created_at desc
  limit 1;
$$;


ALTER FUNCTION "public"."get_staff_role"("uid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_stream_recommendations"("p_user_id" "uuid", "p_limit" integer DEFAULT 20, "p_algorithm" character varying DEFAULT 'balanced'::character varying) RETURNS TABLE("stream_id" "uuid", "title" character varying, "category" character varying, "current_viewers" integer, "final_score" numeric, "rank_position" integer, "broadcaster_username" character varying)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    user_prefs RECORD;
BEGIN
    -- Get user preferences
    SELECT * INTO user_prefs
    FROM stream_discovery_prefs
    WHERE user_id = p_user_id;

    -- If no preferences, use defaults
    IF user_prefs IS NULL THEN
        user_prefs := ROW(p_user_id, '{}', '{}', 0, '{}', 'balanced', NOW(), NOW())::stream_discovery_prefs;
    END IF;

    CASE p_algorithm
        WHEN 'trending' THEN
            -- Return highest scoring streams
            RETURN QUERY
            SELECT
                s.id,
                s.title,
                s.category,
                s.current_viewers,
                sr.final_score,
                sr.rank_position,
                up.username
            FROM streams s
            JOIN stream_ranking sr ON s.id = sr.stream_id
            JOIN user_profiles up ON s.broadcaster_id = up.id
            WHERE s.is_live = TRUE
            ORDER BY sr.final_score DESC
            LIMIT p_limit;

        WHEN 'personalized' THEN
            -- Filter by user preferences
            RETURN QUERY
            SELECT
                s.id,
                s.title,
                s.category,
                s.current_viewers,
                sr.final_score,
                sr.rank_position,
                up.username
            FROM streams s
            JOIN stream_ranking sr ON s.id = sr.stream_id
            JOIN user_profiles up ON s.broadcaster_id = up.id
            LEFT JOIN user_reputation ur ON up.id = ur.user_id
            WHERE s.is_live = TRUE
            AND (array_length(user_prefs.preferred_categories, 1) IS NULL OR s.category = ANY(user_prefs.preferred_categories))
            AND (user_prefs.content_rating_min = 0 OR COALESCE(ur.current_score, 50) >= user_prefs.content_rating_min)
            AND (array_length(user_prefs.avoid_categories, 1) IS NULL OR s.category != ALL(user_prefs.avoid_categories))
            ORDER BY sr.final_score DESC
            LIMIT p_limit;

        ELSE
            -- Balanced approach (default)
            RETURN QUERY
            SELECT
                s.id,
                s.title,
                s.category,
                s.current_viewers,
                sr.final_score,
                sr.rank_position,
                up.username
            FROM streams s
            JOIN stream_ranking sr ON s.id = sr.stream_id
            JOIN user_profiles up ON s.broadcaster_id = up.id
            WHERE s.is_live = TRUE
            ORDER BY
                -- Mix of score and some randomness for discovery
                (sr.final_score * 0.7 + random() * 30) DESC
            LIMIT p_limit;
    END CASE;
END;
$$;


ALTER FUNCTION "public"."get_stream_recommendations"("p_user_id" "uuid", "p_limit" integer, "p_algorithm" character varying) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_system_settings"() RETURNS "public"."system_settings"
    LANGUAGE "sql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT *
  FROM public.system_settings
  ORDER BY updated_at DESC
  LIMIT 1
$$;


ALTER FUNCTION "public"."get_system_settings"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_top_broadcasters_paid_24h"("limit_count" integer DEFAULT 10) RETURNS TABLE("broadcaster_id" "uuid", "total_paid_coins" bigint, "username" "text", "avatar_url" "text")
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT
    gl.receiver_id AS broadcaster_id,
    COALESCE(SUM(gl.coins), 0)::bigint AS total_paid_coins,
    COALESCE(up.username, 'Unknown') AS username,
    COALESCE(up.avatar_url, '') AS avatar_url
  FROM public.gift_ledger gl
  LEFT JOIN public.user_profiles up
    ON up.id = gl.receiver_id
  WHERE gl.created_at >= now() - interval '24 hours'
    AND gl.source = 'paid'
  GROUP BY gl.receiver_id, up.username, up.avatar_url
  ORDER BY COALESCE(SUM(gl.coins), 0) DESC
  LIMIT GREATEST(1, LEAST(limit_count, 50));
$$;


ALTER FUNCTION "public"."get_top_broadcasters_paid_24h"("limit_count" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_top_gifters"("limit_count" integer) RETURNS TABLE("user_id" "uuid", "total_gifted" numeric)
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select
    user_id,
    sum(amount) as total_gifted
  from public.activity_log
  where action = 'gift'
  group by user_id
  order by total_gifted desc
  limit limit_count;
$$;


ALTER FUNCTION "public"."get_top_gifters"("limit_count" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_top_gifters"("limit_count" integer) IS 'Returns top gifters leaderboard with user information';



CREATE OR REPLACE FUNCTION "public"."get_unread_notification_count"("p_user_id" "uuid") RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)::INTEGER
    FROM notifications
    WHERE user_id = p_user_id
      AND is_read = FALSE
  );
END;
$$;


ALTER FUNCTION "public"."get_unread_notification_count"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_user_accessible_districts"("p_user_id" "uuid" DEFAULT "auth"."uid"()) RETURNS TABLE("id" "uuid", "name" character varying, "display_name" character varying, "description" "text", "icon" character varying, "color" character varying, "required_role" character varying, "features" "jsonb", "onboarding_completed" boolean, "visit_count" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    cd.id,
    cd.name,
    cd.display_name,
    cd.description,
    cd.icon,
    cd.color,
    cd.required_role,
    cd.features,
    COALESCE(udp.onboarding_completed, false) as onboarding_completed,
    COALESCE(udp.visit_count, 0) as visit_count
  FROM city_districts cd
  LEFT JOIN user_district_progress udp ON cd.id = udp.district_id AND udp.user_id = p_user_id
  WHERE cd.is_active = true
    AND (
      cd.required_role = 'user' OR
      cd.required_role = (SELECT role FROM user_profiles WHERE id = p_user_id) OR
      (cd.required_role = 'family_member' AND EXISTS (
        SELECT 1 FROM applications a
        WHERE a.user_id = p_user_id AND a.type = 'troll_family' AND a.status = 'approved'
      ))
    )
  ORDER BY cd.sort_order;
END;
$$;


ALTER FUNCTION "public"."get_user_accessible_districts"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_user_accessible_districts"("p_user_id" "uuid") IS 'Returns districts accessible to a specific user based on their role and permissions';



CREATE OR REPLACE FUNCTION "public"."get_user_docket"("p_user_id" "uuid" DEFAULT "auth"."uid"()) RETURNS TABLE("id" "uuid", "case_type" "text", "scheduled_at" timestamp with time zone, "status" "text", "assigned_officer" "uuid", "notes" "text", "court_session_id" "uuid")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        cd.id,
        cd.case_type,
        cd.scheduled_at,
        cd.status,
        cd.assigned_officer,
        cd.notes,
        cd.court_session_id
    FROM court_docket cd
    WHERE cd.user_id = p_user_id
    ORDER BY cd.scheduled_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_user_docket"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_user_docket"("p_user_id" "uuid") IS 'Returns docket entries for a specific user';



CREATE OR REPLACE FUNCTION "public"."get_user_gift_recipients"("p_user_id" "uuid") RETURNS TABLE("recipient_id" "uuid", "recipient_username" "text", "recipient_avatar_url" "text", "total_gifts_sent" bigint, "total_coins_sent" bigint, "last_gift_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    g.receiver_id,
    up.username,
    up.avatar_url,
    COUNT(*)::BIGINT as total_gifts,
    SUM(g.coins_spent)::BIGINT as total_coins,
    MAX(g.created_at) as last_gift
  FROM gifts g
  JOIN user_profiles up ON g.receiver_id = up.id
  WHERE g.sender_id = p_user_id
  GROUP BY g.receiver_id, up.username, up.avatar_url
  ORDER BY total_coins DESC, last_gift DESC;
END;
$$;


ALTER FUNCTION "public"."get_user_gift_recipients"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_user_gift_recipients"("p_user_id" "uuid") IS 'Returns list of users who received gifts from a specific user';



CREATE OR REPLACE FUNCTION "public"."get_user_gifters"("p_user_id" "uuid") RETURNS TABLE("gifter_id" "uuid", "gifter_username" "text", "gifter_avatar_url" "text", "total_gifts_sent" bigint, "total_coins_sent" bigint, "last_gift_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    g.sender_id,
    up.username,
    up.avatar_url,
    COUNT(*)::BIGINT as total_gifts,
    SUM(g.coins_spent)::BIGINT as total_coins,
    MAX(g.created_at) as last_gift
  FROM gifts g
  JOIN user_profiles up ON g.sender_id = up.id
  WHERE g.receiver_id = p_user_id
  GROUP BY g.sender_id, up.username, up.avatar_url
  ORDER BY total_coins DESC, last_gift DESC;
END;
$$;


ALTER FUNCTION "public"."get_user_gifters"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_user_gifters"("p_user_id" "uuid") IS 'Returns list of users who sent gifts to a specific user';



CREATE TABLE IF NOT EXISTS "public"."creator_applications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "is_trolltract_required" boolean DEFAULT true NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "reviewer_id" "uuid",
    "reviewer_notes" "text",
    "submitted_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "reviewed_at" timestamp with time zone,
    "category" "text" DEFAULT 'broadcaster'::"text" NOT NULL,
    "experience_text" "text" NOT NULL,
    "social_links" "text",
    "goals_text" "text" NOT NULL,
    "training_passed" boolean DEFAULT false,
    "empire_partner_request" boolean DEFAULT false,
    "empire_partner_reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "creator_applications_category_check" CHECK (("category" = ANY (ARRAY['broadcaster'::"text", 'empire_partner'::"text"]))),
    CONSTRAINT "creator_applications_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'denied'::"text"])))
);


ALTER TABLE "public"."creator_applications" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_user_latest_application"("p_user_id" "uuid") RETURNS "public"."creator_applications"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
    RETURN (
        SELECT * FROM creator_applications 
        WHERE user_id = p_user_id 
        ORDER BY created_at DESC 
        LIMIT 1
    );
END;
$$;


ALTER FUNCTION "public"."get_user_latest_application"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_user_monthly_coins_earned"("p_user_id" "uuid", "p_month" "text") RETURNS bigint
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_total_coins bigint := 0;
  v_year int;
  v_month int;
BEGIN
  -- Parse month string (e.g., '2025-02')
  v_year := CAST(SPLIT_PART(p_month, '-', 1) AS int);
  v_month := CAST(SPLIT_PART(p_month, '-', 2) AS int);
  
  -- Calculate total from gifts table (coins received)
  SELECT COALESCE(SUM(coins_spent), 0) INTO v_total_coins
  FROM gifts
  WHERE receiver_id = p_user_id
    AND EXTRACT(YEAR FROM created_at) = v_year
    AND EXTRACT(MONTH FROM created_at) = v_month;
  
  -- Add coins from battle gifts (if battle_gifts table exists)
  -- Note: Adjust based on your actual battle gifts table structure
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'troll_battle_gifts') THEN
    SELECT COALESCE(v_total_coins + SUM(coins_spent), v_total_coins) INTO v_total_coins
    FROM troll_battle_gifts
    WHERE receiver_id = p_user_id
      AND EXTRACT(YEAR FROM created_at) = v_year
      AND EXTRACT(MONTH FROM created_at) = v_month;
  END IF;
  
  -- Add any other coin sources (troll events, etc.)
  -- Extend this function as needed for other coin sources
  
  RETURN COALESCE(v_total_coins, 0);
END;
$$;


ALTER FUNCTION "public"."get_user_monthly_coins_earned"("p_user_id" "uuid", "p_month" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_user_monthly_coins_earned"("p_user_id" "uuid", "p_month" "text") IS 'Calculates total coins earned by a user in a specific month from all sources';



CREATE OR REPLACE FUNCTION "public"."get_user_reputation_summary"("p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    result JSONB;
BEGIN
    SELECT jsonb_build_object(
        'current_score', current_score,
        'lifetime_score', lifetime_score,
        'reputation_tier', reputation_tier,
        'violations_count', violations_count,
        'court_appearances', court_appearances,
        'missed_court_sessions', missed_court_sessions,
        'is_escalation_priority', is_escalation_priority,
        'last_violation_date', last_violation_date
    ) INTO result
    FROM user_reputation
    WHERE user_id = p_user_id;

    RETURN COALESCE(result, jsonb_build_object(
        'current_score', 100,
        'lifetime_score', 100,
        'reputation_tier', 'good',
        'violations_count', 0,
        'court_appearances', 0,
        'missed_court_sessions', 0,
        'is_escalation_priority', false,
        'last_violation_date', null
    ));
END;
$$;


ALTER FUNCTION "public"."get_user_reputation_summary"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_weekly_family_task_counts"() RETURNS TABLE("family_id" "uuid", "family_name" "text", "task_count" integer)
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
SELECT 
  f.id AS family_id, 
  f.family_name AS family_name, 
  COALESCE(cnt.c, 0) AS task_count
  FROM troll_families f
  LEFT JOIN (
    SELECT family_id, COUNT(*) AS c FROM family_tasks_new WHERE status = 'active' GROUP BY family_id
  ) cnt ON cnt.family_id = f.id
  ORDER BY cnt.c DESC NULLS LAST;
$$;


ALTER FUNCTION "public"."get_weekly_family_task_counts"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_weekly_reports_for_admin"() RETURNS SETOF "public"."officer_weekly_reports"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select * from officer_weekly_reports
  order by created_at desc;
$$;


ALTER FUNCTION "public"."get_weekly_reports_for_admin"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."grant_entrance_effect"("p_user_id" "uuid", "p_effect_id" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  -- Insert if not already owned
  insert into user_entrance_effects (user_id, entrance_effect_id, is_active)
  values (p_user_id, p_effect_id, false)
  on conflict (user_id, entrance_effect_id) do nothing;

  return jsonb_build_object('success', true);
end;
$$;


ALTER FUNCTION "public"."grant_entrance_effect"("p_user_id" "uuid", "p_effect_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."grant_family_crown"("p_family_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  UPDATE troll_families SET level = level + 1 WHERE id = p_family_id;
  UPDATE user_profiles SET has_crown_badge = true WHERE id IN (SELECT user_id FROM troll_family_members WHERE family_id = p_family_id);
END;
$$;


ALTER FUNCTION "public"."grant_family_crown"("p_family_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."grant_og_badge"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- Grant OG badge to all users until 2026-01-01
  IF CURRENT_DATE < '2026-01-01' THEN
    NEW.og_badge = true;
  ELSE
    -- After 2026-01-01, only grant to early users (created before 2026-01-01)
    IF NEW.created_at < '2026-01-01' THEN
      NEW.og_badge = true;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."grant_og_badge"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_battle_gift"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  is_battle_gift BOOLEAN;
BEGIN
  is_battle_gift := NEW.battle_id IS NOT NULL;

  -- logic here

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_battle_gift"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_chargeback_ban"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF NEW.status = 'chargeback' AND (TG_OP = 'INSERT' OR OLD.status IS DISTINCT FROM NEW.status) THEN
    UPDATE public.user_profiles
    SET
      is_banned = true,
      ban_expires_at = NULL,
      banned_until = NULL,
      account_reset_after_ban = false,
      updated_at = now()
    WHERE id = NEW.user_id;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_chargeback_ban"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_gift_bonus"("p_sender_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  total_gifts int;
  bonus int := 0;
  bonus_message text := '';
BEGIN
  -- Count how many gifts user has sent (from transactions table)
  SELECT COUNT(*) INTO total_gifts
  FROM transactions
  WHERE user_id = p_sender_id
    AND type = 'gift'
    AND transaction_type = 'gift';

  -- Determine bonus tiers
  IF total_gifts = 5 THEN 
    bonus := 2;
    bonus_message := 'üéâ 5 Gifts Milestone!';
  ELSIF total_gifts = 10 THEN 
    bonus := 6;
    bonus_message := 'üéâ 10 Gifts Milestone!';
  ELSIF total_gifts = 25 THEN 
    bonus := 18;
    bonus_message := 'üéâ 25 Gifts Milestone!';
  ELSIF total_gifts = 50 THEN 
    bonus := 50;
    bonus_message := 'üéâ 50 Gifts Milestone!';
  ELSIF total_gifts = 100 THEN 
    bonus := 250;
    bonus_message := 'üéâ 100 Gifts Milestone!';
  END IF;

  -- Apply bonus if any
  IF bonus > 0 THEN
    UPDATE user_profiles
    SET troll_coins = troll_coins + bonus
    WHERE id = p_sender_id;

    -- Record bonus transaction
    INSERT INTO coin_transactions (
      user_id,
      type,
      coins,
      description,
      metadata
    ) VALUES (
      p_sender_id,
      'gift_bonus',
      bonus,
      bonus_message,
      jsonb_build_object(
        'total_gifts', total_gifts,
        'bonus_tier', total_gifts
      )
    );
  END IF;

  -- Return bonus info
  RETURN jsonb_build_object(
    'bonus_awarded', bonus > 0,
    'bonus_amount', bonus,
    'total_gifts', total_gifts,
    'message', bonus_message
  );
END;
$$;


ALTER FUNCTION "public"."handle_gift_bonus"("p_sender_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."handle_gift_bonus"("p_sender_id" "uuid") IS 'Awards bonus free coins when users reach gift milestones (5, 10, 25, 50, 100 gifts)';



CREATE OR REPLACE FUNCTION "public"."handle_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- Auto-confirm the user's email
  UPDATE auth.users 
  SET email_confirmed_at = NOW() 
  WHERE id = NEW.id;
  
  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  -- Log error but don't fail the user creation
  RAISE WARNING 'Error auto-confirming user: %', SQLERRM;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user_profile"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  insert into public.user_profiles (user_id, email)
  values (new.id, new.email)
  on conflict (user_id) do update set email = excluded.email;
  return new;
end;
$$;


ALTER FUNCTION "public"."handle_new_user_profile"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user_troll_coins"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  INSERT INTO public.user_profiles (id, troll_coins)
  VALUES (NEW.id, 500)
  ON CONFLICT (id)
  DO UPDATE SET troll_coins = COALESCE(user_profiles.troll_coins, 500);

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_user_troll_coins"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_user_signup"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_username text;
  v_avatar_url text;
  v_email text;
  v_role text;
BEGIN
  -- Extract values with proper defaults
  -- Check both raw_user_meta_data and user_metadata for username
  v_username := COALESCE(
    NEW.raw_user_meta_data->>'username',
    NEW.raw_app_metadata->>'username',
    split_part(NEW.email, '@', 1),
    'user' || substr(NEW.id::text, 1, 8)
  );
  v_avatar_url := COALESCE(
    NEW.raw_user_meta_data->>'avatar_url',
    'https://api.dicebear.com/7.x/avataaars/svg?seed=' || COALESCE(NEW.raw_user_meta_data->>'username', split_part(NEW.email, '@', 1))
  );
  v_email := COALESCE(NEW.email, '');
  
  -- Set role based on email
  IF v_email = 'trollcity2025@gmail.com' THEN
    v_role := 'admin';
  ELSE
    v_role := 'user';
  END IF;

  -- Insert user profile with all required columns
  INSERT INTO public.user_profiles (
    id,
    username,
    avatar_url,
    bio,
    role,
    tier,
    troll_coins,
    troll_coins,
    total_earned_coins,
    total_spent_coins,
    email,
    terms_accepted,
    created_at,
    updated_at
  ) VALUES (
    NEW.id,
    v_username,
    v_avatar_url,
    'New troll in the city!',
    v_role,
    'Bronze',
    0,
    100,
    100,
    0,
    v_email,
    false,
    NOW(),
    NOW()
  )
  ON CONFLICT (id) DO NOTHING; -- Prevent duplicate key errors

  -- Create welcome coin transaction
  INSERT INTO public.coin_transactions (user_id, type, amount, description, created_at)
  VALUES (NEW.id, 'purchase', 100, 'Welcome bonus coins!', NOW())
  ON CONFLICT DO NOTHING;

  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  -- Log the error but don't fail the auth.users insert
  RAISE WARNING 'Error creating user profile for %: %', NEW.id, SQLERRM;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_user_signup"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."has_accepted_agreement"("p_user_id" "uuid", "p_agreement_version" "text" DEFAULT '1.0'::"text") RETURNS boolean
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_agreements
    WHERE user_id = p_user_id
      AND agreement_version = COALESCE(p_agreement_version, '1.0')
  );
$$;


ALTER FUNCTION "public"."has_accepted_agreement"("p_user_id" "uuid", "p_agreement_version" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."has_active_perk"("p_user_id" "uuid", "p_perk_id" "text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN EXISTS(
    SELECT 1 FROM user_perks
    WHERE user_id = p_user_id
      AND perk_id = p_perk_id
      AND is_active = true
      AND expires_at > NOW()
  );
END;
$$;


ALTER FUNCTION "public"."has_active_perk"("p_user_id" "uuid", "p_perk_id" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."has_active_perk"("p_user_id" "uuid", "p_perk_id" "text") IS 'Checks if user has an active perk';



CREATE OR REPLACE FUNCTION "public"."has_daily_giveaway_run_today"() RETURNS boolean
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
        BEGIN
            RETURN EXISTS (
                SELECT 1 FROM daily_giveaways
                WHERE giveaway_date = CURRENT_DATE
                LIMIT 1
            );
        END;
        $$;


ALTER FUNCTION "public"."has_daily_giveaway_run_today"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."healthcheck"() RETURNS json
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT json_build_object('ok', true, 'timestamp', now(), 'status', 'healthy');
$$;


ALTER FUNCTION "public"."healthcheck"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."hire_officer"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  update user_profiles
  set officer_role = 'officer'
  where id = p_user_id;

  insert into officer_actions (officer_id, action_type, acted_by, reason)
  values (p_user_id, 'hired', p_acted_by, p_reason);
end;
$$;


ALTER FUNCTION "public"."hire_officer"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."increment_paid_balance"("userid" "uuid", "coin_amount" integer) RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  UPDATE user_profiles
  SET paid_coin_balance = paid_coin_balance + coin_amount
  WHERE id = userid;

  INSERT INTO coin_transactions (user_id, coins_awarded, usd_amount, source, status)
  VALUES (userid, coin_amount, 0, 'purchase', 'completed');
END;
$$;


ALTER FUNCTION "public"."increment_paid_balance"("userid" "uuid", "coin_amount" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."increment_stream_likes"("stream_id" "uuid") RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare new_total integer;
begin
  update public.streams
  set total_likes = coalesce(total_likes,0) + 1
  where id = stream_id
  returning total_likes into new_total;

  return new_total;
end;
$$;


ALTER FUNCTION "public"."increment_stream_likes"("stream_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."increment_stream_mute_count"("p_stream_id" "uuid", "p_target_user_id" "uuid", "p_muted_by" "uuid") RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_count integer;
BEGIN
  INSERT INTO public.stream_mute_counts (
    stream_id,
    target_user_id,
    mute_count,
    last_muted_by,
    updated_at
  ) VALUES (
    p_stream_id,
    p_target_user_id,
    1,
    p_muted_by,
    now()
  )
  ON CONFLICT (stream_id, target_user_id)
  DO UPDATE SET
    mute_count = public.stream_mute_counts.mute_count + 1,
    last_muted_by = excluded.last_muted_by,
    updated_at = now()
  RETURNING mute_count INTO v_count;

  RETURN v_count;
END;
$$;


ALTER FUNCTION "public"."increment_stream_mute_count"("p_stream_id" "uuid", "p_target_user_id" "uuid", "p_muted_by" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."increment_stream_viewers"("stream_id_input" "uuid") RETURNS "void"
    LANGUAGE "sql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
  update public.streams
  set viewer_count = viewer_count + 1
  where id = stream_id_input;
$$;


ALTER FUNCTION "public"."increment_stream_viewers"("stream_id_input" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."increment_trollmonds"("p_user_id" "uuid", "p_amount" bigint) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
begin
  update user_profiles
  set trollmonds = coalesce(trollmonds, 0) + p_amount
  where id = p_user_id;
end;
$$;


ALTER FUNCTION "public"."increment_trollmonds"("p_user_id" "uuid", "p_amount" bigint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_admin"() RETURNS boolean
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid() AND role = 'admin'
  );
$$;


ALTER FUNCTION "public"."is_admin"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_admin"("uid" "uuid") RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select exists(
    select 1
    from public.user_profiles
    where user_id = uid
      and role = 'admin'
      and coalesce(is_officer_active, false) = true
  );
$$;


ALTER FUNCTION "public"."is_admin"("uid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_admin_or_secretary"() RETURNS boolean
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_profiles up
    WHERE up.id = auth.uid()
      AND up.role IN ('admin','secretary')
  );
$$;


ALTER FUNCTION "public"."is_admin_or_secretary"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_admin_user"("p_user_id" "uuid") RETURNS boolean
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_roles
    WHERE user_id = p_user_id
      AND role = 'admin'
  );
$$;


ALTER FUNCTION "public"."is_admin_user"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_court_admin"() RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT EXISTS (
    SELECT 1
    FROM user_profiles up
    WHERE up.id = auth.uid()
      AND (
        up.role = 'admin'
        OR up.role = 'lead_troll_officer'
        OR up.is_admin = true
        OR up.is_lead_officer = true
      )
  );
$$;


ALTER FUNCTION "public"."is_court_admin"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_ip_banned"("p_ip_address" "inet") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_ban_count integer;
BEGIN
  SELECT COUNT(*) INTO v_ban_count
  FROM ip_bans
  WHERE ip_address = p_ip_address
    AND is_active = true
    AND (banned_until IS NULL OR banned_until > now());
  
  RETURN v_ban_count > 0;
END;
$$;


ALTER FUNCTION "public"."is_ip_banned"("p_ip_address" "inet") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."is_ip_banned"("p_ip_address" "inet") IS 'Checks if an IP address is currently banned';



CREATE OR REPLACE FUNCTION "public"."is_lead"() RETURNS boolean
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid() AND role = 'lead_troll_officer'
  );
$$;


ALTER FUNCTION "public"."is_lead"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_lead_officer"() RETURNS boolean
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select jwt_role() = 'lead_troll_officer';
$$;


ALTER FUNCTION "public"."is_lead_officer"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_lead_officer_position_filled"() RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM user_profiles
    WHERE is_lead_officer = TRUE 
    OR officer_role = 'lead_officer'
    OR officer_role = 'owner'
  );
END;
$$;


ALTER FUNCTION "public"."is_lead_officer_position_filled"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."is_lead_officer_position_filled"() IS 'Checks if lead officer position is already filled';



CREATE OR REPLACE FUNCTION "public"."is_officer_or_admin"() RETURNS boolean
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select jwt_role() in ('troll_officer','lead_troll_officer','admin');
$$;


ALTER FUNCTION "public"."is_officer_or_admin"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_og_period_active"() RETURNS boolean
    LANGUAGE "sql" STABLE
    AS $$
  SELECT NOW() < '2026-02-01 00:00:00'::timestamptz;
$$;


ALTER FUNCTION "public"."is_og_period_active"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_paid_user"("uid" "uuid") RETURNS boolean
    LANGUAGE "sql" STABLE
    AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_profiles up
    WHERE up.id = uid
      AND up.has_paid = true
  );
$$;


ALTER FUNCTION "public"."is_paid_user"("uid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_payout_locked"() RETURNS boolean
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_settings public.system_settings;
BEGIN
  SELECT * INTO v_settings FROM public.system_settings ORDER BY updated_at DESC LIMIT 1;
  IF v_settings IS NULL THEN
    RETURN TRUE;
  END IF;
  IF v_settings.payout_lock_enabled = TRUE THEN
    IF v_settings.payout_unlock_at IS NOT NULL AND now() >= v_settings.payout_unlock_at THEN
      PERFORM public.auto_unlock_payouts();
      RETURN FALSE;
    END IF;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END
$$;


ALTER FUNCTION "public"."is_payout_locked"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_payout_window_open"() RETURNS boolean
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public'
    AS $$
  SELECT (
    EXTRACT(DOW FROM (now() AT TIME ZONE 'UTC')) IN (1, 5)
    AND EXTRACT(HOUR FROM (now() AT TIME ZONE 'UTC')) >= 1
  );
$$;


ALTER FUNCTION "public"."is_payout_window_open"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_secretary"() RETURNS boolean
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.secretary_assignments
    WHERE secretary_id = auth.uid()
  );
$$;


ALTER FUNCTION "public"."is_secretary"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_staff"() RETURNS boolean
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT public.is_admin() OR public.is_secretary() OR public.is_lead();
$$;


ALTER FUNCTION "public"."is_staff"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_staff"("p_uid" "uuid") RETURNS boolean
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.user_profiles up
    WHERE up.id = p_uid
    AND (up.role = 'admin' OR up.role = 'secretary' OR up.is_admin = true)
  );
$$;


ALTER FUNCTION "public"."is_staff"("p_uid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."join_city_event"("p_event_id" "uuid", "p_user_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
    INSERT INTO event_participants (event_id, user_id)
    VALUES (p_event_id, p_user_id)
    ON CONFLICT (event_id, user_id) DO NOTHING;

    -- Update participation count
    UPDATE city_events
    SET participation_count = participation_count + 1
    WHERE id = p_event_id;
END;
$$;


ALTER FUNCTION "public"."join_city_event"("p_event_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."join_tromody_queue"() RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare
  me uuid := auth.uid();
  opponent uuid;
  sid uuid;
begin
  delete from public.tromody_queue where user_id = me;

  select user_id into opponent
  from public.tromody_queue
  where user_id <> me
  order by created_at
  limit 1;

  if opponent is null then
    insert into public.tromody_queue (user_id, status)
    values (me, 'waiting')
    on conflict (user_id) do update set status = 'waiting';
    return null;
  end if;

  delete from public.tromody_queue where user_id = opponent;

  sid := public.create_tromody_session(me);

  perform public.join_tromody_side(sid, opponent, 'left');
  perform public.join_tromody_side(sid, me, 'right');

  return sid;
end;
$$;


ALTER FUNCTION "public"."join_tromody_queue"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."join_tromody_side"("p_session" "uuid", "p_user" "uuid", "p_side" "text") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare s public.tromody_sessions;
begin
  select * into s from public.tromody_sessions where id = p_session for update;

  if not found then
    raise exception 'Session not found';
  end if;

  if s.status not in ('waiting','live') then
    raise exception 'Cannot join session';
  end if;

  if p_side = 'left' then
    if s.left_user_id is not null then
      raise exception 'Left side is taken';
    end if;
    update public.tromody_sessions
    set left_user_id = p_user,
        status = case when right_user_id is not null then 'live' else status end,
        started_at = case when right_user_id is not null and started_at is null then now() else started_at end
    where id = p_session;

  elsif p_side = 'right' then
    if s.right_user_id is not null then
      raise exception 'Right side is taken';
    end if;
    update public.tromody_sessions
    set right_user_id = p_user,
        status = case when left_user_id is not null then 'live' else status end,
        started_at = case when left_user_id is not null and started_at is null then now() else started_at end
    where id = p_session;

  else
    raise exception 'Invalid side';
  end if;
end;
$$;


ALTER FUNCTION "public"."join_tromody_side"("p_session" "uuid", "p_user" "uuid", "p_side" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."jwt_role"() RETURNS "text"
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select coalesce(auth.jwt() ->> 'troll_role','user');
$$;


ALTER FUNCTION "public"."jwt_role"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."kick_tromody_user"("p_session" "uuid", "p_side" "text") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare
  role text := jwt_role();
begin
  if not public.is_officer_or_admin() then
    raise exception 'Not authorized';
  end if;

  if p_side = 'left' then
    update public.tromody_sessions
    set left_user_id = null
    where id = p_session;

  elsif p_side = 'right' then
    update public.tromody_sessions
    set right_user_id = null
    where id = p_session;

  else
    raise exception 'Invalid side';
  end if;
end;
$$;


ALTER FUNCTION "public"."kick_tromody_user"("p_session" "uuid", "p_side" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."kick_user"("p_target_user_id" "uuid", "p_kicker_user_id" "uuid", "p_stream_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_kicker_balance integer;
  v_kick_cost integer := 500;
  v_target_kick_count integer;
BEGIN
  -- Check if kicker has enough paid coins
  SELECT paid_coin_balance
  INTO v_kicker_balance
  FROM public.user_profiles
  WHERE id = p_kicker_user_id;

  IF v_kicker_balance IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Kicker profile not found.');
  END IF;

  IF v_kicker_balance < v_kick_cost THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', format('Insufficient troll_coins. Need %s troll_coins to kick a user.', v_kick_cost)
    );
  END IF;

  -- Deduct coins from kicker
  UPDATE public.user_profiles
  SET paid_coin_balance = paid_coin_balance - v_kick_cost
  WHERE id = p_kicker_user_id;

  -- Get current kick count for target
  SELECT COALESCE(kick_count, 0)
  INTO v_target_kick_count
  FROM public.user_profiles
  WHERE id = p_target_user_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Target profile not found.');
  END IF;

  -- Update target user's kick status
  UPDATE public.user_profiles
  SET
    kick_count = v_target_kick_count + 1,
    last_kicked_at = now(),
    is_kicked = true,
    kicked_until = now() + interval '1 hour'
  WHERE id = p_target_user_id;

  -- Log the kick
  INSERT INTO public.kick_logs (kicked_user_id, kicked_by_user_id, stream_id, kick_cost_paid)
  VALUES (p_target_user_id, p_kicker_user_id, p_stream_id, v_kick_cost);

  -- Check if this is the 3rd kick (auto-ban)
  IF v_target_kick_count + 1 >= 3 THEN
    UPDATE public.user_profiles
    SET
      is_banned = true,
      banned_until = NULL,
      account_reset_after_ban = true
    WHERE id = p_target_user_id;

    RETURN jsonb_build_object(
      'success', true,
      'kicked', true,
      'auto_banned', true,
      'message', 'User kicked and auto-banned. Must pay $20 to restore account.'
    );
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'kicked', true,
    'kick_count', v_target_kick_count + 1,
    'message', 'User kicked. They can pay 250 troll_coins to re-enter.'
  );
END;
$_$;


ALTER FUNCTION "public"."kick_user"("p_target_user_id" "uuid", "p_kicker_user_id" "uuid", "p_stream_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."kick_user"("p_target_user_id" "uuid", "p_kicker_user_id" "uuid", "p_stream_id" "uuid") IS 'Kicks a user from the app. Costs 500 troll_coins. After 3 kicks, user is auto-banned.';



CREATE OR REPLACE FUNCTION "public"."kick_user_from_stream"("target_user" "uuid", "stream_id" "uuid", "reason" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare role text;
begin
  role := public.get_staff_role(auth.uid());

  if role not in ('admin','lead_troll_officer','troll_officer') then
    insert into public.moderation_actions(actor_id, target_user_id, action_type, reason, status, error_message)
    values(auth.uid(), target_user, 'kick', reason, 'failed', 'not authorized');
    return jsonb_build_object('status','error','message','not authorized');
  end if;

  -- Example: mark participant removed (adjust to your table)
  update public.stream_participants
  set removed = true, removed_reason = reason, removed_at = now()
  where user_id = target_user and stream_id = stream_id;

  insert into public.moderation_actions(actor_id, target_user_id, action_type, reason, action_payload)
  values(auth.uid(), target_user, 'kick', reason, jsonb_build_object('stream_id', stream_id));

  return jsonb_build_object('status','ok','message','user kicked');
end;
$$;


ALTER FUNCTION "public"."kick_user_from_stream"("target_user" "uuid", "stream_id" "uuid", "reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_admin_action"("p_action_type" "text", "p_target_id" "uuid" DEFAULT NULL::"uuid", "p_details" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_log_id uuid;
BEGIN
  INSERT INTO public.action_logs (
    actor_id,
    target_id,
    action_type,
    details,
    created_at
  ) VALUES (
    auth.uid(),
    p_target_id,
    p_action_type,
    p_details,
    now()
  )
  RETURNING id INTO v_log_id;
  
  RETURN v_log_id;
END;
$$;


ALTER FUNCTION "public"."log_admin_action"("p_action_type" "text", "p_target_id" "uuid", "p_details" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_coin_gift"("receiver_id" "uuid", "gift_amount" numeric) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  insert into public.activity_logs (
    user_id,
    target_user_id,
    action,
    amount,
    unit
  )
  values (
    auth.uid(),
    receiver_id,
    'coin_gift',
    gift_amount,
    'COINS'
  );
end;
$$;


ALTER FUNCTION "public"."log_coin_gift"("receiver_id" "uuid", "gift_amount" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_payout_status_change"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF OLD.status IS DISTINCT FROM NEW.status THEN
    INSERT INTO public.action_logs (actor_id, target_id, action_type, details)
    VALUES (
      auth.uid(),
      NEW.user_id,
      'payout_status_change',
      jsonb_build_object(
        'payout_id', NEW.id,
        'old_status', OLD.status,
        'new_status', NEW.status,
        'amount_usd', NEW.amount_usd
      )
    );
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."log_payout_status_change"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_security_event"("p_url" "text", "p_user_agent" "text", "p_user_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  insert into security_events (url, user_agent, user_id)
  values (p_url, p_user_agent, p_user_id);
end;
$$;


ALTER FUNCTION "public"."log_security_event"("p_url" "text", "p_user_agent" "text", "p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_security_event"("p_ip" "text", "p_url" "text", "p_user_agent" "text", "p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  INSERT INTO security_events (
    ip_address,
    request_url,
    user_agent,
    user_id
  ) VALUES (
    p_ip,
    p_url,
    p_user_agent,
    p_user_id
  );

  RETURN jsonb_build_object(
    'success', TRUE,
    'message', 'Security event logged'
  );
END;
$$;


ALTER FUNCTION "public"."log_security_event"("p_ip" "text", "p_url" "text", "p_user_agent" "text", "p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_security_event"("p_url" "text", "p_user_agent" "text", "p_user_id" "uuid", "p_ip" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  insert into security_events (url, user_agent, user_id, ip_address)
  values (p_url, p_user_agent, p_user_id, p_ip);
end;
$$;


ALTER FUNCTION "public"."log_security_event"("p_url" "text", "p_user_agent" "text", "p_user_id" "uuid", "p_ip" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_security_event"("p_event" "text", "p_ip" "text", "p_url" "text", "p_user_agent" "text", "p_user_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  INSERT INTO security_logs (
    event,
    ip_address,
    url,
    user_agent,
    user_id,
    created_at
  ) VALUES (
    p_event,
    p_ip,
    p_url,
    p_user_agent,
    p_user_id,
    NOW()
  );
END;
$$;


ALTER FUNCTION "public"."log_security_event"("p_event" "text", "p_ip" "text", "p_url" "text", "p_user_agent" "text", "p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_security_event"("p_ip" "text", "p_url" "text", "p_user_agent" "text", "p_user_id" "uuid", "p_event" "text" DEFAULT 'unknown'::"text") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  INSERT INTO security_logs (
    id,
    user_id,
    ip_address,
    url_accessed,
    user_agent,
    event_type,
    created_at
  )
  VALUES (
    gen_random_uuid(),
    p_user_id,
    p_ip,
    p_url,
    p_user_agent,
    p_event,
    NOW()
  );
END;
$$;


ALTER FUNCTION "public"."log_security_event"("p_ip" "text", "p_url" "text", "p_user_agent" "text", "p_user_id" "uuid", "p_event" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_user_moderation"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF (OLD.is_banned IS DISTINCT FROM NEW.is_banned) THEN
    INSERT INTO public.action_logs (actor_id, target_id, action_type, details)
    VALUES (
      auth.uid(),
      NEW.id,
      CASE WHEN NEW.is_banned THEN 'ban_user' ELSE 'unban_user' END,
      jsonb_build_object('reason', 'manual_update')
    );
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."log_user_moderation"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mai_append_event"("p_event_type" "text", "p_target_user_id" "uuid" DEFAULT NULL::"uuid", "p_stream_id" "uuid" DEFAULT NULL::"uuid", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb", "p_sensitive_hash" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_id uuid;
BEGIN
  INSERT INTO public.mai_timeline_events (
    event_type,
    actor_user_id,
    target_user_id,
    stream_id,
    metadata,
    sensitive_hash
  )
  VALUES (
    COALESCE(NULLIF(trim(p_event_type), ''), 'unknown'),
    auth.uid(),
    p_target_user_id,
    p_stream_id,
    COALESCE(p_metadata, '{}'::jsonb),
    p_sensitive_hash
  )
  RETURNING id INTO v_id;

  RETURN v_id;
END;
$$;


ALTER FUNCTION "public"."mai_append_event"("p_event_type" "text", "p_target_user_id" "uuid", "p_stream_id" "uuid", "p_metadata" "jsonb", "p_sensitive_hash" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."manage_honorary_family_member"("p_user_id" "uuid", "p_admin_id" "uuid", "p_action" character varying, "p_title" character varying DEFAULT 'Honorary Family Member'::character varying) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_admin_check BOOLEAN;
BEGIN
  -- Check if caller is admin
  SELECT EXISTS(
    SELECT 1 FROM user_profiles
    WHERE id = auth.uid() AND role = 'admin'
  ) INTO v_admin_check;

  IF NOT v_admin_check THEN
    RETURN jsonb_build_object('success', false, 'error', 'Only admins can manage honorary family members');
  END IF;

  IF p_action = 'add' THEN
    INSERT INTO honorary_family_members (user_id, admin_id, assigned_by, title)
    VALUES (p_user_id, p_admin_id, auth.uid(), p_title)
    ON CONFLICT (user_id, admin_id)
    DO UPDATE SET
      title = p_title,
      assigned_by = auth.uid(),
      assigned_at = NOW(),
      is_active = true,
      removed_at = NULL,
      updated_at = NOW();

    RETURN jsonb_build_object('success', true, 'action', 'added');

  ELSIF p_action = 'remove' THEN
    UPDATE honorary_family_members
    SET is_active = false,
        removed_at = NOW(),
        updated_at = NOW()
    WHERE user_id = p_user_id AND admin_id = p_admin_id;

    RETURN jsonb_build_object('success', true, 'action', 'removed');

  ELSIF p_action = 'update_title' THEN
    UPDATE honorary_family_members
    SET title = p_title,
        updated_at = NOW()
    WHERE user_id = p_user_id AND admin_id = p_admin_id AND is_active = true;

    RETURN jsonb_build_object('success', true, 'action', 'updated');
  END IF;

  RETURN jsonb_build_object('success', false, 'error', 'Invalid action');
END;
$$;


ALTER FUNCTION "public"."manage_honorary_family_member"("p_user_id" "uuid", "p_admin_id" "uuid", "p_action" character varying, "p_title" character varying) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."manage_honorary_family_member"("p_user_id" "uuid", "p_admin_id" "uuid", "p_action" character varying, "p_title" character varying) IS 'Admin function to add/remove honorary family members';



CREATE OR REPLACE FUNCTION "public"."mark_all_notifications_read"("p_user_id" "uuid") RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  updated_count INTEGER;
BEGIN
  UPDATE notifications
  SET is_read = TRUE
  WHERE user_id = p_user_id
    AND is_read = FALSE;
  
  GET DIAGNOSTICS updated_count = ROW_COUNT;
  RETURN updated_count;
END;
$$;


ALTER FUNCTION "public"."mark_all_notifications_read"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_conversation_read"("p_conversation_id" "uuid") RETURNS "void"
    LANGUAGE "sql" SECURITY DEFINER
    AS $$
  update public.message_receipts r
  set read_at = coalesce(r.read_at, now()),
      delivered_at = coalesce(r.delivered_at, now())
  from public.conversation_messages m
  where r.message_id = m.id
    and m.conversation_id = p_conversation_id
    and r.user_id = auth.uid()
    and m.sender_id <> auth.uid();
$$;


ALTER FUNCTION "public"."mark_conversation_read"("p_conversation_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_expired_referrals_failed"() RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
        BEGIN
            UPDATE referrals
            SET reward_status = 'failed', updated_at = NOW()
            WHERE reward_status = 'pending' AND deadline < NOW();
        END;
        $$;


ALTER FUNCTION "public"."mark_expired_referrals_failed"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_message_delivered"("p_message_id" "uuid") RETURNS "void"
    LANGUAGE "sql" SECURITY DEFINER
    AS $$
  update public.message_receipts
  set delivered_at = coalesce(delivered_at, now())
  where message_id = p_message_id
    and user_id = auth.uid();
$$;


ALTER FUNCTION "public"."mark_message_delivered"("p_message_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_message_read"("p_message_id" "uuid") RETURNS "void"
    LANGUAGE "sql" SECURITY DEFINER
    AS $$
  update public.message_receipts
  set read_at = coalesce(read_at, now()),
      delivered_at = coalesce(delivered_at, now())
  where message_id = p_message_id
    and user_id = auth.uid();
$$;


ALTER FUNCTION "public"."mark_message_read"("p_message_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_stream_gift"("p_stream_id" "uuid", "p_user_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_now timestamptz := now();
BEGIN
  PERFORM public.ensure_stream_momentum(p_stream_id);

  UPDATE public.stream_momentum
  SET
    momentum = LEAST(100, GREATEST(0, momentum + 5)),
    last_gift_at = v_now,
    last_decay_at = v_now,
    updated_at = v_now
  WHERE stream_id = p_stream_id;
END;
$$;


ALTER FUNCTION "public"."mark_stream_gift"("p_stream_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_user_paid"("p_user_id" "uuid") RETURNS "void"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  UPDATE public.user_profiles
  SET has_paid = true
  WHERE id = p_user_id;
$$;


ALTER FUNCTION "public"."mark_user_paid"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."marketplace_items_sync_title"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  -- If title is missing, automatically copy from name
  if new.title is null or new.title = '' then
    new.title := new.name;
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."marketplace_items_sync_title"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mute_user"("target" "uuid", "minutes" integer, "reason" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_actor_role text;
  v_is_admin boolean;
  v_is_lead_officer boolean;
  v_is_troll_officer boolean;
  v_troll_role text;
BEGIN
  -- Check permissions
  SELECT role, is_admin, is_lead_officer, is_troll_officer, troll_role
  INTO v_actor_role, v_is_admin, v_is_lead_officer, v_is_troll_officer, v_troll_role
  FROM user_profiles
  WHERE id = auth.uid();

  IF NOT (v_is_admin OR v_is_lead_officer OR v_is_troll_officer OR v_actor_role = 'admin' OR v_troll_role IN ('admin', 'lead_troll_officer', 'troll_officer')) THEN
    RAISE EXCEPTION 'Not authorized';
  END IF;

  -- Update target user
  -- If minutes is 0, we treat it as unmute.
  -- If minutes is -1, we treat it as permanent.
  
  IF minutes = 0 THEN
    UPDATE user_profiles SET muted_until = NULL WHERE id = target;
  ELSE
    UPDATE user_profiles
    SET
      muted_until = CASE 
        WHEN minutes < 0 THEN '9999-12-31 23:59:59+00'::timestamptz -- Permanent
        ELSE now() + (minutes || ' minutes')::interval 
      END,
      metadata = COALESCE(metadata, '{}'::jsonb) || jsonb_build_object('mute_reason', reason),
      updated_at = now()
    WHERE id = target;
  END IF;

  -- Add to officer actions log
  BEGIN
    INSERT INTO officer_actions (
      officer_id,
      target_user_id,
      action_type,
      reason
    ) VALUES (
      auth.uid(),
      target,
      'mute',
      reason
    );
  EXCEPTION WHEN OTHERS THEN
    NULL;
  END;

END;
$$;


ALTER FUNCTION "public"."mute_user"("target" "uuid", "minutes" integer, "reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_all_users"("p_title" "text", "p_message" "text", "p_type" "text") RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_count integer := 0;
BEGIN
  INSERT INTO public.notifications (user_id, title, message, type, is_read, created_at)
  SELECT id, p_title, p_message, COALESCE(p_type, 'system_update'), FALSE, now()
  FROM public.user_profiles;
  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END
$$;


ALTER FUNCTION "public"."notify_all_users"("p_title" "text", "p_message" "text", "p_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_badge_unlocked"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_badge_name TEXT;
BEGIN
  SELECT badge_name INTO v_badge_name
  FROM badges
  WHERE id = NEW.badge_id;
  
  PERFORM create_notification(
    NEW.user_id,
    'badge_unlocked',
    'üèÜ Badge Unlocked!',
    format('You unlocked the \"%s\" badge!', COALESCE(v_badge_name, 'Unknown Badge')),
    jsonb_build_object(
      'badge_id', NEW.badge_id,
      'earned_at', NEW.earned_at
    )
  );
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_badge_unlocked"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_gift_received"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  PERFORM create_notification(
    NEW.receiver_id,
    'gift_received',
    'üéÅ Gift Received!',
    format('You received %s coins from @%s', 
      NEW.coins_spent,
      (SELECT username FROM user_profiles WHERE id = NEW.sender_id)
    ),
    jsonb_build_object(
      'gift_id', NEW.id,
      'sender_id', NEW.sender_id,
      'coins_spent', NEW.coins_spent,
      'stream_id', NEW.stream_id
    )
  );
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_gift_received"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_moderation_action"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_title TEXT;
  v_message TEXT;
BEGIN
  IF NEW.target_user_id IS NOT NULL THEN
    CASE NEW.action_type
      WHEN 'warn' THEN
        v_title := '‚ö†Ô∏è Warning Issued';
        v_message := format('You have been issued a warning: %s', NEW.reason);
      WHEN 'ban_user' THEN
        v_title := 'üö´ Account Banned';
        v_message := format('Your account has been banned. Reason: %s', NEW.reason);
      WHEN 'suspend_stream' THEN
        v_title := '‚è∏Ô∏è Stream Suspended';
        v_message := format('Your stream has been suspended. Reason: %s', NEW.reason);
      WHEN 'unban_user' THEN
        v_title := '‚úÖ Account Unbanned';
        v_message := 'Your account ban has been lifted.';
      ELSE
        RETURN NEW;
    END CASE;
    
    PERFORM create_notification(
      NEW.target_user_id,
      'moderation_action',
      v_title,
      v_message,
      jsonb_build_object(
        'action_id', NEW.id,
        'action_type', NEW.action_type,
        'reason', NEW.reason,
        'created_by', NEW.created_by,
        'expires_at', NEW.expires_at
      )
    );
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_moderation_action"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_payout_status"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_title TEXT;
  v_message TEXT;
BEGIN
  IF OLD.status IS DISTINCT FROM NEW.status THEN
    CASE NEW.status
      WHEN 'approved' THEN
        v_title := '‚úÖ Payout Approved';
        v_message := format('Your payout request of $%s has been approved and will be processed soon.', NEW.cash_amount);
      WHEN 'paid' THEN
        v_title := 'üí∞ Payout Completed';
        v_message := format('Your payout of $%s has been processed successfully.', NEW.cash_amount);
      WHEN 'rejected' THEN
        v_title := '‚ùå Payout Rejected';
        v_message := format('Your payout request of $%s was rejected. Please check your account for details.', NEW.cash_amount);
      ELSE
        RETURN NEW;
    END CASE;
    
    PERFORM create_notification(
      NEW.user_id,
      'payout_status',
      v_title,
      v_message,
      jsonb_build_object(
        'payout_id', NEW.id,
        'status', NEW.status,
        'cash_amount', NEW.cash_amount,
        'coins_redeemed', NEW.coins_redeemed
      )
    );
  END IF;
  
  RETURN NEW;
END;
$_$;


ALTER FUNCTION "public"."notify_payout_status"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_user_rpc"("p_target_user_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb", "p_is_read" boolean DEFAULT false) RETURNS TABLE("id" "uuid", "user_id" "uuid", "type" "text", "title" "text", "message" "text", "metadata" "jsonb", "is_read" boolean, "created_at" timestamp with time zone, "updated_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  inserted RECORD;
BEGIN
  IF p_target_user_id IS NULL THEN
    RAISE EXCEPTION 'Target user is required';
  END IF;

  IF trim(p_type) = '' THEN
    RAISE EXCEPTION 'Notification type is required';
  END IF;

  INSERT INTO notifications (
    user_id,
    type,
    title,
    message,
    metadata,
    is_read,
    created_at,
    updated_at
  )
  VALUES (
    p_target_user_id,
    p_type,
    p_title,
    p_message,
    p_metadata,
    p_is_read,
    now(),
    now()
  )
  RETURNING * INTO inserted;

  RETURN QUERY SELECT
    inserted.id,
    inserted.user_id,
    inserted.type,
    inserted.title,
    inserted.message,
    inserted.metadata,
    inserted.is_read,
    inserted.created_at,
    inserted.updated_at;
END;
$$;


ALTER FUNCTION "public"."notify_user_rpc"("p_target_user_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_metadata" "jsonb", "p_is_read" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."officer_cashout_after_shift"("p_shift_log_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_shift_log RECORD;
  v_officer RECORD;
  v_free_coins BIGINT;
  v_troll_coins INTEGER;
  v_usd_amount NUMERIC(10,2);
  v_exchange_rate NUMERIC := 100.0; -- 6,000 troll_coins = $60, so 100 troll_coins = $1
  v_payout_id UUID;
BEGIN
  -- Get shift log details
  SELECT * INTO v_shift_log
  FROM officer_shift_logs
  WHERE id = p_shift_log_id;

  IF v_shift_log IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Shift log not found');
  END IF;

  -- Check if shift is completed
  IF v_shift_log.shift_end IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Shift must be completed before cashing out');
  END IF;

  -- Check if already cashed out
  IF EXISTS (SELECT 1 FROM officer_payouts WHERE shift_log_id = p_shift_log_id AND status != 'rejected') THEN
    RETURN jsonb_build_object('success', false, 'error', 'This shift has already been cashed out');
  END IF;

  -- Get officer profile
  SELECT * INTO v_officer
  FROM user_profiles
  WHERE id = v_shift_log.officer_id;

  IF v_officer IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Officer profile not found');
  END IF;

  -- Check if user is an officer
  IF NOT (v_officer.is_troll_officer = true OR v_officer.role = 'troll_officer') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Only troll officers can cash out');
  END IF;

  -- Get coins earned from shift
  v_free_coins := COALESCE(v_shift_log.coins_earned, 0);

  IF v_free_coins <= 0 THEN
    RETURN jsonb_build_object('success', false, 'error', 'No coins earned from this shift');
  END IF;

  -- Check if officer has enough free coins
  IF (v_officer.troll_coins < v_free_coins) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Insufficient free coins. You may have already cashed out or spent them.');
  END IF;

  -- Calculate conversion: 6,000 troll_coins = $60
  -- So 100 troll_coins = $1
  -- Free coins to troll_coins: 1 free coin = 1 paid coin (1:1 ratio)
  -- But we need to convert to USD: 6,000 troll_coins = $60, so 100 troll_coins = $1
  v_troll_coins := v_free_coins; -- 1:1 conversion
  v_usd_amount := (v_troll_coins::NUMERIC / 100.0); -- 100 troll_coins = $1

  -- Deduct free coins and add troll_coins
  UPDATE user_profiles
  SET 
    troll_coins = troll_coins - v_free_coins,
    troll_coins = troll_coins + v_troll_coins,
    updated_at = NOW()
  WHERE id = v_officer.id;

  -- Create payout record
  INSERT INTO officer_payouts (
    officer_id,
    shift_log_id,
    free_coins_redeemed,
    troll_coins_received,
    usd_amount,
    status,
    requested_at
  ) VALUES (
    v_officer.id,
    p_shift_log_id,
    v_free_coins,
    v_troll_coins,
    v_usd_amount,
    'pending',
    NOW()
  ) RETURNING id INTO v_payout_id;

  -- Record transaction
  INSERT INTO coin_transactions (
    user_id,
    type,
    amount,
    description,
    metadata
  ) VALUES (
    v_officer.id,
    'officer_cashout',
    v_troll_coins,
    format('Officer cashout: %s free coins converted to %s troll_coins ($%s)', 
           v_free_coins, v_troll_coins, v_usd_amount),
    jsonb_build_object(
      'shift_log_id', p_shift_log_id,
      'payout_id', v_payout_id,
      'free_coins_redeemed', v_free_coins,
      'troll_coins_received', v_troll_coins,
      'usd_amount', v_usd_amount
    )
  );

  RETURN jsonb_build_object(
    'success', true,
    'message', format('Successfully cashed out %s free coins for %s troll_coins ($%s)', 
                     v_free_coins, v_troll_coins, v_usd_amount),
    'payout_id', v_payout_id,
    'free_coins_redeemed', v_free_coins,
    'troll_coins_received', v_troll_coins,
    'usd_amount', v_usd_amount
  );
END;
$_$;


ALTER FUNCTION "public"."officer_cashout_after_shift"("p_shift_log_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."officer_cashout_after_shift"("p_shift_log_id" "uuid") IS 'Allows officers to cash out free coins earned from a shift into troll_coins';



CREATE TABLE IF NOT EXISTS "public"."officer_chat_messages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "message" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."officer_chat_messages" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_chat_messages" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."officer_send_message"("p_message" "text") RETURNS "public"."officer_chat_messages"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  WITH allowed AS (
    SELECT 1
    FROM user_profiles
    WHERE id = auth.uid()
      AND role IN ('troll_officer','admin')
  )
  INSERT INTO officer_chat_messages(user_id, message)
  SELECT auth.uid(), p_message
  FROM allowed
  RETURNING officer_chat_messages.*;
$$;


ALTER FUNCTION "public"."officer_send_message"("p_message" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."officer_send_message"("p_message" "text") IS 'Insert officer chat message; only allowed for roles troll_officer/admin';



CREATE OR REPLACE FUNCTION "public"."on_giftcard_failure_alert"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF NEW.fulfillment_status = 'failed' THEN

    -- Insert critical alert
    INSERT INTO public.critical_alerts (
      alert_type, severity, title, message, related_table, related_id
    )
    VALUES (
      'giftcard_failed',
      'critical',
      'Gift Card Fulfillment Failed',
      'Gift card failed for cashout_id=' || NEW.cashout_id || '. Reason: ' || COALESCE(NEW.failure_reason,'(none)'),
      'giftcard_fulfillments',
      NEW.id
    );

    -- Also insert executive intake item for secretaries/admin
    INSERT INTO public.executive_intake (
      category, severity, status, subject, details,
      related_table, related_id, escalated_to_admin
    )
    VALUES (
      'payout',
      'critical',
      'open',
      'Gift card failed for cashout request',
      'Cashout ID: ' || NEW.cashout_id || ' | Reason: ' || COALESCE(NEW.failure_reason,'(none)'),
      'giftcard_fulfillments',
      NEW.id,
      true
    );

  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."on_giftcard_failure_alert"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."pay_ban_restoration_fee"("p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_user_balance integer;
  v_restoration_fee integer := 2000;
BEGIN
  SELECT paid_coin_balance
  INTO v_user_balance
  FROM public.user_profiles
  WHERE id = p_user_id
    AND is_banned = true
    AND account_reset_after_ban = true;

  IF v_user_balance IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Account is not eligible for restoration.'
    );
  END IF;

  IF v_user_balance < v_restoration_fee THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', format('Insufficient troll_coins. Need %s troll_coins ($20) to restore account.', v_restoration_fee)
    );
  END IF;

  UPDATE public.user_profiles
  SET
    paid_coin_balance = paid_coin_balance - v_restoration_fee,
    free_coin_balance = 0,
    xp = 0,
    level = 0,
    is_banned = false,
    banned_until = NULL,
    kick_count = 0,
    is_kicked = false,
    kicked_until = NULL,
    account_reset_after_ban = false,
    last_kicked_at = NULL
  WHERE id = p_user_id;

  RETURN jsonb_build_object(
    'success', true,
    'message', 'Account restored and reset. Fresh start!'
  );
END;
$_$;


ALTER FUNCTION "public"."pay_ban_restoration_fee"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."pay_ban_restoration_fee"("p_user_id" "uuid") IS 'Allows banned user to pay $20 (2000 coins) to restore account with reset';



CREATE OR REPLACE FUNCTION "public"."pay_for_message"("p_sender_id" "uuid", "p_recipient_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_price INTEGER;
  v_balance INTEGER;
BEGIN
  SELECT message_price INTO v_price
  FROM user_profiles
  WHERE id = p_recipient_id;

  IF v_price IS NULL OR v_price <= 0 THEN
    RETURN jsonb_build_object('success', true, 'message', 'Message is free');
  END IF;

  SELECT paid_coin_balance INTO v_balance
  FROM user_profiles
  WHERE id = p_sender_id;

  IF v_balance < v_price THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'insufficient paid coins',
      'required', v_price,
      'balance', v_balance
    );
  END IF;

  UPDATE user_profiles
  SET paid_coin_balance = paid_coin_balance - v_price
  WHERE id = p_sender_id;

  UPDATE user_profiles
  SET paid_coin_balance = paid_coin_balance + v_price
  WHERE id = p_recipient_id;

  INSERT INTO coin_transactions (
    user_id,
    type,
    coins,
    amount_usd,
    description,
    metadata
  ) VALUES (
    p_sender_id,
    'message_payment',
    -v_price,
    0,
    'Paid for direct message',
    jsonb_build_object('recipient_id', p_recipient_id, 'amount', v_price)
  ),
  (
    p_recipient_id,
    'message_income',
    v_price,
    0,
    'Message fee received',
    jsonb_build_object('sender_id', p_sender_id, 'amount', v_price)
  );

  RETURN jsonb_build_object(
    'success', true,
    'payed', v_price,
    'message', 'Message fee paid'
  );
END;
$$;


ALTER FUNCTION "public"."pay_for_message"("p_sender_id" "uuid", "p_recipient_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."pay_for_message"("p_sender_id" "uuid", "p_recipient_id" "uuid") IS 'Deducts troll_coins for sending a direct message';



CREATE OR REPLACE FUNCTION "public"."pay_for_profile_view"("p_viewer_id" "uuid", "p_profile_owner_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_view_price INTEGER;
  v_viewer_balance INTEGER;
  v_has_access BOOLEAN;
BEGIN
  -- Get profile view price
  SELECT profile_view_price INTO v_view_price
  FROM user_profiles
  WHERE id = p_profile_owner_id;

  -- If no price or price is 0, access is free
  IF v_view_price IS NULL OR v_view_price <= 0 THEN
    RETURN jsonb_build_object(
      'success', true,
      'has_access', true,
      'message', 'Profile view is free'
    );
  END IF;

  -- Check if viewer already has access (stored in profile metadata or separate table)
  -- For now, we'll use a simple check - in production you might want a separate access table
  -- This is a simplified version - you may want to track access in a separate table

  -- Get viewer's paid coin balance
  SELECT troll_coins INTO v_viewer_balance
  FROM user_profiles
  WHERE id = p_viewer_id;

  -- Check if viewer has enough coins
  IF v_viewer_balance < v_view_price THEN
    RETURN jsonb_build_object(
      'success', false,
      'has_access', false,
      'error', 'Insufficient troll_coins',
      'required', v_view_price,
      'current_balance', v_viewer_balance
    );
  END IF;

  -- Deduct coins from viewer
  UPDATE user_profiles
  SET troll_coins = troll_coins - v_view_price
  WHERE id = p_viewer_id;

  -- Add coins to profile owner
  UPDATE user_profiles
  SET troll_coins = troll_coins + v_view_price
  WHERE id = p_profile_owner_id;

  -- Record transaction
  INSERT INTO coin_transactions (
    user_id,
    type,
    coins,
    amount_usd,
    description,
    metadata
  ) VALUES (
    p_viewer_id,
    'profile_view',
    -v_view_price,
    0,
    'Paid to view profile',
    jsonb_build_object('profile_owner_id', p_profile_owner_id)
  );

  RETURN jsonb_build_object(
    'success', true,
    'has_access', true,
    'paid', v_view_price,
    'message', 'Profile access granted'
  );
END;
$$;


ALTER FUNCTION "public"."pay_for_profile_view"("p_viewer_id" "uuid", "p_profile_owner_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."pay_for_profile_view"("p_viewer_id" "uuid", "p_profile_owner_id" "uuid") IS 'Handles payment for viewing a profile with view price';



CREATE OR REPLACE FUNCTION "public"."pay_kick_reentry_fee"("p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_is_kicked boolean;
  v_user_balance integer;
  v_reentry_fee integer := 250;
  v_kick_count integer;
BEGIN
  -- Check if user is kicked
  SELECT is_kicked, kick_count, paid_coin_balance
  INTO v_is_kicked, v_kick_count, v_user_balance
  FROM public.user_profiles
  WHERE id = p_user_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'User profile not found.');
  END IF;

  IF NOT v_is_kicked THEN
    RETURN jsonb_build_object('success', false, 'error', 'User is not currently kicked.');
  END IF;

  IF v_user_balance < v_reentry_fee THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', format('Insufficient troll_coins. Need %s troll_coins to re-enter.', v_reentry_fee)
    );
  END IF;

  IF v_kick_count >= 3 THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Maximum kicks reached. Account is banned. Pay $20 to restore.'
    );
  END IF;

  -- Deduct re-entry fee and restore access
  UPDATE public.user_profiles
  SET
    paid_coin_balance = paid_coin_balance - v_reentry_fee,
    is_kicked = false,
    kicked_until = NULL
  WHERE id = p_user_id;

  -- ‚úÖ FIX: update only the latest unpaid kick_log row
  UPDATE public.kick_logs
  SET re_entry_fee_paid = v_reentry_fee
  WHERE id = (
    SELECT id
    FROM public.kick_logs
    WHERE kicked_user_id = p_user_id
      AND re_entry_fee_paid = 0
    ORDER BY created_at DESC
    LIMIT 1
  );

  RETURN jsonb_build_object(
    'success', true,
    'message', 'Re-entry fee paid. You can now access the app again.'
  );
END;
$_$;


ALTER FUNCTION "public"."pay_kick_reentry_fee"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."pay_kick_reentry_fee"("p_user_id" "uuid") IS 'Allows kicked user to pay 250 troll_coins to re-enter (max 3 times)';



CREATE OR REPLACE FUNCTION "public"."payout_trigger"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
    UPDATE payouts
    SET status = 'processed'
    WHERE id = NEW.id;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."payout_trigger"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."perform_daily_trollmond_giveaway"() RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
        DECLARE
            user_record RECORD;
            giveaway_amount INTEGER;
            total_users INTEGER;
            jackpot_user UUID;
            users_awarded INTEGER := 0;
        BEGIN
            -- Check if giveaway already ran today
            IF has_daily_giveaway_run_today() THEN
                RETURN json_build_object(
                    'success', false,
                    'error', 'Daily giveaway has already run today'
                );
            END IF;

            -- Get total number of users
            SELECT COUNT(*) INTO total_users FROM user_profiles;

            -- Select one random user for the 1000 trollmond jackpot
            SELECT id INTO jackpot_user
            FROM user_profiles
            ORDER BY random()
            LIMIT 1;

            -- Loop through all users and give them random amounts
            FOR user_record IN SELECT id FROM user_profiles LOOP
                -- Determine giveaway amount
                IF user_record.id = jackpot_user THEN
                    giveaway_amount := 1000;
                ELSE
                    giveaway_amount := 100 + floor(random() * 900)::INTEGER;
                END IF;

                -- Insert giveaway record
                INSERT INTO daily_giveaways (user_id, trollmonds_awarded)
                VALUES (user_record.id, giveaway_amount)
                ON CONFLICT (user_id, giveaway_date) DO NOTHING;

                -- Only award if the insert succeeded
                IF FOUND THEN
                    -- Add trollmonds to user's free_coin_balance
                    UPDATE user_profiles
                    SET free_coin_balance = free_coin_balance + giveaway_amount,
                        updated_at = NOW()
                    WHERE id = user_record.id;

                    -- Log the transaction
                    INSERT INTO coin_transactions (
                        user_id,
                        amount,
                        type,
                        description,
                        created_at
                    ) VALUES (
                        user_record.id,
                        giveaway_amount,
                        'daily_giveaway',
                        CASE
                            WHEN user_record.id = jackpot_user THEN 'Daily Trollmond Jackpot! 1000 trollmonds awarded!'
                            ELSE format('Daily trollmond giveaway: %s trollmonds', giveaway_amount)
                        END,
                        NOW()
                    );

                    users_awarded := users_awarded + 1;
                END IF;
            END LOOP;

            RETURN json_build_object(
                'success', true,
                'total_users', total_users,
                'users_awarded', users_awarded,
                'jackpot_winner', jackpot_user,
                'jackpot_amount', 1000,
                'message', format('Daily giveaway completed: %s users received trollmonds, jackpot winner: %s', users_awarded, jackpot_user)
            );
        END;
        $$;


ALTER FUNCTION "public"."perform_daily_trollmond_giveaway"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."place_payment_hold"("target" "uuid", "hold_type" "text", "reason" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare role text;
declare target_is_admin boolean;
begin
  role := public.get_staff_role(auth.uid());

  if role not in ('admin','lead_troll_officer','secretary') then
    insert into public.moderation_actions(actor_id, target_user_id, action_type, reason, status, error_message)
    values(auth.uid(), target, 'payment_hold', reason, 'failed', 'not authorized');
    return jsonb_build_object('status','error','message','not authorized');
  end if;

  target_is_admin := public.is_admin(target);
  if target_is_admin then
    insert into public.moderation_actions(actor_id, target_user_id, action_type, reason, status, error_message)
    values(auth.uid(), target, 'payment_hold', reason, 'failed', 'cannot hold admin');
    return jsonb_build_object('status','error','message','cannot hold admin');
  end if;

  insert into public.payment_holds (user_id, hold_type, reason, placed_by, is_active)
  values (target, hold_type, reason, auth.uid(), true);

  insert into public.moderation_actions(actor_id, target_user_id, action_type, reason, action_payload)
  values (auth.uid(), target, 'payment_hold', reason, jsonb_build_object('hold_type', hold_type));

  return jsonb_build_object('status','ok','message','payment hold placed');
end;
$$;


ALTER FUNCTION "public"."place_payment_hold"("target" "uuid", "hold_type" "text", "reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."prestige_user"("p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    v_user_profile user_profiles%ROWTYPE;
    v_new_prestige INTEGER;
BEGIN
    -- Get user profile
    SELECT * INTO v_user_profile FROM user_profiles WHERE id = p_user_id;
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'message', 'User not found');
    END IF;

    -- Check requirements (Level 50)
    IF v_user_profile.level < 50 THEN
        RETURN jsonb_build_object('success', false, 'message', 'Must be level 50 to prestige');
    END IF;

    v_new_prestige := v_user_profile.prestige_level + 1;

    -- Update User: Reset Level, XP, Increment Prestige, Boost Multipliers
    UPDATE user_profiles SET
        level = 1,
        current_xp = 0,
        prestige_level = v_new_prestige,
        xp_multiplier = xp_multiplier + 0.10, -- +10% XP per prestige
        coin_multiplier = coin_multiplier + 0.05 -- +5% Coins per prestige
    WHERE id = p_user_id;

    -- Award Prestige Badge (via Perks system if possible, or just JSON rewards)
    -- We'll assume the frontend checks prestige_level for the badge, 
    -- but we can also add a specific perk if we want.
    
    -- Log it
    INSERT INTO xp_logs (user_id, source, amount) 
    VALUES (p_user_id, 'prestige_reset', 0);

    RETURN jsonb_build_object(
        'success', true, 
        'new_prestige', v_new_prestige,
        'message', 'Prestige successful! Level reset to 1. Multipliers increased.'
    );
END;
$$;


ALTER FUNCTION "public"."prestige_user"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."prevent_hr_field_changes"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  is_hr boolean := false;
BEGIN
  -- Check if user is HR admin
  SELECT EXISTS(
    SELECT 1 FROM public.user_profiles p
    WHERE p.id = auth.uid()
      AND (p.role = 'admin' OR p.is_admin = true OR p.role = 'hr_admin')
  ) INTO is_hr;
  
  -- If not HR, prevent changes to HR fields
  IF NOT is_hr THEN
    IF NEW.application_required <> OLD.application_required OR
       NEW.application_submitted <> OLD.application_submitted OR
       NEW.is_employee <> OLD.is_employee OR
       NEW.employee_role IS DISTINCT FROM OLD.employee_role OR
       NEW.hire_date IS DISTINCT FROM OLD.hire_date THEN
      RAISE EXCEPTION 'Only HR administrators can modify HR-controlled fields';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."prevent_hr_field_changes"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."prevent_negative_paid_coins"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  p bigint;
BEGIN
  SELECT paid_coins INTO p FROM user_profiles WHERE id = NEW.user_id;
  IF p < 0 THEN
    RAISE EXCEPTION 'Paid coins cannot go negative';
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."prevent_negative_paid_coins"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."prevent_negative_troll_coins"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  coins bigint;
BEGIN
  SELECT troll_coins INTO coins
  FROM user_profiles
  WHERE id = NEW.user_id;

  IF coins < 0 THEN
    RAISE EXCEPTION 'troll_coins cannot go negative';
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."prevent_negative_troll_coins"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."prevent_over_reservation"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  available_coins bigint;
BEGIN
  SELECT (troll_coins - reserved_troll_coins)
  INTO available_coins
  FROM user_profiles
  WHERE id = NEW.user_id;

  IF available_coins < NEW.tier_coins_required THEN
    RAISE EXCEPTION 'Not enough available troll coins to reserve';
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."prevent_over_reservation"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."prevent_profile_privilege_escalation"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- prevent role changes by user
  IF NEW.role <> OLD.role THEN
    NEW.role := OLD.role;
  END IF;

  -- prevent broadcasting_disabled changes by user
  IF NEW.broadcasting_disabled <> OLD.broadcasting_disabled THEN
    NEW.broadcasting_disabled := OLD.broadcasting_disabled;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."prevent_profile_privilege_escalation"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."prevent_protected_profile_changes"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF NEW.role <> OLD.role THEN
    NEW.role := OLD.role;
  END IF;

  IF NEW.troll_coins <> OLD.troll_coins THEN
    NEW.troll_coins := OLD.troll_coins;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."prevent_protected_profile_changes"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."prevent_redemption_tier_changes"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF NEW.tier_coins_required <> OLD.tier_coins_required
     OR NEW.tier_value_usd <> OLD.tier_value_usd
     OR NEW.processing_fee_usd <> OLD.processing_fee_usd
     OR NEW.net_giftcard_value_usd <> OLD.net_giftcard_value_usd
     OR NEW.user_id <> OLD.user_id
  THEN
    RAISE EXCEPTION 'Redemption tier values cannot be changed after creation';
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."prevent_redemption_tier_changes"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."prevent_role_change"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF NEW.role <> OLD.role THEN
    NEW.role := OLD.role;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."prevent_role_change"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_admin_gift"("p_gifter_id" "uuid", "p_admin_id" "uuid", "p_troll_coins" bigint) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_current_total BIGINT;
  v_threshold BIGINT := 50000;
  v_current_title RECORD;
  v_new_title_holder UUID;
  v_gifter_gender VARCHAR(10);
  v_title_type VARCHAR(20);
BEGIN
  -- Get gifter's gender
  SELECT gender INTO v_gifter_gender
  FROM user_profiles
  WHERE id = p_gifter_id;

  IF v_gifter_gender IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Gender not set for gifter');
  END IF;

  -- Update or insert gift total
  INSERT INTO admin_gift_totals (user_id, admin_id, total_troll_coins, last_gift_at, updated_at)
  VALUES (p_gifter_id, p_admin_id, p_troll_coins, NOW(), NOW())
  ON CONFLICT (user_id, admin_id)
  DO UPDATE SET
    total_troll_coins = admin_gift_totals.total_troll_coins + p_troll_coins,
    last_gift_at = NOW(),
    updated_at = NOW()
  RETURNING total_troll_coins INTO v_current_total;

  -- Check if gifter qualifies for royal title (50k threshold)
  IF v_current_total >= v_threshold THEN
    -- Determine title type based on gender
    v_title_type := CASE WHEN v_gifter_gender = 'female' THEN 'wife' ELSE 'husband' END;

    -- Find current active title holder
    SELECT user_id INTO v_current_title
    FROM royal_family_titles
    WHERE admin_id = p_admin_id AND is_active = true
    AND title_type IN ('wife', 'husband');

    -- Find the user with the highest total now
    SELECT agt.user_id INTO v_new_title_holder
    FROM admin_gift_totals agt
    WHERE agt.admin_id = p_admin_id AND agt.total_troll_coins >= v_threshold
    ORDER BY agt.total_troll_coins DESC
    LIMIT 1;

    -- If the top gifter changed, transfer the title
    IF v_current_title IS NULL OR v_current_title.user_id != v_new_title_holder THEN
      -- Deactivate current title if exists
      IF v_current_title IS NOT NULL THEN
        UPDATE royal_family_titles
        SET is_active = false,
            unassigned_at = NOW(),
            updated_at = NOW()
        WHERE user_id = v_current_title.user_id
          AND admin_id = p_admin_id
          AND is_active = true
          AND title_type IN ('wife', 'husband');

        -- Convert to former title
        UPDATE royal_family_titles
        SET title_type = CASE WHEN title_type = 'wife' THEN 'former_wife' ELSE 'former_husband' END,
            is_active = false,
            unassigned_at = NOW(),
            updated_at = NOW()
        WHERE user_id = v_current_title.user_id
          AND admin_id = p_admin_id
          AND title_type IN ('wife', 'husband');

        -- Log dethronement
        INSERT INTO royal_family_history (
          user_id, admin_id, event_type, title_type, details
        ) VALUES (
          v_current_title.user_id, p_admin_id, 'dethroned',
          CASE WHEN (SELECT gender FROM user_profiles WHERE id = v_current_title.user_id) = 'female' THEN 'wife' ELSE 'husband' END,
          jsonb_build_object('reason', 'surpassed', 'new_holder', v_new_title_holder, 'old_total', v_current_total)
        );
      END IF;

      -- Assign new title
      INSERT INTO royal_family_titles (
        user_id, admin_id, title_type, total_coins_at_assignment
      ) VALUES (
        v_new_title_holder, p_admin_id, v_title_type, v_current_total
      );

      -- Log assignment
      INSERT INTO royal_family_history (
        user_id, admin_id, event_type, title_type, details
      ) VALUES (
        v_new_title_holder, p_admin_id, 'assigned', v_title_type,
        jsonb_build_object('total_coins', v_current_total, 'threshold', v_threshold)
      );
    END IF;
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'new_total', v_current_total,
    'qualifies', v_current_total >= v_threshold
  );
END;
$$;


ALTER FUNCTION "public"."process_admin_gift"("p_gifter_id" "uuid", "p_admin_id" "uuid", "p_troll_coins" bigint) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."process_admin_gift"("p_gifter_id" "uuid", "p_admin_id" "uuid", "p_troll_coins" bigint) IS 'Processes gifts to admin and automatically manages royal family titles';



CREATE OR REPLACE FUNCTION "public"."process_cashout_refund"("p_request_id" "uuid", "p_admin_id" "uuid", "p_notes" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_request RECORD;
  cashout_coin_col text;
  coin_amount bigint;
  sql_text text;
BEGIN

  IF auth.role() != 'service_role' THEN
    RAISE EXCEPTION 'Unauthorized';
  END IF;

  -- Detect coin column
  SELECT column_name INTO cashout_coin_col
  FROM information_schema.columns
  WHERE table_schema='public'
    AND table_name='cashout_requests'
    AND column_name IN (
      'requested_coins',
      'amount_coins',
      'coins',
      'coin_amount',
      'troll_coins',
      'requested_amount',
      'requested_troll_coins'
    )
  ORDER BY CASE column_name
    WHEN 'requested_coins' THEN 1
    WHEN 'amount_coins' THEN 2
    WHEN 'coins' THEN 3
    WHEN 'coin_amount' THEN 4
    WHEN 'troll_coins' THEN 5
    WHEN 'requested_amount' THEN 6
    WHEN 'requested_troll_coins' THEN 7
    ELSE 999
  END
  LIMIT 1;

  IF cashout_coin_col IS NULL THEN
    RAISE EXCEPTION 'No coin amount column found in cashout_requests';
  END IF;

  sql_text := format(
    'SELECT *, %I as coin_amount FROM public.cashout_requests WHERE id=$1',
    cashout_coin_col
  );

  EXECUTE sql_text INTO v_request USING p_request_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Request not found';
  END IF;

  IF v_request.status IN ('denied','fulfilled','cancelled') THEN
    RAISE EXCEPTION 'Request already processed';
  END IF;

  coin_amount := v_request.coin_amount;

  UPDATE public.user_profiles
  SET reserved_troll_coins = GREATEST(0, COALESCE(reserved_troll_coins, 0) - coin_amount)
  WHERE id = v_request.user_id;

  UPDATE public.cashout_requests
  SET
    status = 'denied',
    notes = p_notes,
    updated_at = now()
  WHERE id = p_request_id;
END;
$_$;


ALTER FUNCTION "public"."process_cashout_refund"("p_request_id" "uuid", "p_admin_id" "uuid", "p_notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_gift"("p_sender_id" "uuid", "p_streamer_id" "uuid", "p_stream_id" "uuid", "p_gift_id" "text", "p_gift_name" "text", "p_coins_spent" integer, "p_gift_type" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare evt text;
begin
  insert into gifts(stream_id, sender_id, receiver_id, coins_spent, gift_type, message)
    values (p_stream_id, p_sender_id, p_streamer_id, p_coins_spent, 'gift', p_gift_name);

  if p_gift_id in ('diamond','car') then
    evt := 'EPIC_GIFT_CHAOS';
  elsif p_gift_id in ('crown') then
    evt := 'LEGACY_EVENT';
  else
    evt := case when p_gift_type = 'paid' then 'SENT_CHAOS_GIFT' else 'HELPED_SMALL_STREAMER' end;
  end if;

  perform record_dna_event(p_sender_id, evt, jsonb_build_object('gift_id', p_gift_id, 'coins', p_coins_spent));
  perform add_xp(p_sender_id, greatest(1, p_coins_spent/50), 'gift_sent');
  return jsonb_build_object('success', true);
end;
$$;


ALTER FUNCTION "public"."process_gift"("p_sender_id" "uuid", "p_streamer_id" "uuid", "p_stream_id" "uuid", "p_gift_id" "text", "p_gift_name" "text", "p_coins_spent" integer, "p_gift_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_gift"("p_sender_id" "uuid", "p_streamer_id" "uuid", "p_stream_id" "uuid", "p_gift_id" "text", "p_gift_name" "text", "p_coins_spent" bigint, "p_gift_type" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_gift_id uuid := gen_random_uuid();
BEGIN
  IF p_gift_type = 'paid' THEN
    UPDATE user_profiles SET paid_coin_balance = paid_coin_balance - p_coins_spent, total_spent_coins = total_spent_coins + p_coins_spent, updated_at = now() WHERE id = p_sender_id;
  ELSE
    UPDATE user_profiles SET free_coin_balance = free_coin_balance - p_coins_spent, total_spent_coins = total_spent_coins + p_coins_spent, updated_at = now() WHERE id = p_sender_id;
  END IF;

  UPDATE user_profiles SET paid_coin_balance = paid_coin_balance + p_coins_spent, total_earned_coins = total_earned_coins + p_coins_spent, updated_at = now() WHERE id = p_streamer_id;

  INSERT INTO gifts(id, stream_id, sender_id, receiver_id, coins_spent, gift_type, message, created_at)
    VALUES (v_gift_id, p_stream_id, p_sender_id, p_streamer_id, p_coins_spent, p_gift_type, p_gift_name, now());

  INSERT INTO transactions(id, user_id, type, transaction_type, coins_used, description, created_at)
    VALUES (gen_random_uuid(), p_sender_id, 'gift', 'gift', p_coins_spent, p_gift_name, now());

  UPDATE streams SET total_gifts_coins = COALESCE(total_gifts_coins,0) + p_coins_spent, total_unique_gifters = COALESCE(total_unique_gifters,0) + 1, updated_at = now() WHERE id = p_stream_id;

  RETURN v_gift_id;
END;
$$;


ALTER FUNCTION "public"."process_gift"("p_sender_id" "uuid", "p_streamer_id" "uuid", "p_stream_id" "uuid", "p_gift_id" "text", "p_gift_name" "text", "p_coins_spent" bigint, "p_gift_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_gift_transaction"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_sender_xp_gain bigint;
  v_receiver_xp_gain bigint;
  v_family_xp_gain bigint;

  v_sender_prev_level int;
  v_receiver_prev_level int;
  v_family_prev_level int;

  v_sender_new_level int;
  v_receiver_new_level int;
  v_family_new_level int;

  v_millionaire_threshold int := 250000;
BEGIN
  -- XP rules:
  -- gifter xp = coins_spent / 10
  -- streamer xp = coins_spent / 12
  -- family war xp = war_points / 5
  v_sender_xp_gain := FLOOR(NEW.coins_spent / 10);
  v_receiver_xp_gain := FLOOR(NEW.coins_spent / 12);
  v_family_xp_gain := FLOOR(NEW.war_points / 5);

  -- Ensure sender row exists
  INSERT INTO public.gift_xp_stats(user_id)
  VALUES (NEW.sender_id)
  ON CONFLICT (user_id) DO NOTHING;

  -- Ensure receiver row exists
  INSERT INTO public.gift_xp_stats(user_id)
  VALUES (NEW.receiver_id)
  ON CONFLICT (user_id) DO NOTHING;

  -- Get previous levels
  SELECT gifter_level INTO v_sender_prev_level
  FROM public.gift_xp_stats WHERE user_id = NEW.sender_id;

  SELECT streamer_level INTO v_receiver_prev_level
  FROM public.gift_xp_stats WHERE user_id = NEW.receiver_id;

  -- Update sender (gifter)
  UPDATE public.gift_xp_stats
  SET gifter_xp = gifter_xp + v_sender_xp_gain,
      total_coins_spent = total_coins_spent + NEW.coins_spent,
      last_updated = now()
  WHERE user_id = NEW.sender_id;

  -- Update receiver (streamer)
  UPDATE public.gift_xp_stats
  SET streamer_xp = streamer_xp + v_receiver_xp_gain,
      total_coins_received = total_coins_received + NEW.coins_spent,
      last_updated = now()
  WHERE user_id = NEW.receiver_id;

  -- Recalculate levels after XP updates
  SELECT public.calculate_level(gifter_xp) INTO v_sender_new_level
  FROM public.gift_xp_stats WHERE user_id = NEW.sender_id;

  SELECT public.calculate_level(streamer_xp) INTO v_receiver_new_level
  FROM public.gift_xp_stats WHERE user_id = NEW.receiver_id;

  -- Update levels if changed
  IF v_sender_new_level IS DISTINCT FROM v_sender_prev_level THEN
    UPDATE public.gift_xp_stats
    SET gifter_level = v_sender_new_level
    WHERE user_id = NEW.sender_id;

    PERFORM public.award_user_badge(NEW.sender_id, 'gifter', v_sender_new_level);
  END IF;

  IF v_receiver_new_level IS DISTINCT FROM v_receiver_prev_level THEN
    UPDATE public.gift_xp_stats
    SET streamer_level = v_receiver_new_level
    WHERE user_id = NEW.receiver_id;

    PERFORM public.award_user_badge(NEW.receiver_id, 'streamer', v_receiver_new_level);
  END IF;

  -- Family war XP update (only if receiver_family_id exists)
  IF NEW.receiver_family_id IS NOT NULL THEN
    INSERT INTO public.family_war_stats(family_id)
    VALUES (NEW.receiver_family_id)
    ON CONFLICT (family_id) DO NOTHING;

    SELECT war_level INTO v_family_prev_level
    FROM public.family_war_stats
    WHERE family_id = NEW.receiver_family_id;

    UPDATE public.family_war_stats
    SET war_xp = war_xp + v_family_xp_gain,
        total_war_points = total_war_points + NEW.war_points,
        weekly_war_points = weekly_war_points + NEW.war_points,
        updated_at = now()
    WHERE family_id = NEW.receiver_family_id;

    SELECT public.calculate_level(war_xp) INTO v_family_new_level
    FROM public.family_war_stats
    WHERE family_id = NEW.receiver_family_id;

    IF v_family_new_level IS DISTINCT FROM v_family_prev_level THEN
      UPDATE public.family_war_stats
      SET war_level = v_family_new_level
      WHERE family_id = NEW.receiver_family_id;

      PERFORM public.award_family_badge(NEW.receiver_family_id, 'family_war', v_family_new_level);
    END IF;
  END IF;

  -- Millionaire Hall of Fame insert
  IF NEW.coins_spent >= v_millionaire_threshold THEN
    INSERT INTO public.millionaire_hall_of_fame(sender_id, receiver_id, gift_name, coins_spent)
    VALUES (NEW.sender_id, NEW.receiver_id, COALESCE(NEW.gift_name, 'Millionaire Gift'), NEW.coins_spent);

    -- Optional: award millionaire badge level 1 for any millionaire gift
    PERFORM public.award_user_badge(NEW.sender_id, 'millionaire', 1);
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."process_gift_transaction"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_gift_with_lucky"("p_sender_id" "uuid", "p_receiver_id" "uuid", "p_paid_coins" bigint, "p_gift_type" character varying DEFAULT 'standard'::character varying) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_sender_balance bigint;
  v_lucky_multiplier integer;
  v_trollmonds_awarded bigint := 0;
  v_event_id uuid;
  v_admin_check boolean := false;
BEGIN
  -- Input validation
  IF p_paid_coins <= 0 THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid coin amount');
  END IF;

  IF p_sender_id = p_receiver_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Cannot send gift to yourself');
  END IF;

  -- Check if receiver is admin (for royal family processing)
  SELECT EXISTS(
    SELECT 1 FROM user_profiles
    WHERE id = p_receiver_id AND role = 'admin'
  ) INTO v_admin_check;

  -- Check sender balance
  SELECT paid_coins INTO v_sender_balance
  FROM user_profiles
  WHERE id = p_sender_id;

  IF v_sender_balance IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Sender not found');
  END IF;

  IF v_sender_balance < p_paid_coins THEN
    RETURN jsonb_build_object('success', false, 'error', 'Insufficient paid coins');
  END IF;

  -- Start atomic transaction
  BEGIN
    -- Deduct paid coins from sender
    UPDATE user_profiles
    SET paid_coins = paid_coins - p_paid_coins,
        updated_at = now()
    WHERE id = p_sender_id;

    -- Process gift and update recipient's earned coins for payout system
    UPDATE user_profiles
    SET total_earned_coins = total_earned_coins + p_paid_coins,
        updated_at = now()
    WHERE id = p_receiver_id;

    -- Roll for lucky multiplier
    SELECT calculate_lucky_multiplier(p_paid_coins) INTO v_lucky_multiplier;

    -- Calculate trollmonds if lucky
    IF v_lucky_multiplier IS NOT NULL THEN
      v_trollmonds_awarded := p_paid_coins * v_lucky_multiplier;

      -- Credit trollmonds to sender
      UPDATE user_profiles
      SET trollmonds = trollmonds + v_trollmonds_awarded,
          updated_at = now()
      WHERE id = p_sender_id;
    END IF;

    -- Log the lucky event (always, even if no win)
    INSERT INTO lucky_trollmond_events (
      user_id,
      gift_id,
      spent_paid_coins,
      multiplier,
      trollmonds_awarded
    ) VALUES (
      p_sender_id,
      gen_random_uuid(), -- Generate gift ID
      p_paid_coins,
      v_lucky_multiplier,
      v_trollmonds_awarded
    ) RETURNING id INTO v_event_id;

    -- Process admin gift for royal family if receiver is admin
    IF v_admin_check THEN
      PERFORM process_admin_gift(p_sender_id, p_receiver_id, p_paid_coins);
    END IF;

    -- Commit transaction
    RETURN jsonb_build_object(
      'success', true,
      'spent_coins', p_paid_coins,
      'lucky_multiplier', v_lucky_multiplier,
      'trollmonds_awarded', v_trollmonds_awarded,
      'new_paid_balance', v_sender_balance - p_paid_coins,
      'event_id', v_event_id
    );

  EXCEPTION
    WHEN OTHERS THEN
      -- Rollback on any error
      RETURN jsonb_build_object('success', false, 'error', SQLERRM);
  END;
END;
$$;


ALTER FUNCTION "public"."process_gift_with_lucky"("p_sender_id" "uuid", "p_receiver_id" "uuid", "p_paid_coins" bigint, "p_gift_type" character varying) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."process_gift_with_lucky"("p_sender_id" "uuid", "p_receiver_id" "uuid", "p_paid_coins" bigint, "p_gift_type" character varying) IS 'Atomic gift processing with lucky mechanics';



CREATE OR REPLACE FUNCTION "public"."process_missed_court"("p_docket_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    v_user_id UUID;
BEGIN
    -- Update docket status
    UPDATE court_docket
    SET
        status = 'missed',
        missed_at = NOW(),
        updated_at = NOW()
    WHERE id = p_docket_id
    RETURNING user_id INTO v_user_id;

    -- Deduct reputation points
    UPDATE user_profiles
    SET court_reputation_score = GREATEST(0, court_reputation_score - 10)
    WHERE id = v_user_id;

    -- Create notification
    INSERT INTO notifications (
        user_id,
        type,
        title,
        message,
        metadata
    ) VALUES (
        v_user_id,
        'court_missed',
        'Court Appearance Missed',
        'You missed your scheduled court appearance. Your reputation has been reduced.',
        jsonb_build_object('docket_id', p_docket_id)
    );
END;
$$;


ALTER FUNCTION "public"."process_missed_court"("p_docket_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."process_missed_court"("p_docket_id" "uuid") IS 'Handles missed court appearances with reputation penalties';



CREATE OR REPLACE FUNCTION "public"."process_payout"("p_payout_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
    UPDATE payouts
    SET status = 'processed'
    WHERE id = p_payout_id;
END;
$$;


ALTER FUNCTION "public"."process_payout"("p_payout_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_payout_request"("p_request_id" "uuid", "p_requested_coins" bigint) RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_auto_approve_threshold BIGINT := 25000;
BEGIN
  IF p_requested_coins <= v_auto_approve_threshold THEN
    UPDATE payout_requests
    SET status = 'approved'
    WHERE id = p_request_id;
  ELSE
    UPDATE payout_requests
    SET status = 'pending'
    WHERE id = p_request_id;
  END IF;
END;
$$;


ALTER FUNCTION "public"."process_payout_request"("p_request_id" "uuid", "p_requested_coins" bigint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_referral_rewards"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare
  coin_delta bigint;
begin
  -- Ensure not null
  if NEW.troll_coins is null then
    NEW.troll_coins := 0;
  end if;

  if OLD.troll_coins is null then
    OLD.troll_coins := 0;
  end if;

  -- Only run if paid balance increased
  if NEW.troll_coins > OLD.troll_coins then
    coin_delta := NEW.troll_coins - OLD.troll_coins;

    -- ‚úÖ PLACEHOLDER: your referral payout logic goes here
    -- Example:
    -- perform credit_referrer(NEW.user_id, coin_delta);

  end if;

  return NEW;
end;
$$;


ALTER FUNCTION "public"."process_referral_rewards"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_trolltract_weekly_payout"("p_week_start" timestamp with time zone, "p_week_end" timestamp with time zone, "p_threshold" bigint DEFAULT 40000, "p_reward" bigint DEFAULT 2000) RETURNS TABLE("contract_id" "uuid", "member_id" "uuid", "owner_id" "uuid", "member_earned" bigint, "reward_paid" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  r RECORD;
  v_member_earned bigint;
  v_exists boolean;
BEGIN
  FOR r IN
    SELECT c.id AS contract_id, c.member_id, c.contract_owner_id
    FROM public.trolltract_contracts c
    WHERE c.active = true
  LOOP
    SELECT COALESCE(SUM(ct.amount), 0) INTO v_member_earned
    FROM public.coin_transactions ct
    WHERE ct.user_id = r.member_id
      AND ct.coin_type = 'paid'
      AND ct.type IN ('gift_receive','gift_received')
      AND ct.created_at >= p_week_start
      AND ct.created_at <= p_week_end;

    SELECT EXISTS (
      SELECT 1 FROM public.trolltract_weekly_rewards twr
      WHERE twr.contract_id = r.contract_id
        AND twr.week_start = p_week_start
    ) INTO v_exists;

    IF v_member_earned >= p_threshold AND NOT v_exists THEN
      INSERT INTO public.trolltract_weekly_rewards (
        contract_id, week_start, week_end, threshold_coins, reward_coins, member_earned_coins, paid, paid_at
      ) VALUES (
        r.contract_id, p_week_start, p_week_end, p_threshold, p_reward, v_member_earned, true, now()
      );

      UPDATE public.user_profiles
      SET paid_coin_balance = COALESCE(paid_coin_balance, 0) + p_reward,
          updated_at = now()
      WHERE id = r.contract_owner_id;

      BEGIN
        INSERT INTO public.coin_transactions (
          user_id, type, amount, coin_type, description, metadata, created_at
        ) VALUES (
          r.contract_owner_id,
          'admin_grant',
          p_reward,
          'paid',
          'TrollTract weekly goal reward',
          jsonb_build_object('contract_id', r.contract_id, 'week_start', p_week_start, 'member_id', r.member_id, 'member_earned', v_member_earned),
          now()
        );
      EXCEPTION WHEN OTHERS THEN
        NULL;
      END;

      contract_id := r.contract_id;
      member_id := r.member_id;
      owner_id := r.contract_owner_id;
      member_earned := v_member_earned;
      reward_paid := true;
      RETURN NEXT;
    ELSE
      contract_id := r.contract_id;
      member_id := r.member_id;
      owner_id := r.contract_owner_id;
      member_earned := v_member_earned;
      reward_paid := false;
      RETURN NEXT;
    END IF;
  END LOOP;
END;
$$;


ALTER FUNCTION "public"."process_trolltract_weekly_payout"("p_week_start" timestamp with time zone, "p_week_end" timestamp with time zone, "p_threshold" bigint, "p_reward" bigint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."promote_to_lead"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  update user_profiles
  set officer_role = 'lead_officer'
  where id = p_user_id;

  insert into officer_actions (officer_id, action_type, acted_by, reason)
  values (p_user_id, 'promoted_to_lead', p_acted_by, p_reason);
end;
$$;


ALTER FUNCTION "public"."promote_to_lead"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."purchase_broadcast_theme"("p_theme_id" "uuid", "p_set_active" boolean DEFAULT true) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_user_id uuid := auth.uid();
  v_price integer := 0;
  v_slug text;
  v_balance integer := 0;
begin
  if v_user_id is null then
    return jsonb_build_object('success', false, 'error', 'Not authenticated');
  end if;

  select price_coins, slug
    into v_price, v_slug
  from public.broadcast_background_themes
  where id = p_theme_id and is_active = true
  limit 1;

  if v_slug is null then
    return jsonb_build_object('success', false, 'error', 'Theme not found');
  end if;

  -- Already owned? Return success (no double charge)
  if exists (
    select 1
    from public.user_broadcast_theme_purchases
    where user_id = v_user_id and theme_id = p_theme_id
  ) then
    if p_set_active then
      insert into public.user_broadcast_theme_state (user_id, active_theme_id, updated_at)
      values (v_user_id, p_theme_id, now())
      on conflict (user_id)
      do update set active_theme_id = excluded.active_theme_id, updated_at = now();
    end if;

    return jsonb_build_object(
      'success', true,
      'already_owned', true,
      'theme_id', p_theme_id,
      'theme_slug', v_slug,
      'price', v_price
    );
  end if;

  -- Lock profile row for atomic spend
  select troll_coins
    into v_balance
  from public.user_profiles
  where id = v_user_id
  for update;

  if v_balance is null then
    return jsonb_build_object('success', false, 'error', 'User not found');
  end if;

  if v_balance < v_price then
    return jsonb_build_object('success', false, 'error', 'Not enough coins');
  end if;

  update public.user_profiles
  set troll_coins = troll_coins - v_price,
      total_spent_coins = coalesce(total_spent_coins, 0) + v_price,
      updated_at = now()
  where id = v_user_id;

  insert into public.user_broadcast_theme_purchases (user_id, theme_id)
  values (v_user_id, p_theme_id)
  on conflict do nothing;

  if p_set_active then
    insert into public.user_broadcast_theme_state (user_id, active_theme_id, updated_at)
    values (v_user_id, p_theme_id, now())
    on conflict (user_id)
    do update set active_theme_id = excluded.active_theme_id, updated_at = now();
  end if;

  -- Log coin transaction (if schema supports)
  begin
    if exists (
      select 1 from information_schema.columns
      where table_schema='public' and table_name='coin_transactions' and column_name='amount'
    ) then
      execute
        'insert into public.coin_transactions (user_id, type, amount, description, metadata, created_at)
         values ($1, $2, $3, $4, $5, now())'
      using v_user_id, 'broadcast_theme_purchase', v_price,
            format('Broadcast theme purchase: %s', v_slug),
            jsonb_build_object('theme_slug', v_slug, 'theme_id', p_theme_id);
    elsif exists (
      select 1 from information_schema.columns
      where table_schema='public' and table_name='coin_transactions' and column_name='coins'
    ) then
      execute
        'insert into public.coin_transactions (user_id, type, coins, description, metadata, created_at)
         values ($1, $2, $3, $4, $5, now())'
      using v_user_id, 'broadcast_theme_purchase', v_price,
            format('Broadcast theme purchase: %s', v_slug),
            jsonb_build_object('theme_slug', v_slug, 'theme_id', p_theme_id);
    end if;
  exception when others then
    null;
  end;

  return jsonb_build_object(
    'success', true,
    'theme_id', p_theme_id,
    'theme_slug', v_slug,
    'price', v_price
  );
end;
$_$;


ALTER FUNCTION "public"."purchase_broadcast_theme"("p_theme_id" "uuid", "p_set_active" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."purchase_broadcast_theme"("p_set_active" boolean, "p_theme_id" "uuid", "p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  -- Ignore p_user_id for safety; auth.uid() is used in the secure function.
  return public.purchase_broadcast_theme(p_theme_id, p_set_active);
end;
$$;


ALTER FUNCTION "public"."purchase_broadcast_theme"("p_set_active" boolean, "p_theme_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."purchase_call_sound"("p_sound_id" "uuid", "p_set_active" boolean DEFAULT false) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_user_id uuid := auth.uid();
  v_price integer := 0;
  v_slug text;
  v_type text;
  v_balance integer := 0;
begin
  if v_user_id is null then
    return jsonb_build_object('success', false, 'error', 'not_authenticated');
  end if;

  select price_coins, slug, sound_type
    into v_price, v_slug, v_type
  from public.call_sound_catalog
  where id = p_sound_id and is_active = true
  limit 1;

  if v_slug is null then
    return jsonb_build_object('success', false, 'error', 'sound_not_found');
  end if;

  -- already owned: optionally set active and return
  if exists (
    select 1 from public.user_call_sounds
    where user_id = v_user_id and sound_id = p_sound_id
  ) then
    if p_set_active then
      -- deactivate other sounds of same type
      update public.user_call_sounds u
      set is_active = false
      where u.user_id = v_user_id
        and u.sound_id in (
          select id from public.call_sound_catalog where sound_type = v_type
        );

      update public.user_call_sounds
      set is_active = true
      where user_id = v_user_id and sound_id = p_sound_id;
    end if;

    return jsonb_build_object(
      'success', true,
      'already_owned', true,
      'sound_id', p_sound_id,
      'sound_slug', v_slug,
      'price', v_price
    );
  end if;

  select troll_coins
    into v_balance
  from public.user_profiles
  where id = v_user_id
  for update;

  if v_balance is null then
    return jsonb_build_object('success', false, 'error', 'user_not_found');
  end if;

  if v_balance < v_price then
    return jsonb_build_object('success', false, 'error', 'not_enough_coins');
  end if;

  update public.user_profiles
  set troll_coins = troll_coins - v_price,
      total_spent_coins = coalesce(total_spent_coins, 0) + v_price,
      updated_at = now()
  where id = v_user_id;

  insert into public.user_call_sounds (user_id, sound_id, is_active)
  values (v_user_id, p_sound_id, false)
  on conflict do nothing;

  if p_set_active then
    update public.user_call_sounds u
    set is_active = false
    where u.user_id = v_user_id
      and u.sound_id in (
        select id from public.call_sound_catalog where sound_type = v_type
      );

    update public.user_call_sounds
    set is_active = true
    where user_id = v_user_id and sound_id = p_sound_id;
  end if;

  -- Log coin transaction if schema supports it
  begin
    if exists (
      select 1 from information_schema.columns
      where table_schema='public' and table_name='coin_transactions' and column_name='amount'
    ) then
      execute
        'insert into public.coin_transactions (user_id, type, amount, description, metadata, created_at)
         values ($1, $2, $3, $4, $5, now())'
      using v_user_id, 'call_sound_purchase', v_price,
            format('Call sound purchase: %s', v_slug),
            jsonb_build_object('sound_slug',v_slug,'sound_id',p_sound_id,'sound_type',v_type);
    elsif exists (
      select 1 from information_schema.columns
      where table_schema='public' and table_name='coin_transactions' and column_name='coins'
    ) then
      execute
        'insert into public.coin_transactions (user_id, type, coins, description, metadata, created_at)
         values ($1, $2, $3, $4, $5, now())'
      using v_user_id, 'call_sound_purchase', v_price,
            format('Call sound purchase: %s', v_slug),
            jsonb_build_object('sound_slug',v_slug,'sound_id',p_sound_id,'sound_type',v_type);
    end if;
  exception when others then
    null;
  end;

  return jsonb_build_object(
    'success', true,
    'sound_id', p_sound_id,
    'sound_slug', v_slug,
    'price', v_price
  );
end;
$_$;


ALTER FUNCTION "public"."purchase_call_sound"("p_sound_id" "uuid", "p_set_active" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."purchase_coins"("p_user_id" "uuid", "p_package_id" "text", "p_coins" bigint, "p_amount" numeric, "p_square_tx_id" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  update user_profiles
    set troll_coins = troll_coins + p_coins,
        updated_at = now()
    where id = p_user_id;

  insert into coin_transactions(user_id, type, package_id, coins, amount_usd, payment_method, status, description, metadata)
    values (p_user_id, 'purchase', p_package_id, p_coins, p_amount, 'square', 'completed', 'Coin package purchase', jsonb_build_object('square_transaction_id', p_square_tx_id));

  insert into payment_transactions(user_id, coins_purchased, amount_paid, square_transaction_id)
    values (p_user_id, p_coins, p_amount, p_square_tx_id);

  return jsonb_build_object('success', true);
end;
$$;


ALTER FUNCTION "public"."purchase_coins"("p_user_id" "uuid", "p_package_id" "text", "p_coins" bigint, "p_amount" numeric, "p_square_tx_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."purchase_entrance_effect"("p_user_id" "uuid", "p_effect_id" "text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
begin
  if not exists (
    select 1 from entrance_effect_catalog
    where id = p_effect_id and is_enabled = true
  ) then
    raise exception 'Entrance effect not found or disabled';
  end if;

  insert into user_entrance_effects (user_id, effect_id)
  values (p_user_id, p_effect_id)
  on conflict (user_id, effect_id) do nothing;
end;
$$;


ALTER FUNCTION "public"."purchase_entrance_effect"("p_user_id" "uuid", "p_effect_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."purchase_inventory_item"("p_user_id" "uuid", "p_item_id" "uuid", "p_quantity" integer DEFAULT 1) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_item_price bigint;
  v_item_status text;
  v_total_cost bigint;
  v_balance bigint;
  v_inventory_id uuid;
BEGIN
  -- Get item details from inventory_items
  SELECT coin_price, status INTO v_item_price, v_item_status
  FROM inventory_items
  WHERE id = p_item_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Item not found');
  END IF;

  IF v_item_status != 'active' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Item not available for purchase');
  END IF;

  v_total_cost := v_item_price * p_quantity;

  -- Check Trollmonds balance (free_coin_balance is Trollmonds)
  SELECT free_coin_balance INTO v_balance
  FROM user_profiles
  WHERE id = p_user_id;

  IF v_balance < v_total_cost THEN
    RETURN jsonb_build_object('success', false, 'error', 'Insufficient Trollmonds');
  END IF;

  -- Deduct only Trollmonds (free_coin_balance)
  UPDATE user_profiles
  SET free_coin_balance = free_coin_balance - v_total_cost,
      updated_at = now()
  WHERE id = p_user_id;

  -- Add to inventory
  INSERT INTO user_inventory (user_id, item_id, quantity)
  VALUES (p_user_id, p_item_id, p_quantity)
  ON CONFLICT (user_id, item_id)
  DO UPDATE SET quantity = user_inventory.quantity + p_quantity, updated_at = now()
  RETURNING id INTO v_inventory_id;

  -- Log transaction
  INSERT INTO coin_transactions (
    user_id,
    type,
    coins,
    coin_type,
    description,
    metadata
  ) VALUES (
    p_user_id,
    'store_purchase',
    -v_total_cost,
    'free',
    'Purchased item from Trollmonds Store',
    jsonb_build_object('item_id', p_item_id, 'quantity', p_quantity)
  );

  RETURN jsonb_build_object('success', true, 'inventory_id', v_inventory_id, 'new_balance', v_balance - v_total_cost);
END;
$$;


ALTER FUNCTION "public"."purchase_inventory_item"("p_user_id" "uuid", "p_item_id" "uuid", "p_quantity" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."purchase_perk"("p_perk_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    v_user_id UUID := auth.uid();
    v_perk perks%ROWTYPE;
    v_user_tokens INTEGER;
    v_user_level INTEGER;
    v_expires_at TIMESTAMPTZ;
    v_metadata JSONB;
BEGIN
    -- Get Perk Details
    SELECT * INTO v_perk FROM perks WHERE id = p_perk_id;
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'error', 'Perk not found');
    END IF;

    -- Get User Details
    SELECT perk_tokens, level INTO v_user_tokens, v_user_level 
    FROM user_profiles WHERE id = v_user_id;

    -- Checks
    IF v_user_level < v_perk.required_level THEN
        RETURN jsonb_build_object('success', false, 'error', 'Level requirement not met');
    END IF;

    IF v_user_tokens < v_perk.cost_tokens THEN
        RETURN jsonb_build_object('success', false, 'error', 'Insufficient tokens');
    END IF;

    -- Determine Expiration (from metadata)
    v_metadata := v_perk.metadata;
    IF v_metadata ? 'duration_hours' THEN
        v_expires_at := NOW() + (v_metadata->>'duration_hours')::INTEGER * INTERVAL '1 hour';
    ELSE
        v_expires_at := NULL; -- Permanent
    END IF;

    -- Deduct Tokens
    UPDATE user_profiles 
    SET perk_tokens = perk_tokens - v_perk.cost_tokens 
    WHERE id = v_user_id;

    -- Grant Perk
    INSERT INTO user_perks (user_id, perk_id, expires_at)
    VALUES (v_user_id, p_perk_id, v_expires_at);

    RETURN jsonb_build_object(
        'success', true, 
        'message', 'Perk purchased successfully!',
        'remaining_tokens', v_user_tokens - v_perk.cost_tokens
    );
END;
$$;


ALTER FUNCTION "public"."purchase_perk"("p_perk_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."purchase_trolltract"() RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare
  v_wallet_record public.wallets;
begin
  -- Already contracted?
  if exists (
    select 1 from public.profiles
    where id = auth.uid()
      and is_contracted = true
  ) then
    return 'already_contracted';
  end if;

  -- Lock wallet row & check balance
  select *
  into v_wallet_record
  from public.wallets
  where user_id = auth.uid()
  for update;

  if not found then
    raise exception 'Wallet not found. Please contact support.';
  end if;

  if v_wallet_record.paid_coins < 20000 then
    return 'insufficient_funds';
  end if;

  -- Deduct 20,000 paid coins (assumes your deduct_coins throws on error)
  perform public.deduct_coins(auth.uid(), 20000, 'paid');

  -- Activate contract on profile
  update public.profiles
  set is_contracted = true,
      contract_signed_at = now(),
      contract_level = 1
  where id = auth.uid();

  -- Log contract
  insert into public.trolltract_contracts (
    user_id,
    coins_spent,
    earnings_multiplier,
    goal_monthly_coins
  ) values (
    auth.uid(),
    20000,
    1.10,      -- 10% earnings boost for contracted creators
    50000      -- example monthly goal (you can adjust in UI or admin)
  );

  return 'success';
end;
$$;


ALTER FUNCTION "public"."purchase_trolltract"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_agreement_acceptance"("p_user_id" "uuid", "p_agreement_version" "text" DEFAULT '1.0'::"text", "p_ip_address" "text" DEFAULT NULL::"text", "p_user_agent" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_agreement_id uuid := gen_random_uuid();
  v_username text;
  v_email text;
BEGIN
  -- Get username and email from user_profiles
  SELECT username, email INTO v_username, v_email
  FROM public.user_profiles
  WHERE id = p_user_id;

  IF v_username IS NULL THEN
    RAISE EXCEPTION 'User not found or username is null';
  END IF;

  INSERT INTO public.user_agreements (
    id,
    user_id,
    username,
    email,
    agreement_version,
    accepted_at,
    ip_address,
    user_agent,
    terms_accepted,
    created_at
  )
  VALUES (
    v_agreement_id,
    p_user_id,
    v_username,
    v_email,
    COALESCE(p_agreement_version, '1.0'),
    now(),
    p_ip_address,
    p_user_agent,
    true,
    now()
  );

  UPDATE public.user_profiles
  SET terms_accepted = true,
      court_recording_consent = true,
      updated_at = now()
  WHERE id = p_user_id;

  RETURN v_agreement_id;
END;
$$;


ALTER FUNCTION "public"."record_agreement_acceptance"("p_user_id" "uuid", "p_agreement_version" "text", "p_ip_address" "text", "p_user_agent" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_dna_event"("p_user_id" "uuid", "p_event_type" "text", "p_event_data" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  INSERT INTO troll_dna_events (
    user_id,
    event_type,
    event_data
  ) VALUES (
    p_user_id,
    p_event_type,
    p_event_data
  );

  RETURN jsonb_build_object(
    'success', TRUE,
    'message', 'DNA event recorded'
  );
END;
$$;


ALTER FUNCTION "public"."record_dna_event"("p_user_id" "uuid", "p_event_type" "text", "p_event_data" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_home_feature_spend"("p_coins_spent" bigint) RETURNS "void"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  SELECT public.record_home_feature_spend(auth.uid(), p_coins_spent);
$$;


ALTER FUNCTION "public"."record_home_feature_spend"("p_coins_spent" bigint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_home_feature_spend"("p_user_id" "uuid", "p_coins_spent" bigint) RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  cycle_id UUID;
BEGIN
  -- Get active cycle
  cycle_id := get_or_create_active_cycle();

  -- Insert spend record
  INSERT INTO home_feature_spend (cycle_id, user_id, coins_spent)
  VALUES (cycle_id, p_user_id, p_coins_spent);

  -- Increment total
  UPDATE home_feature_cycles
  SET total_spent_coins = total_spent_coins + p_coins_spent
  WHERE id = cycle_id;
END;
$$;


ALTER FUNCTION "public"."record_home_feature_spend"("p_user_id" "uuid", "p_coins_spent" bigint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_post_view"("p_post_id" "uuid", "p_user_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  -- no self-views counting as ‚Äúviews‚Äù if you want:
  if p_user_id is not null then
    if exists (
      select 1 from troll_posts
      where id = p_post_id and user_id = p_user_id
    ) then
      return;
    end if;
  end if;

  -- only one view per user per post per 24 hours
  if p_user_id is not null then
    if exists (
      select 1
      from troll_post_views
      where post_id = p_post_id
        and user_id = p_user_id
        and created_at > now() - interval '24 hours'
    ) then
      return;
    end if;
  end if;

  insert into troll_post_views (post_id, user_id)
  values (p_post_id, p_user_id);
end;
$$;


ALTER FUNCTION "public"."record_post_view"("p_post_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_promo_code_use"("p_promo_code_id" "uuid", "p_user_id" "uuid", "p_discount_applied" numeric, "p_original_price" numeric, "p_final_price" numeric, "p_transaction_id" "uuid" DEFAULT NULL::"uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_use_id UUID;
BEGIN
  -- Insert usage record
  INSERT INTO promo_code_uses (
    promo_code_id,
    user_id,
    transaction_id,
    discount_applied,
    original_price,
    final_price
  ) VALUES (
    p_promo_code_id,
    p_user_id,
    p_transaction_id,
    p_discount_applied,
    p_original_price,
    p_final_price
  )
  RETURNING id INTO v_use_id;

  -- Increment usage count
  UPDATE promo_codes
  SET current_uses = current_uses + 1,
      updated_at = NOW()
  WHERE id = p_promo_code_id;

  RETURN v_use_id;
END;
$$;


ALTER FUNCTION "public"."record_promo_code_use"("p_promo_code_id" "uuid", "p_user_id" "uuid", "p_discount_applied" numeric, "p_original_price" numeric, "p_final_price" numeric, "p_transaction_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_tromody_gift"("p_session" "uuid", "p_from_user" "uuid", "p_side" "text", "p_coin_amount" bigint, "p_usd_amount" numeric, "p_coin_type" "text") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  insert into public.tromody_gifts (
    session_id,
    from_user_id,
    side,
    coin_amount,
    usd_amount,
    coin_type
  )
  values (
    p_session,
    p_from_user,
    p_side,
    p_coin_amount,
    p_usd_amount,
    p_coin_type
  );

  if p_side = 'left' then
    if p_coin_type = 'paid' then
      update public.tromody_sessions
      set left_gifts_paid = left_gifts_paid + p_coin_amount
      where id = p_session;
    else
      update public.tromody_sessions
      set left_gifts_free = left_gifts_free + p_coin_amount
      where id = p_session;
    end if;
  else
    if p_coin_type = 'paid' then
      update public.tromody_sessions
      set right_gifts_paid = right_gifts_paid + p_coin_amount
      where id = p_session;
    else
      update public.tromody_sessions
      set right_gifts_free = right_gifts_free + p_coin_amount
      where id = p_session;
    end if;
  end if;
end;
$$;


ALTER FUNCTION "public"."record_tromody_gift"("p_session" "uuid", "p_from_user" "uuid", "p_side" "text", "p_coin_amount" bigint, "p_usd_amount" numeric, "p_coin_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."refresh_probation_status"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  UPDATE public.profiles
  SET officer_status = 'active'
  WHERE officer_status = 'probation'
    AND probation_ends_at IS NOT NULL
    AND probation_ends_at <= now();
END;
$$;


ALTER FUNCTION "public"."refresh_probation_status"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."refund_payout_coins"("refund_user_id" "uuid", "refund_amount" bigint) RETURNS "void"
    LANGUAGE "sql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
  update public.wallets
  set paid_coins = paid_coins + refund_amount,
      updated_at = now()
  where user_id = refund_user_id;
$$;


ALTER FUNCTION "public"."refund_payout_coins"("refund_user_id" "uuid", "refund_amount" bigint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."register_session"("p_user_id" "uuid", "p_session_id" "uuid", "p_device_info" "jsonb" DEFAULT '{}'::"jsonb", "p_ip_address" "text" DEFAULT NULL::"text", "p_user_agent" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    -- Deactivate any existing sessions for this user (single device policy)
    UPDATE active_sessions
    SET is_active = FALSE, last_active = NOW()
    WHERE user_id = p_user_id AND is_active = TRUE;
    
    -- Insert new session
    INSERT INTO active_sessions (user_id, session_id, device_info, ip_address, user_agent)
    VALUES (p_user_id, p_session_id, p_device_info, p_ip_address, p_user_agent)
    ON CONFLICT (session_id) DO UPDATE
    SET is_active = TRUE, last_active = NOW(), device_info = p_device_info, 
        ip_address = p_ip_address, user_agent = p_user_agent;
END;
$$;


ALTER FUNCTION "public"."register_session"("p_user_id" "uuid", "p_session_id" "uuid", "p_device_info" "jsonb", "p_ip_address" "text", "p_user_agent" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."register_session"("p_user_id" "uuid", "p_session_id" "uuid", "p_device_info" "jsonb", "p_ip_address" "text", "p_user_agent" "text") IS 'Register a new user session and deactivate previous ones';



CREATE OR REPLACE FUNCTION "public"."reject_empire_partner"("p_application_id" "uuid", "p_reviewer_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  UPDATE empire_applications
  SET 
    status = 'rejected',
    reviewed_by = p_reviewer_id,
    reviewed_at = NOW()
  WHERE id = p_application_id
    AND status = 'pending';
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Application not found or already processed';
  END IF;
END;
$$;


ALTER FUNCTION "public"."reject_empire_partner"("p_application_id" "uuid", "p_reviewer_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."reject_empire_partner"("p_application_id" "uuid", "p_reviewer_id" "uuid") IS 'Rejects an Empire Partner application';



CREATE OR REPLACE FUNCTION "public"."reject_payout"("p_payout_id" "uuid", "p_reason" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_payout payout_requests%ROWTYPE;
  v_actor record;
  v_has_rejection_reason boolean;
  v_has_notes boolean;
  v_coins bigint;
  v_should_refund boolean;
BEGIN
  SELECT role, is_admin, officer_role, is_lead_officer
  INTO v_actor
  FROM user_profiles
  WHERE id = auth.uid();

  IF v_actor IS NULL THEN
    RAISE EXCEPTION 'Authentication required';
  END IF;

  IF NOT (v_actor.role = 'admin' OR v_actor.is_admin = true OR v_actor.officer_role = 'lead_officer' OR v_actor.is_lead_officer = true) THEN
    RAISE EXCEPTION 'Only admins or lead officers can reject payouts';
  END IF;

  SELECT *
  INTO v_payout
  FROM payout_requests
  WHERE id = p_payout_id;

  IF v_payout IS NULL THEN
    RAISE EXCEPTION 'Payout request not found';
  END IF;

  -- Idempotent behavior
  IF v_payout.status = 'rejected' THEN
    RETURN;
  END IF;
  IF v_payout.status = 'paid' THEN
    RAISE EXCEPTION 'Cannot reject a paid payout';
  END IF;
  IF v_payout.status != 'pending' AND v_payout.status != 'approved' AND v_payout.status != 'processing' THEN
    RAISE EXCEPTION 'Payout is already %', v_payout.status;
  END IF;

  v_coins := COALESCE(v_payout.coins_redeemed, v_payout.requested_coins, v_payout.coin_amount, 0);
  v_should_refund := COALESCE(v_payout.coins_reserved, false) IS TRUE AND v_coins > 0;

  v_has_rejection_reason := EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'payout_requests'
      AND column_name = 'rejection_reason'
  );

  v_has_notes := EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'payout_requests'
      AND column_name = 'notes'
  );

  IF v_has_rejection_reason THEN
    UPDATE payout_requests
    SET
      status = 'rejected',
      rejection_reason = p_reason,
      processed_by = auth.uid(),
      processed_at = now()
    WHERE id = p_payout_id;
  ELSIF v_has_notes THEN
    UPDATE payout_requests
    SET
      status = 'rejected',
      notes = COALESCE(p_reason, notes),
      processed_by = auth.uid(),
      processed_at = now()
    WHERE id = p_payout_id;
  ELSE
    UPDATE payout_requests
    SET
      status = 'rejected',
      processed_by = auth.uid(),
      processed_at = now()
    WHERE id = p_payout_id;
  END IF;

  -- Refund reserved coins (only when reserved at request time)
  IF v_should_refund THEN
    UPDATE public.user_profiles
    SET
      paid_coin_balance = paid_coin_balance + v_coins,
      updated_at = now()
    WHERE id = v_payout.user_id;

    BEGIN
      INSERT INTO public.coin_transactions (
        user_id,
        type,
        amount,
        description,
        metadata
      ) VALUES (
        v_payout.user_id,
        'payout_refund',
        v_coins,
        format('Payout request rejected: %s coins refunded', v_coins),
        jsonb_build_object('payout_request_id', p_payout_id, 'rejection_reason', p_reason)
      );
    EXCEPTION
      WHEN undefined_table THEN NULL;
      WHEN insufficient_privilege THEN NULL;
    END;

    UPDATE public.payout_requests
    SET coins_reserved = false
    WHERE id = p_payout_id;
  END IF;
END;
$$;


ALTER FUNCTION "public"."reject_payout"("p_payout_id" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reject_visa_redemption"("p_redemption_id" "uuid", "p_reason" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_admin_id uuid := auth.uid();
  v_role text;
  v_row public.visa_redemptions;
  v_available_before bigint;
  v_reserved_before bigint;
BEGIN
  IF v_admin_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT role INTO v_role FROM public.user_profiles WHERE id = v_admin_id;
  IF v_role NOT IN ('admin','secretary') THEN
    RAISE EXCEPTION 'Not authorized';
  END IF;

  SELECT * INTO v_row FROM public.visa_redemptions WHERE id = p_redemption_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Redemption not found';
  END IF;

  IF v_row.status IN ('fulfilled','rejected') THEN
    RAISE EXCEPTION 'Redemption already processed';
  END IF;

  SELECT COALESCE(troll_coins,0) - COALESCE(reserved_troll_coins,0),
         COALESCE(reserved_troll_coins,0)
    INTO v_available_before, v_reserved_before
  FROM public.user_profiles
  WHERE id = v_row.user_id;

  UPDATE public.user_profiles
  SET reserved_troll_coins = GREATEST(0, COALESCE(reserved_troll_coins,0) - v_row.coins_reserved),
      updated_at = now()
  WHERE id = v_row.user_id;

  UPDATE public.visa_redemptions
  SET status = 'rejected',
      rejected_at = now(),
      rejected_by = v_admin_id,
      notes = COALESCE(notes, p_reason),
      updated_at = now()
  WHERE id = p_redemption_id;

  BEGIN
    PERFORM create_notification(
      v_row.user_id,
      'gift_card',
      'Visa Redemption Rejected',
      COALESCE(p_reason, 'Your redemption was rejected. Coins were returned to your wallet.'),
      jsonb_build_object(
        'usd_amount', v_row.usd_amount,
        'redemption_id', p_redemption_id,
        'rejected_at', now()
      )
    );
  EXCEPTION WHEN OTHERS THEN
    INSERT INTO notifications (user_id, type, title, message, metadata, created_at)
    VALUES (
      v_row.user_id,
      'gift_card',
      'Visa Redemption Rejected',
      COALESCE(p_reason, 'Your redemption was rejected. Coins were returned to your wallet.'),
      jsonb_build_object(
        'usd_amount', v_row.usd_amount,
        'redemption_id', p_redemption_id,
        'rejected_at', now()
      ),
      now()
    );
  END;

  RETURN jsonb_build_object(
    'success', true,
    'RedemptionStatus', 'rejected',
    'WalletBefore', jsonb_build_object(
      'available', v_available_before,
      'reserved', v_reserved_before
    ),
    'WalletAfter', jsonb_build_object(
      'available', v_available_before + v_row.coins_reserved,
      'reserved', GREATEST(0, v_reserved_before - v_row.coins_reserved)
    )
  );
END;
$$;


ALTER FUNCTION "public"."reject_visa_redemption"("p_redemption_id" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."release_broadcast_seat"("p_room" "text", "p_seat_index" integer, "p_user_id" "uuid", "p_force" boolean DEFAULT false) RETURNS TABLE("room" "text", "seat_index" integer, "user_id" "uuid", "username" "text", "avatar_url" "text", "role" "text", "metadata" "jsonb", "assigned_at" timestamp with time zone)
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  existing public.broadcast_seats%ROWTYPE;
BEGIN
  SELECT * INTO existing
  FROM public.broadcast_seats bs
  WHERE bs.room = p_room AND bs.seat_index = p_seat_index
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN;
  END IF;

  IF NOT p_force AND existing.user_id <> p_user_id THEN
    RETURN;
  END IF;

  DELETE FROM public.broadcast_seats AS bs
  WHERE bs.room = p_room AND bs.seat_index = p_seat_index
  RETURNING
    bs.room, bs.seat_index, bs.user_id, bs.username, bs.avatar_url, bs.role, bs.metadata, bs.assigned_at
  INTO
    room, seat_index, user_id, username, avatar_url, role, metadata, assigned_at;

  RETURN NEXT;
END;
$$;


ALTER FUNCTION "public"."release_broadcast_seat"("p_room" "text", "p_seat_index" integer, "p_user_id" "uuid", "p_force" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."release_payment_hold"("hold_id" "uuid", "reason" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare role text;
begin
  role := public.get_staff_role(auth.uid());

  if role not in ('admin','lead_troll_officer') then
    return jsonb_build_object('status','error','message','not authorized');
  end if;

  update public.payment_holds
  set is_active = false,
      released_by = auth.uid(),
      released_reason = reason,
      released_at = now()
  where id = hold_id;

  return jsonb_build_object('status','ok','message','hold released');
end;
$$;


ALTER FUNCTION "public"."release_payment_hold"("hold_id" "uuid", "reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."relock_payouts"("p_reason" "text") RETURNS "public"."system_settings"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_settings public.system_settings;
BEGIN
  UPDATE public.system_settings
  SET payout_lock_enabled = TRUE,
      payout_lock_reason = COALESCE(p_reason, 'Emergency payout lock'),
      updated_at = now()
  WHERE TRUE;
  SELECT * INTO v_settings FROM public.system_settings ORDER BY updated_at DESC LIMIT 1;
  RETURN v_settings;
END
$$;


ALTER FUNCTION "public"."relock_payouts"("p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."remove_og_status_after_period"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- This function will be called by a scheduled job after 2-1-2026
  -- to remove OG status from users who don't have permanent OG status
  
  -- For now, we'll just log that the period has ended
  IF NOT is_og_period_active() THEN
    RAISE NOTICE 'OG period has ended. Consider running a cleanup to remove temporary OG status.';
  END IF;
END;
$$;


ALTER FUNCTION "public"."remove_og_status_after_period"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."remove_verification"("p_user_id" "uuid") RETURNS json
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  UPDATE user_profiles
  SET 
    is_verified = FALSE,
    verification_date = NULL,
    verification_paid_amount = NULL,
    verification_payment_method = NULL,
    updated_at = NOW()
  WHERE id = p_user_id;

  RETURN json_build_object('success', true);
END;
$$;


ALTER FUNCTION "public"."remove_verification"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."request_cashout"("p_amount" bigint) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  balance bigint;
BEGIN
  SELECT available_balance
  INTO balance
  FROM public.profiles
  WHERE id = auth.uid();

  IF balance < p_amount THEN
    RAISE EXCEPTION 'Insufficient balance for cashout';
  END IF;

  INSERT INTO public.payout_requests (user_id, amount)
  VALUES (auth.uid(), p_amount);

  UPDATE public.profiles
  SET available_balance = available_balance - p_amount
  WHERE id = auth.uid();
END;
$$;


ALTER FUNCTION "public"."request_cashout"("p_amount" bigint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."request_court_box"("p_session_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_user_id uuid;
  v_session record;
  v_count integer;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Authentication required');
  END IF;

  SELECT id, status, max_boxes
    INTO v_session
  FROM public.court_sessions
  WHERE id = p_session_id;

  IF v_session IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Court session not found');
  END IF;

  IF v_session.status IS NOT NULL AND v_session.status <> 'active' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Court session is not active');
  END IF;

  SELECT COUNT(*)
    INTO v_count
  FROM public.court_box_members
  WHERE session_id = p_session_id;

  IF v_count >= COALESCE(v_session.max_boxes, 2) THEN
    RETURN jsonb_build_object('success', false, 'error', 'All court boxes are full');
  END IF;

  INSERT INTO public.court_box_members (session_id, user_id)
  VALUES (p_session_id, v_user_id)
  ON CONFLICT (session_id, user_id) DO NOTHING;

  RETURN jsonb_build_object('success', true);
END;
$$;


ALTER FUNCTION "public"."request_court_box"("p_session_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_amount_troll_coins" integer) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_user_profile RECORD;
  v_cash_amount NUMERIC(10,2);
  v_processing_fee NUMERIC(10,2);
  v_net_amount NUMERIC(10,2);
  v_payout_id UUID;
  v_minimum INTEGER := 100;
  v_conversion_rate NUMERIC(10,4) := 0.10; -- $0.10 per paid coin
BEGIN
  -- Get user profile
  SELECT * INTO v_user_profile
  FROM user_profiles
  WHERE id = p_user_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not found');
  END IF;

  -- Removed broadcaster approval requirement - anyone can request payouts now

  -- Tax compliance check
  IF v_user_profile.tax_status = 'required' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Tax form required. Please submit your W-9 form first.');
  END IF;

  IF v_user_profile.tax_status != 'approved' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Payout locked. Tax verification required.');
  END IF;

  -- Validate amount
  IF p_amount_troll_coins < v_minimum THEN
    RETURN jsonb_build_object('success', false, 'error', format('Minimum withdrawal is %s troll_coins', v_minimum));
  END IF;

  IF p_amount_troll_coins > v_user_profile.troll_coins THEN
    RETURN jsonb_build_object('success', false, 'error', 'Insufficient paid coin balance');
  END IF;

  -- Calculate amounts
  v_cash_amount := p_amount_troll_coins * v_conversion_rate;
  v_processing_fee := v_cash_amount * 0.05; -- 5% processing fee
  v_net_amount := v_cash_amount - v_processing_fee;

  -- Create payout request
  INSERT INTO payout_requests (
    user_id,
    coins_used,
    cash_amount,
    processing_fee,
    net_amount,
    status,
    created_at
  )
  VALUES (
    p_user_id,
    p_amount_troll_coins,
    v_cash_amount,
    v_processing_fee,
    v_net_amount,
    'pending',
    NOW()
  )
  RETURNING id INTO v_payout_id;

  -- Deduct coins from user balance (hold them until payout is processed)
  UPDATE user_profiles
  SET 
    troll_coins = troll_coins - p_amount_troll_coins,
    updated_at = NOW()
  WHERE id = p_user_id;

  -- Record transaction
  INSERT INTO coin_transactions (
    user_id,
    type,
    amount,
    description,
    metadata
  )
  VALUES (
    p_user_id,
    'payout_request',
    -p_amount_troll_coins,
    format('Payout request: %s coins ($%s)', p_amount_troll_coins, v_net_amount),
    jsonb_build_object('payout_request_id', v_payout_id)
  );

  RETURN jsonb_build_object(
    'success', true,
    'payout_id', v_payout_id,
    'message', 'Payout request submitted successfully'
  );
END;
$_$;


ALTER FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_amount_troll_coins" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_coins_to_redeem" bigint) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_current_balance bigint;
  v_usd_amount numeric(10,2);
  v_payout_id uuid;
  v_minimum_coins bigint := 7000; -- $21 minimum (7000 coins)
  v_conversion_rate numeric := 0.003; -- Approximate rate: $21 for 7000 coins
BEGIN
  -- Get current paid coin balance
  SELECT troll_coins INTO v_current_balance
  FROM user_profiles
  WHERE id = p_user_id;

  IF v_current_balance IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'User profile not found'
    );
  END IF;

  -- Validate minimum withdrawal
  IF p_coins_to_redeem < v_minimum_coins THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', format('Minimum withdrawal is %s coins ($%s)', v_minimum_coins, (v_minimum_coins * v_conversion_rate))
    );
  END IF;

  -- Validate sufficient balance
  IF p_coins_to_redeem > v_current_balance THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', format('Insufficient balance. Available: %s coins', v_current_balance)
    );
  END IF;

  -- Calculate USD amount based on tier
  -- Tier 1: 7k coins = $21 (rate: 0.003)
  -- Tier 2: 14k coins = $49.50 (rate: 0.0035357)
  -- Tier 3: 27k coins = $90 (rate: 0.00333)
  -- Tier 4: 47k coins = $150 (rate: 0.00319)
  IF p_coins_to_redeem >= 47000 THEN
    v_usd_amount := p_coins_to_redeem * 0.00319; -- $150 for 47k
  ELSIF p_coins_to_redeem >= 27000 THEN
    v_usd_amount := p_coins_to_redeem * 0.00333; -- $90 for 27k
  ELSIF p_coins_to_redeem >= 14000 THEN
    v_usd_amount := p_coins_to_redeem * 0.0035357; -- $49.50 for 14k
  ELSE
    v_usd_amount := p_coins_to_redeem * 0.003; -- $21 for 7k
  END IF;

  -- Generate payout request ID
  v_payout_id := gen_random_uuid();

  -- Insert payout request
  INSERT INTO payout_requests (
    id,
    user_id,
    coins_redeemed,
    cash_amount,
    status,
    created_at
  ) VALUES (
    v_payout_id,
    p_user_id,
    p_coins_to_redeem,
    v_usd_amount,
    'pending',
    NOW()
  );

  -- Deduct coins from user profile (but don't actually deduct until approved/paid)
  -- We'll keep the coins in the balance until payout is processed
  -- This prevents double-spending if request is rejected

  -- Return success response
  RETURN jsonb_build_object(
    'success', true,
    'payout_id', v_payout_id,
    'coins_redeemed', p_coins_to_redeem,
    'cash_amount', v_usd_amount,
    'status', 'pending'
  );
END;
$_$;


ALTER FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_coins_to_redeem" bigint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_coins_to_redeem" bigint, "p_idempotency_key" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_actor_id uuid;
  v_user record;
  v_payout_id uuid;
  v_existing record;
  v_usd_amount numeric(10,2);
  v_minimum_coins bigint := 12000;
  v_coin_amount bigint;
BEGIN
  v_actor_id := auth.uid();
  IF v_actor_id IS NULL THEN
    RAISE EXCEPTION 'Authentication required';
  END IF;

  IF p_user_id IS NULL OR p_user_id <> v_actor_id THEN
    RAISE EXCEPTION 'Cannot request payout for another user';
  END IF;

  IF public.mai_override_enabled('payouts_frozen') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Payouts temporarily disabled for safety review');
  END IF;

  v_coin_amount := COALESCE(p_coins_to_redeem, 0);
  IF v_coin_amount <= 0 THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid coin amount');
  END IF;

  IF p_idempotency_key IS NOT NULL THEN
    SELECT id, status, cash_amount, COALESCE(coins_redeemed, coin_amount, coins_used, 0) AS coins
      INTO v_existing
    FROM public.payout_requests
    WHERE user_id = p_user_id
      AND idempotency_key = p_idempotency_key
    LIMIT 1;

    IF v_existing IS NOT NULL THEN
      RETURN jsonb_build_object(
        'success', true,
        'idempotent', true,
        'payout_id', v_existing.id,
        'coins_redeemed', v_existing.coins,
        'cash_amount', COALESCE(v_existing.cash_amount, 0),
        'status', v_existing.status
      );
    END IF;
  END IF;

  SELECT id, is_broadcaster, payout_paypal_email, tax_status, w9_status, paid_coin_balance, payout_frozen, payout_freeze_reason
    INTO v_user
  FROM public.user_profiles
  WHERE id = p_user_id;

  IF v_user IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User profile not found');
  END IF;

  IF COALESCE(v_user.payout_frozen, false) IS TRUE THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', COALESCE(NULLIF(trim(v_user.payout_freeze_reason), ''), 'Payouts are frozen for safety review')
    );
  END IF;

  IF COALESCE(v_user.is_broadcaster, false) IS NOT TRUE THEN
    RETURN jsonb_build_object('success', false, 'error', 'Only approved broadcasters can request payouts');
  END IF;

  IF v_user.payout_paypal_email IS NULL OR length(trim(v_user.payout_paypal_email)) = 0 THEN
    RETURN jsonb_build_object('success', false, 'error', 'PayPal payout email required');
  END IF;

  IF v_user.tax_status = 'required' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Tax form required. Please submit your W-9 form first.');
  END IF;

  IF v_user.tax_status IS NOT NULL AND v_user.tax_status NOT IN ('not_required', 'approved') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Payout locked. Tax verification required.');
  END IF;

  IF v_user.w9_status IS NOT NULL AND v_user.w9_status NOT IN ('submitted', 'verified') THEN
    RETURN jsonb_build_object('success', false, 'error', 'W-9 onboarding required to request a payout.');
  END IF;

  IF v_coin_amount < v_minimum_coins THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', format('Minimum withdrawal is %s coins', v_minimum_coins)
    );
  END IF;

  IF v_coin_amount >= 47000 THEN
    v_usd_amount := ROUND(v_coin_amount * 0.00319, 2);
  ELSIF v_coin_amount >= 27000 THEN
    v_usd_amount := ROUND(v_coin_amount * 0.00333, 2);
  ELSIF v_coin_amount >= 14000 THEN
    v_usd_amount := ROUND(v_coin_amount * 0.0035357, 2);
  ELSE
    v_usd_amount := ROUND(v_coin_amount * 0.003, 2);
  END IF;

  UPDATE public.user_profiles
  SET
    paid_coin_balance = paid_coin_balance - v_coin_amount,
    updated_at = NOW()
  WHERE id = p_user_id
    AND paid_coin_balance >= v_coin_amount;

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', format('Insufficient balance. Available: %s coins', COALESCE(v_user.paid_coin_balance, 0))
    );
  END IF;

  v_payout_id := gen_random_uuid();

  INSERT INTO public.payout_requests (
    id,
    user_id,
    coins_redeemed,
    cash_amount,
    status,
    created_at,
    idempotency_key,
    coins_reserved
  ) VALUES (
    v_payout_id,
    p_user_id,
    v_coin_amount,
    v_usd_amount,
    'pending',
    NOW(),
    p_idempotency_key,
    true
  );

  BEGIN
    INSERT INTO public.coin_transactions (
      user_id,
      type,
      amount,
      description,
      metadata
    ) VALUES (
      p_user_id,
      'payout_hold',
      -v_coin_amount,
      format('Payout request hold: %s coins ($%s)', v_coin_amount, v_usd_amount),
      jsonb_build_object('payout_request_id', v_payout_id)
    );
  EXCEPTION
    WHEN undefined_table THEN NULL;
    WHEN insufficient_privilege THEN NULL;
  END;

  PERFORM public.mai_append_event(
    'payout_requested',
    p_user_id,
    NULL,
    jsonb_build_object('payout_request_id', v_payout_id, 'coins', v_coin_amount, 'cash_amount', v_usd_amount),
    NULL
  );

  RETURN jsonb_build_object(
    'success', true,
    'payout_id', v_payout_id,
    'coins_redeemed', v_coin_amount,
    'cash_amount', v_usd_amount,
    'status', 'pending'
  );
EXCEPTION
  WHEN unique_violation THEN
    SELECT id, status, cash_amount, COALESCE(coins_redeemed, coin_amount, coins_used, 0) AS coins
      INTO v_existing
    FROM public.payout_requests
    WHERE user_id = p_user_id
      AND idempotency_key = p_idempotency_key
    LIMIT 1;

    IF v_existing IS NOT NULL THEN
      RETURN jsonb_build_object(
        'success', true,
        'idempotent', true,
        'payout_id', v_existing.id,
        'coins_redeemed', v_existing.coins,
        'cash_amount', COALESCE(v_existing.cash_amount, 0),
        'status', v_existing.status
      );
    END IF;
    RAISE;
END;
$_$;


ALTER FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_coins_to_redeem" bigint, "p_idempotency_key" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_coin_amount" integer, "p_cash_amount" numeric, "p_fee_amount" numeric, "p_provider_type" "text", "p_provider_username" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_id UUID;
BEGIN
  INSERT INTO payout_requests (
    id, user_id, coin_amount, cash_amount, fee_amount,
    provider_type, provider_username,
    status, created_at
  )
  VALUES (
    gen_random_uuid(),
    p_user_id,
    p_coin_amount,
    p_cash_amount,
    p_fee_amount,
    p_provider_type,
    p_provider_username,
    'pending',
    NOW()
  )
  RETURNING id INTO v_id;

  RETURN jsonb_build_object('success', true, 'payout_id', v_id);
END;
$$;


ALTER FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_coin_amount" integer, "p_cash_amount" numeric, "p_fee_amount" numeric, "p_provider_type" "text", "p_provider_username" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."request_visa_redemption"("p_user_id" "uuid", "p_coins" bigint, "p_usd" numeric) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_user_id uuid := auth.uid();
  v_reserved bigint;
  v_available bigint;
  v_total bigint;
  v_usd numeric(10,2);
  v_redemption_id uuid;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  IF p_user_id IS NULL OR p_user_id <> v_user_id THEN
    RAISE EXCEPTION 'Invalid user';
  END IF;

  IF p_coins NOT IN (12000, 30000, 60000, 120000) THEN
    RAISE EXCEPTION 'Invalid tier';
  END IF;

  v_usd := CASE p_coins
    WHEN 12000 THEN 25
    WHEN 30000 THEN 70
    WHEN 60000 THEN 150
    WHEN 120000 THEN 325
  END;

  IF p_usd IS NULL OR p_usd::numeric(10,2) <> v_usd THEN
    RAISE EXCEPTION 'USD does not match tier';
  END IF;

  SELECT COALESCE(troll_coins,0), COALESCE(reserved_troll_coins,0)
    INTO v_total, v_reserved
  FROM public.user_profiles
  WHERE id = p_user_id;

  v_available := v_total - v_reserved;
  IF v_available < p_coins THEN
    RAISE EXCEPTION 'Insufficient available coins';
  END IF;

  UPDATE public.user_profiles
  SET reserved_troll_coins = COALESCE(reserved_troll_coins,0) + p_coins,
      updated_at = now()
  WHERE id = p_user_id;

  INSERT INTO public.visa_redemptions (
    user_id, coins_reserved, usd_amount, status, created_at
  ) VALUES (
    p_user_id, p_coins, v_usd, 'pending', now()
  )
  RETURNING id INTO v_redemption_id;

  RETURN jsonb_build_object(
    'redemption_id', v_redemption_id,
    'WalletBefore', jsonb_build_object(
      'available', v_available,
      'reserved', v_reserved
    ),
    'WalletAfter', jsonb_build_object(
      'available', v_available - p_coins,
      'reserved', v_reserved + p_coins
    ),
    'RedemptionStatus', 'pending'
  );
END;
$$;


ALTER FUNCTION "public"."request_visa_redemption"("p_user_id" "uuid", "p_coins" bigint, "p_usd" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reserve_paid_coins_on_redemption"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- Reserve coins on INSERT (pending status)
  IF TG_OP = 'INSERT' THEN
    UPDATE user_profiles
    SET reserved_paid_coins = reserved_paid_coins + NEW.tier_coins_required
    WHERE id = NEW.user_id;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."reserve_paid_coins_on_redemption"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reserve_troll_coins_on_redemption"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  UPDATE user_profiles
  SET reserved_troll_coins = reserved_troll_coins + NEW.tier_coins_required
  WHERE id = NEW.user_id;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."reserve_troll_coins_on_redemption"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reset_app_for_launch"() RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_deleted_counts JSONB := '{}'::jsonb;
BEGIN
  -- Check if caller is admin
  IF NOT EXISTS (
    SELECT 1 FROM user_profiles 
    WHERE id = auth.uid() 
    AND (role = 'admin' OR is_admin = TRUE)
  ) THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Only admins can reset the app');
  END IF;

  -- 1. Delete all coin transactions
  DELETE FROM coin_transactions;
  v_deleted_counts := v_deleted_counts || jsonb_build_object('coin_transactions', (SELECT COUNT(*) FROM coin_transactions));

  -- 2. Delete all payout requests
  DELETE FROM payout_requests;
  v_deleted_counts := v_deleted_counts || jsonb_build_object('payout_requests', (SELECT COUNT(*) FROM payout_requests));

  -- 3. Reset all user coin balances
  UPDATE user_profiles
  SET 
    troll_coins = 0,
    troll_coins = 0,
    total_coins_earned = 0,
    total_coins_spent = 0
  WHERE troll_coins > 0 OR troll_coins > 0 OR total_coins_earned > 0 OR total_coins_spent > 0;
  v_deleted_counts := v_deleted_counts || jsonb_build_object('balances_reset', (SELECT COUNT(*) FROM user_profiles WHERE troll_coins = 0 AND troll_coins = 0));

  -- 4. Delete all notifications
  DELETE FROM notifications;
  v_deleted_counts := v_deleted_counts || jsonb_build_object('notifications', (SELECT COUNT(*) FROM notifications));

  -- 5. Delete all gifts
  DELETE FROM gifts;
  v_deleted_counts := v_deleted_counts || jsonb_build_object('gifts', (SELECT COUNT(*) FROM gifts));

  -- 6. Delete all battle history
  DELETE FROM battle_history;
  v_deleted_counts := v_deleted_counts || jsonb_build_object('battle_history', (SELECT COUNT(*) FROM battle_history));

  -- 7. Delete all battles
  DELETE FROM battles;
  v_deleted_counts := v_deleted_counts || jsonb_build_object('battles', (SELECT COUNT(*) FROM battles));

  -- 8. Delete all officer shift logs
  DELETE FROM officer_shift_logs;
  v_deleted_counts := v_deleted_counts || jsonb_build_object('officer_shift_logs', (SELECT COUNT(*) FROM officer_shift_logs));

  -- 9. Delete all officer shift slots
  DELETE FROM officer_shift_slots;
  v_deleted_counts := v_deleted_counts || jsonb_build_object('officer_shift_slots', (SELECT COUNT(*) FROM officer_shift_slots));

  -- 10. Delete all support tickets
  DELETE FROM support_tickets;
  v_deleted_counts := v_deleted_counts || jsonb_build_object('support_tickets', (SELECT COUNT(*) FROM support_tickets));

  -- 11. Delete all officer actions
  DELETE FROM officer_actions;
  v_deleted_counts := v_deleted_counts || jsonb_build_object('officer_actions', (SELECT COUNT(*) FROM officer_actions));

  -- Log the reset
  INSERT INTO system_logs (event_type, description, metadata, created_at)
  VALUES (
    'app_reset',
    'Application reset for launch - all test data cleared',
    jsonb_build_object(
      'reset_at', NOW(),
      'reset_by', auth.uid(),
      'reset_reason', 'pre_launch_cleanup',
      'deleted_counts', v_deleted_counts
    ),
    NOW()
  );

  RETURN jsonb_build_object(
    'success', TRUE,
    'message', 'App reset for launch completed',
    'deleted_counts', v_deleted_counts
  );
END;
$$;


ALTER FUNCTION "public"."reset_app_for_launch"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."reset_app_for_launch"() IS 'Resets entire app for launch by deleting all test transactions, payouts, balances, and test data. Admin only.';



CREATE OR REPLACE FUNCTION "public"."reset_user_coins"("p_user_id" "uuid") RETURNS "void"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
  UPDATE user_profiles SET paid_coin_balance = 0, free_coin_balance = 0, updated_at = now() WHERE id = p_user_id;
$$;


ALTER FUNCTION "public"."reset_user_coins"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reset_weekly_family_war_points"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  UPDATE public.family_war_stats
  SET weekly_war_points = 0,
      updated_at = now();
END;
$$;


ALTER FUNCTION "public"."reset_weekly_family_war_points"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."review_seller_appeal"("p_application_id" "uuid", "p_action" "text", "p_notes" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_application RECORD;
  v_admin_check boolean;
BEGIN
  -- Check if user is admin
  SELECT EXISTS(
    SELECT 1 FROM user_profiles
    WHERE id = auth.uid()
    AND role IN ('admin', 'officer')
  ) INTO v_admin_check;

  IF NOT v_admin_check THEN
    RETURN jsonb_build_object('success', false, 'error', 'Only admins can review appeals');
  END IF;

  -- Get application details
  SELECT * INTO v_application
  FROM applications
  WHERE id = p_application_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Application not found');
  END IF;

  IF NOT v_application.appeal_requested OR v_application.appeal_status != 'pending' THEN
    RETURN jsonb_build_object('success', false, 'error', 'No pending appeal for this application');
  END IF;

  -- Update appeal status
  UPDATE applications
  SET appeal_status = CASE WHEN p_action = 'approve' THEN 'approved' ELSE 'denied' END,
      appeal_reviewed_by = auth.uid(),
      appeal_reviewed_at = now(),
      appeal_notes = p_notes,
      updated_at = now()
  WHERE id = p_application_id;

  -- If appeal is approved, approve the original application
  IF p_action = 'approve' THEN
    -- Update application status
    UPDATE applications
    SET status = 'approved',
        reviewed_by = auth.uid(),
        reviewed_at = now(),
        updated_at = now()
    WHERE id = p_application_id;

    -- Grant seller permissions
    UPDATE user_profiles
    SET seller_verified = true,
        updated_at = now()
    WHERE id = v_application.user_id;

    -- Auto-create store
    INSERT INTO stores (owner_id, name, description)
    VALUES (
      v_application.user_id,
      COALESCE(v_application.data->>'store_name', v_application.data->>'storeName', 'Seller Store'),
      COALESCE(v_application.data->>'store_description', v_application.data->>'storeDescription', 'A seller store')
    );

    -- Create notification for user
    INSERT INTO notifications (
      user_id,
      type,
      title,
      message,
      metadata
    ) VALUES (
      v_application.user_id,
      'seller_appeal_approved',
      'Seller Application Approved',
      'Your seller application appeal has been approved! You can now create and manage your store.',
      jsonb_build_object('application_id', p_application_id)
    );
  ELSE
    -- Create notification for denied appeal
    INSERT INTO notifications (
      user_id,
      type,
      title,
      message,
      metadata
    ) VALUES (
      v_application.user_id,
      'seller_appeal_denied',
      'Seller Appeal Denied',
      'Your seller application appeal has been denied. ' || COALESCE(p_notes, ''),
      jsonb_build_object('application_id', p_application_id, 'notes', p_notes)
    );
  END IF;

  RETURN jsonb_build_object('success', true, 'action', p_action, 'notes', p_notes);
END;
$$;


ALTER FUNCTION "public"."review_seller_appeal"("p_application_id" "uuid", "p_action" "text", "p_notes" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."review_seller_appeal"("p_application_id" "uuid", "p_action" "text", "p_notes" "text") IS 'Allows admins to approve or deny seller appeals';



CREATE OR REPLACE FUNCTION "public"."revoke_lead"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  update user_profiles
  set officer_role = 'officer'
  where id = p_user_id;

  insert into officer_actions (officer_id, action_type, acted_by, reason)
  values (p_user_id, 'revoked_lead', p_acted_by, p_reason);
end;
$$;


ALTER FUNCTION "public"."revoke_lead"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."rpc_buy_property_insurance"("p_user_id" "uuid", "p_property_id" "uuid", "p_cost" integer DEFAULT 500) RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_policy_id uuid := gen_random_uuid();
BEGIN
  -- must own the property
  IF NOT EXISTS (
    SELECT 1
    FROM public.trollstown_properties
    WHERE id = p_property_id AND user_id = p_user_id
  ) THEN
    RAISE EXCEPTION 'NOT_PROPERTY_OWNER';
  END IF;

  -- already insured?
  IF EXISTS (
    SELECT 1
    FROM public.trollstown_properties
    WHERE id = p_property_id AND insurance_active = true
  ) THEN
    RAISE EXCEPTION 'ALREADY_INSURED';
  END IF;

  -- deduct coins
  UPDATE public.user_profiles
  SET troll_coins = COALESCE(troll_coins,0) - p_cost,
      updated_at = now()
  WHERE id = p_user_id
    AND COALESCE(troll_coins,0) >= p_cost;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'INSUFFICIENT_TROLL_COINS';
  END IF;

  -- activate insurance on the property
  UPDATE public.trollstown_properties
  SET insurance_active = true,
      insurance_policy_id = v_policy_id,
      insured_at = now()
  WHERE id = p_property_id
    AND user_id = p_user_id;

  RETURN v_policy_id;
END;
$$;


ALTER FUNCTION "public"."rpc_buy_property_insurance"("p_user_id" "uuid", "p_property_id" "uuid", "p_cost" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."rpc_deduct_troll_coins"("p_amount" bigint, "p_user_id" "uuid") RETURNS bigint
    LANGUAGE "plpgsql"
    AS $$
declare
  v_new_balance bigint;
begin
  if p_amount is null or p_amount <= 0 then
    raise exception 'p_amount must be > 0';
  end if;

  -- prevent client from deducting someone else's coins
  if p_user_id <> auth.uid() then
    raise exception 'Not allowed';
  end if;

  -- ensure profile row exists
  insert into public.profiles (user_id, troll_coins)
  values (p_user_id, 0)
  on conflict (user_id) do nothing;

  -- atomic deduct
  update public.profiles
  set troll_coins = troll_coins - p_amount
  where user_id = p_user_id
    and troll_coins >= p_amount
  returning troll_coins into v_new_balance;

  if v_new_balance is null then
    raise exception 'Insufficient troll coins';
  end if;

  return v_new_balance;
end;
$$;


ALTER FUNCTION "public"."rpc_deduct_troll_coins"("p_amount" bigint, "p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."rpc_raid_property"("p_raider_id" "uuid", "p_property_id" "uuid", "p_raid_fee" integer DEFAULT 100, "p_max_reward" integer DEFAULT 250) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_owner_id uuid;
  v_insured boolean;
  v_property_value integer;
  v_reward integer;
  v_pool bigint;
BEGIN
  -- load property info
  SELECT user_id,
         insurance_active,
         COALESCE(value, 0)
  INTO v_owner_id, v_insured, v_property_value
  FROM public.trollstown_properties
  WHERE id = p_property_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'PROPERTY_NOT_FOUND';
  END IF;

  IF v_owner_id = p_raider_id THEN
    RAISE EXCEPTION 'CANNOT_RAID_OWN_PROPERTY';
  END IF;

  -- deduct raid fee from raider
  UPDATE public.user_profiles
  SET troll_coins = COALESCE(troll_coins,0) - p_raid_fee,
      updated_at = now()
  WHERE id = p_raider_id
    AND COALESCE(troll_coins,0) >= p_raid_fee;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'INSUFFICIENT_TROLL_COINS';
  END IF;

  -- add fee to admin pool
  UPDATE public.admin_coin_pool
  SET troll_coins = troll_coins + p_raid_fee,
      updated_at = now()
  WHERE id = true;

  -- if insured: block completely (fee stays in admin pool)
  IF v_insured THEN
    RETURN jsonb_build_object(
      'status','blocked_by_insurance',
      'raid_fee', p_raid_fee,
      'reward', 0,
      'owner_id', v_owner_id
    );
  END IF;

  -- compute reward (based on value, capped)
  -- simple: 250 max, scaled by value
  v_reward := LEAST(p_max_reward, GREATEST(0, (v_property_value / 10)));

  -- pay reward from admin pool (cap if pool too low)
  SELECT troll_coins INTO v_pool
  FROM public.admin_coin_pool
  WHERE id = true;

  v_reward := LEAST(v_reward, v_pool::integer);

  IF v_reward > 0 THEN
    -- subtract from pool
    UPDATE public.admin_coin_pool
    SET troll_coins = troll_coins - v_reward,
        updated_at = now()
    WHERE id = true;

    -- credit raider
    UPDATE public.user_profiles
    SET troll_coins = COALESCE(troll_coins,0) + v_reward,
        updated_at = now()
    WHERE id = p_raider_id;
  END IF;

  RETURN jsonb_build_object(
    'status','success',
    'raid_fee', p_raid_fee,
    'reward', v_reward,
    'owner_id', v_owner_id,
    'property_value', v_property_value
  );
END;
$$;


ALTER FUNCTION "public"."rpc_raid_property"("p_raider_id" "uuid", "p_property_id" "uuid", "p_raid_fee" integer, "p_max_reward" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."run_broadcast_cycle"("p_now" timestamp with time zone DEFAULT "now"(), "p_max_winners" integer DEFAULT 10, "p_drop_amount_paid_coins" bigint DEFAULT 1000, "p_pool_key" "text" DEFAULT 'home_troll_drops'::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_cycle_start timestamptz;
  v_cycle_end timestamptz;
  v_stream record;
  v_paid_coins bigint;
  v_chat bigint;
  v_reactions bigint;
  v_viewers integer;
  v_score numeric(18,2);

  v_streams_processed integer := 0;
  v_winners_count integer := 0;
  v_awarded integer := 0;
  v_pool_balance bigint := 0;
  v_required bigint := 0;
  v_lock_ok boolean := false;
  v_w record;
BEGIN
  v_lock_ok := pg_try_advisory_lock(hashtext('broadcast_cycle_30m'));
  IF NOT v_lock_ok THEN
    RETURN jsonb_build_object('success', false, 'error', 'cycle_locked');
  END IF;

  SELECT cycle_start, cycle_end
  INTO v_cycle_start, v_cycle_end
  FROM public.get_cycle_window_30m(p_now);

  FOR v_stream IN
    SELECT
      s.id AS stream_id,
      s.broadcaster_id,
      COALESCE(s.start_time, s.created_at, now()) AS start_time,
      COALESCE(s.current_viewers, 0) AS current_viewers
    FROM public.streams s
    WHERE s.is_live = true
  LOOP
    v_streams_processed := v_streams_processed + 1;
    v_viewers := v_stream.current_viewers;

    SELECT COALESCE(SUM(coins_spent),0)
    INTO v_paid_coins
    FROM public.gifts
    WHERE receiver_id = v_stream.broadcaster_id
      AND created_at >= v_cycle_start
      AND created_at < v_cycle_end;

    v_score :=
      (v_viewers::numeric * 1.0)
      + (v_paid_coins::numeric * 2.5);

    INSERT INTO public.broadcast_cycle_stats (
      cycle_start, cycle_end, stream_id, broadcaster_id,
      live_viewers, paid_coins_received,
      popularity_score, computed_at
    )
    VALUES (
      v_cycle_start, v_cycle_end,
      v_stream.stream_id, v_stream.broadcaster_id,
      v_viewers, v_paid_coins,
      v_score, now()
    )
    ON CONFLICT (cycle_start, stream_id) DO UPDATE
    SET
      paid_coins_received = EXCLUDED.paid_coins_received,
      popularity_score = EXCLUDED.popularity_score,
      computed_at = EXCLUDED.computed_at;
  END LOOP;

  RETURN jsonb_build_object(
    'success', true,
    'cycle_start', v_cycle_start,
    'cycle_end', v_cycle_end,
    'streams_processed', v_streams_processed
  );
END;
$$;


ALTER FUNCTION "public"."run_broadcast_cycle"("p_now" timestamp with time zone, "p_max_winners" integer, "p_drop_amount_paid_coins" bigint, "p_pool_key" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."run_daily_gift_leaderboards"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_lb_id uuid;
  v_start date := CURRENT_DATE;
  v_end date := CURRENT_DATE;
BEGIN
  v_lb_id := public.create_gifter_leaderboard_snapshot('daily', v_start, v_end);
  PERFORM public.apply_top_gifter_boosts(v_lb_id);
END;
$$;


ALTER FUNCTION "public"."run_daily_gift_leaderboards"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."run_monthly_gift_leaderboards"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_lb_id uuid;
  v_start date := date_trunc('month', CURRENT_DATE)::date;
  v_end date := (date_trunc('month', CURRENT_DATE)::date + INTERVAL '1 month - 1 day')::date;
BEGIN
  v_lb_id := public.create_gifter_leaderboard_snapshot('monthly', v_start, v_end);
  PERFORM public.apply_top_gifter_boosts(v_lb_id);
END;
$$;


ALTER FUNCTION "public"."run_monthly_gift_leaderboards"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."run_weekly_gift_leaderboards"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_lb_id uuid;
  v_start date := date_trunc('week', CURRENT_DATE)::date;
  v_end date := (date_trunc('week', CURRENT_DATE)::date + 6);
BEGIN
  v_lb_id := public.create_gifter_leaderboard_snapshot('weekly', v_start, v_end);
  PERFORM public.apply_top_gifter_boosts(v_lb_id);

  PERFORM public.apply_family_war_winner_boosts();
  PERFORM public.reset_weekly_family_war_points();
END;
$$;


ALTER FUNCTION "public"."run_weekly_gift_leaderboards"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."send_inventory_gift"("p_sender_id" "uuid", "p_item_id" "uuid", "p_target_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_actor uuid := auth.uid();
  v_trollmond_value bigint;
  v_animation_type text;
  v_quantity integer;
BEGIN
  IF v_actor IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Authentication required');
  END IF;

  IF p_sender_id IS NULL OR p_sender_id <> v_actor THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid sender');
  END IF;

  IF p_item_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Item required');
  END IF;

  IF p_target_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Target required');
  END IF;

  SELECT ui.quantity INTO v_quantity
  FROM public.user_inventory ui
  WHERE ui.user_id = p_sender_id
    AND ui.item_id = p_item_id
    AND ui.quantity > 0;

  IF NOT FOUND OR v_quantity <= 0 THEN
    RETURN jsonb_build_object('success', false, 'error', 'Item not in inventory');
  END IF;

  SELECT ii.trollmond_value, ii.animation_type
  INTO v_trollmond_value, v_animation_type
  FROM public.inventory_items ii
  WHERE ii.id = p_item_id
    AND ii.category = 'gift'
    AND ii.status = 'active';

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid gift item');
  END IF;

  UPDATE public.user_inventory
  SET quantity = quantity - 1, updated_at = now()
  WHERE user_id = p_sender_id AND item_id = p_item_id;

  DELETE FROM public.user_inventory
  WHERE user_id = p_sender_id AND item_id = p_item_id AND quantity <= 0;

  UPDATE public.user_profiles
  SET free_coin_balance = COALESCE(free_coin_balance, 0) + v_trollmond_value,
      updated_at = now()
  WHERE id = p_target_id;

  BEGIN
    INSERT INTO public.coin_transactions (
      user_id,
      type,
      coins,
      coin_type,
      description,
      metadata
    ) VALUES (
      p_target_id,
      'gift_received',
      v_trollmond_value,
      'free',
      'Received Trollbag gift',
      jsonb_build_object('sender_id', p_sender_id, 'item_id', p_item_id)
    );
  EXCEPTION WHEN OTHERS THEN
    NULL;
  END;

  RETURN jsonb_build_object(
    'success', true,
    'trollmond_value', v_trollmond_value,
    'animation_type', v_animation_type
  );
END;
$$;


ALTER FUNCTION "public"."send_inventory_gift"("p_sender_id" "uuid", "p_item_id" "uuid", "p_target_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."send_wall_post_gift"("p_post_id" "uuid", "p_gift_type" "text", "p_quantity" integer DEFAULT 1) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_sender_id UUID := auth.uid();
  v_gift_cost INTEGER;
  v_sender_coins INTEGER;
  v_post_owner_id UUID;
  v_receiver_reward INTEGER;
  v_tx_sender UUID;
  v_tx_receiver UUID;
  v_default_cost INTEGER := 10;
  v_safe_quantity INTEGER;
  v_gift_slug TEXT;
BEGIN
  IF v_sender_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  v_safe_quantity := GREATEST(1, p_quantity);

  SELECT coin_cost, COALESCE(gift_slug, slug, name)
  INTO v_gift_cost, v_gift_slug
  FROM gifts
  WHERE LOWER(COALESCE(gift_slug, slug, name)) = LOWER(p_gift_type)
  LIMIT 1;

  IF v_gift_cost IS NULL THEN
    v_gift_cost := v_default_cost;
    v_gift_slug := p_gift_type;
  END IF;

  v_gift_cost := v_gift_cost * v_safe_quantity;

  SELECT troll_coins INTO v_sender_coins
  FROM user_profiles
  WHERE id = v_sender_id;

  IF COALESCE(v_sender_coins, 0) < v_gift_cost THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Insufficient coins',
      'required', v_gift_cost,
      'available', COALESCE(v_sender_coins, 0)
    );
  END IF;

  SELECT user_id INTO v_post_owner_id
  FROM troll_wall_posts
  WHERE id = p_post_id;

  IF v_post_owner_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Post not found');
  END IF;

  UPDATE user_profiles
  SET troll_coins = COALESCE(troll_coins, 0) - v_gift_cost
  WHERE id = v_sender_id;

  v_receiver_reward := FLOOR(v_gift_cost * 0.8);

  UPDATE user_profiles
  SET troll_coins = COALESCE(troll_coins, 0) + v_receiver_reward
  WHERE id = v_post_owner_id;

  INSERT INTO troll_wall_gifts (post_id, sender_id, gift_type, quantity, coin_cost)
  VALUES (p_post_id, v_sender_id, v_gift_slug, v_safe_quantity, v_gift_cost);

  INSERT INTO coin_transactions (user_id, amount, type, description, metadata)
  VALUES (
    v_sender_id,
    -v_gift_cost,
    'gift_sent_wall',
    'Gift sent on wall post',
    jsonb_build_object(
      'post_id', p_post_id,
      'gift_type', v_gift_slug,
      'quantity', v_safe_quantity,
      'receiver_id', v_post_owner_id
    )
  )
  RETURNING id INTO v_tx_sender;

  INSERT INTO coin_transactions (user_id, amount, type, description, metadata)
  VALUES (
    v_post_owner_id,
    v_receiver_reward,
    'gift_received_wall',
    'Gift received on wall post',
    jsonb_build_object(
      'post_id', p_post_id,
      'gift_type', v_gift_slug,
      'quantity', v_safe_quantity,
      'sender_id', v_sender_id
    )
  )
  RETURNING id INTO v_tx_receiver;

  RETURN jsonb_build_object(
    'success', true,
    'gift_type', v_gift_slug,
    'quantity', v_safe_quantity,
    'total_cost', v_gift_cost,
    'sender_coins', COALESCE(v_sender_coins, 0) - v_gift_cost,
    'receiver_reward', v_receiver_reward,
    'tx_sender', v_tx_sender,
    'tx_receiver', v_tx_receiver
  );
END;
$$;


ALTER FUNCTION "public"."send_wall_post_gift"("p_post_id" "uuid", "p_gift_type" "text", "p_quantity" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_action_logs_created_day"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.created_day := NEW.created_at::date;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_action_logs_created_day"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_active_broadcast_theme"("p_theme_slug" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
declare
  v_user_id uuid := auth.uid();
  v_theme_id uuid;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  if p_theme_slug is null then
    -- clear to default
    insert into public.user_broadcast_theme_state(user_id, active_theme_id, updated_at)
    values (v_user_id, null, now())
    on conflict (user_id)
    do update set active_theme_id = null, updated_at = now();

    return jsonb_build_object('ok', true, 'active', null);
  end if;

  select id into v_theme_id
  from public.broadcast_background_themes
  where slug = p_theme_slug
    and is_active = true;

  if v_theme_id is null then
    raise exception 'Theme not found or inactive';
  end if;

  -- must be owned
  if not exists (
    select 1 from public.user_broadcast_theme_purchases
    where user_id = v_user_id and theme_id = v_theme_id
  ) then
    raise exception 'Theme not owned';
  end if;

  insert into public.user_broadcast_theme_state(user_id, active_theme_id, updated_at)
  values (v_user_id, v_theme_id, now())
  on conflict (user_id)
  do update set active_theme_id = excluded.active_theme_id, updated_at = now();

  return jsonb_build_object('ok', true, 'active', p_theme_slug);
end;
$$;


ALTER FUNCTION "public"."set_active_broadcast_theme"("p_theme_slug" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_active_broadcast_theme"("p_theme_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
declare
  v_user_id uuid := auth.uid();
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  -- your update logic using v_user_id
  -- example (replace with your real tables/columns):
  -- update public.broadcast_themes
  -- set is_active = (id = p_theme_id)
  -- where user_id = v_user_id;

end;
$$;


ALTER FUNCTION "public"."set_active_broadcast_theme"("p_theme_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_active_broadcast_theme"("p_user_id" "uuid", "p_theme_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_owned boolean := false;
BEGIN
  IF p_theme_id IS NOT NULL THEN
    SELECT EXISTS (
      SELECT 1 FROM public.user_broadcast_theme_purchases
      WHERE user_id = p_user_id AND theme_id = p_theme_id
    )
    INTO v_owned;

    IF NOT v_owned THEN
      RETURN jsonb_build_object('success', false, 'error', 'Theme not owned');
    END IF;
  END IF;

  INSERT INTO public.user_broadcast_theme_state (user_id, active_theme_id, updated_at)
  VALUES (p_user_id, p_theme_id, now())
  ON CONFLICT (user_id)
  DO UPDATE SET active_theme_id = EXCLUDED.active_theme_id, updated_at = now();

  RETURN jsonb_build_object('success', true, 'active_theme_id', p_theme_id);
END;
$$;


ALTER FUNCTION "public"."set_active_broadcast_theme"("p_user_id" "uuid", "p_theme_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_active_call_sound"("p_sound_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_user_id uuid := auth.uid();
  v_type text;
  v_owned boolean := false;
begin
  if v_user_id is null then
    return jsonb_build_object('success', false, 'error', 'not_authenticated');
  end if;

  select sound_type into v_type
  from public.call_sound_catalog
  where id = p_sound_id;

  if v_type is null then
    return jsonb_build_object('success', false, 'error', 'sound_not_found');
  end if;

  select exists (
    select 1 from public.user_call_sounds
    where user_id = v_user_id and sound_id = p_sound_id
  ) into v_owned;

  if not v_owned then
    return jsonb_build_object('success', false, 'error', 'sound_not_owned');
  end if;

  update public.user_call_sounds u
  set is_active = false
  where u.user_id = v_user_id
    and u.sound_id in (
      select id from public.call_sound_catalog where sound_type = v_type
    );

  update public.user_call_sounds
  set is_active = true
  where user_id = v_user_id and sound_id = p_sound_id;

  return jsonb_build_object('success', true, 'sound_id', p_sound_id);
end;
$$;


ALTER FUNCTION "public"."set_active_call_sound"("p_sound_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_active_entrance_effect"("p_effect_id" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- First, deactivate ALL entrance effects for this user
  UPDATE user_profiles
  SET active_entrance_effect = NULL
  WHERE id = auth.uid();

  -- If p_effect_id is provided (not null), set it as active
  -- We store the active effect ID directly in user_profiles for easy access
  -- Alternatively, if using user_active_items, we would manage it there.
  -- Based on the UserInventory.tsx code, it seems we might be using user_active_items OR a field on profile.
  -- Let's support both for robustness or check what UserInventory expects.
  -- UserInventory.tsx calls: supabase.rpc('set_active_entrance_effect', { p_effect_id: newEffectId })
  
  IF p_effect_id IS NOT NULL THEN
    UPDATE user_profiles
    SET active_entrance_effect = p_effect_id
    WHERE id = auth.uid();
  END IF;
END;
$$;


ALTER FUNCTION "public"."set_active_entrance_effect"("p_effect_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_active_entrance_effect"("p_effect_id" "text", "p_item_type" "text" DEFAULT 'effect'::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  -- 1. Deactivate all entrance effects (both purchased and role-based)
  DELETE FROM user_active_items
  WHERE user_id = auth.uid() 
  AND item_type IN ('effect', 'role_effect');

  -- Deactivate legacy entrance effects table if present
  UPDATE user_entrance_effects
  SET is_active = false
  WHERE user_id = auth.uid();

  -- Clear user_profiles active field
  UPDATE user_profiles
  SET active_entrance_effect = NULL
  WHERE id = auth.uid();

  -- 2. Activate the new effect if provided
  IF p_effect_id IS NOT NULL THEN
    -- Only insert into user_active_items for items that are UUID-based (non-role effects)
    IF p_item_type <> 'role_effect' THEN
      INSERT INTO user_active_items (user_id, item_id, item_type)
      VALUES (auth.uid(), p_effect_id::uuid, p_item_type)
      ON CONFLICT (user_id, item_id) DO NOTHING;

      UPDATE user_entrance_effects
      SET is_active = true
      WHERE user_id = auth.uid() AND effect_id = p_effect_id;
    END IF;

    -- Always update user_profiles with the provided effect identifier (text)
    UPDATE user_profiles
    SET active_entrance_effect = p_effect_id
    WHERE id = auth.uid();
  END IF;
END;
$$;


ALTER FUNCTION "public"."set_active_entrance_effect"("p_effect_id" "text", "p_item_type" "text") OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."court_sessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "room_name" "text" NOT NULL,
    "started_by" "uuid" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "started_at" timestamp with time zone,
    "ended_at" timestamp with time zone,
    "is_public" boolean DEFAULT true NOT NULL,
    "max_boxes" integer DEFAULT 2 NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "scheduled_for" timestamp with time zone,
    "summons_id" "uuid",
    "created_by" "uuid",
    "session_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "accuser_id" "uuid",
    "defendant_id" "uuid",
    "judge_id" "uuid",
    "court_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    CONSTRAINT "court_sessions_max_boxes_check" CHECK ((("max_boxes" >= 2) AND ("max_boxes" <= 6))),
    CONSTRAINT "court_sessions_status_check" CHECK (("status" = ANY (ARRAY['scheduled'::"text", 'active'::"text", 'ended'::"text"])))
);

ALTER TABLE ONLY "public"."court_sessions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."court_sessions" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_court_boxes"("p_session_id" "text", "p_max_boxes" integer) RETURNS "public"."court_sessions"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_row court_sessions;
BEGIN
  IF NOT _is_court_admin() THEN
    RAISE EXCEPTION 'Not authorized';
  END IF;

  UPDATE court_sessions
  SET max_boxes = GREATEST(2, LEAST(6, COALESCE(p_max_boxes, 2))),
      updated_at = NOW()
  WHERE id = p_session_id
  RETURNING * INTO v_row;

  RETURN v_row;
END;
$$;


ALTER FUNCTION "public"."set_court_boxes"("p_session_id" "text", "p_max_boxes" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_court_session_started_by"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  if new.started_by is null then
    new.started_by := auth.uid();
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."set_court_session_started_by"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_default_troll_coins"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF NEW.troll_coins IS NULL OR NEW.troll_coins < 500 THEN
    NEW.troll_coins := 500;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_default_troll_coins"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_lead_officer_status"("p_user_id" "uuid", "p_make_lead" boolean) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_actor user_profiles;
  v_target user_profiles;
  v_action TEXT;
BEGIN
  SELECT *
  INTO v_actor
  FROM user_profiles
  WHERE id = auth.uid()
    AND (
      role = 'admin'
      OR is_admin = TRUE
      OR is_lead_officer = TRUE
    );

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Only admins and lead officers can change lead status');
  END IF;

  SELECT *
  INTO v_target
  FROM user_profiles
  WHERE id = p_user_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Target user not found');
  END IF;

  IF NOT (
    v_target.is_troll_officer = TRUE
    OR v_target.role = 'troll_officer'
  ) THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Only Troll Officers can become Lead Officers');
  END IF;

  IF p_make_lead THEN
    UPDATE user_profiles
    SET is_lead_officer = TRUE,
        updated_at = NOW()
    WHERE id = p_user_id;
    v_action := 'promoted';
  ELSE
    UPDATE user_profiles
    SET is_lead_officer = FALSE,
        updated_at = NOW()
    WHERE id = p_user_id;
    v_action := 'revoked';
  END IF;

  BEGIN
    INSERT INTO officer_actions (
      officer_id,
      target_user_id,
      action_type,
      reason
    ) VALUES (
      auth.uid(),
      p_user_id,
      CASE WHEN p_make_lead THEN 'promote_to_lead' ELSE 'revoke_lead' END,
      NULL
    );
  EXCEPTION WHEN OTHERS THEN
    NULL; -- optional logging table
  END;

  RETURN jsonb_build_object(
    'success', TRUE,
    'message', format('Lead officer status %s successfully', v_action),
    'target_user_id', p_user_id,
    'promoted', p_make_lead
  );
END;
$$;


ALTER FUNCTION "public"."set_lead_officer_status"("p_user_id" "uuid", "p_make_lead" boolean) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."set_lead_officer_status"("p_user_id" "uuid", "p_make_lead" boolean) IS 'Allows admins and lead officers to promote/revoke Troll Officers to/from Lead Officer.';



CREATE OR REPLACE FUNCTION "public"."set_officer_status"("target_user" "uuid", "new_status" "text", "reason" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  caller_role text;
  target_role text;
BEGIN
  -- Validate status
  IF new_status NOT IN ('active','probation','suspended') THEN
    RAISE EXCEPTION 'Invalid status';
  END IF;

  -- Caller role
  SELECT role INTO caller_role
  FROM public.profiles
  WHERE id = auth.uid();

  IF caller_role IS NULL THEN
    RAISE EXCEPTION 'Caller has no profile';
  END IF;

  -- Target role
  SELECT role INTO target_role
  FROM public.profiles
  WHERE id = target_user;

  IF target_role IS NULL THEN
    RAISE EXCEPTION 'Target has no profile';
  END IF;

  -- Admin can change status for anyone
  IF caller_role = 'admin' THEN
    UPDATE public.profiles
    SET officer_status = new_status
    WHERE id = target_user;

    INSERT INTO public.role_change_log (changed_by, target_user, old_role, new_role, reason)
    VALUES (auth.uid(), target_user, target_role, target_role, 'STATUS: ' || new_status || ' | ' || COALESCE(reason,''));

    RETURN;
  END IF;

  -- Lead troll officers can only manage troll_officers (not lead/admin)
  IF caller_role = 'lead_troll_officer' THEN
    IF target_role <> 'troll_officer' THEN
      RAISE EXCEPTION 'Leads can only change status for troll officers';
    END IF;

    UPDATE public.profiles
    SET officer_status = new_status
    WHERE id = target_user;

    INSERT INTO public.role_change_log (changed_by, target_user, old_role, new_role, reason)
    VALUES (auth.uid(), target_user, target_role, target_role, 'STATUS: ' || new_status || ' | ' || COALESCE(reason,''));

    RETURN;
  END IF;

  RAISE EXCEPTION 'Not authorized';
END;
$$;


ALTER FUNCTION "public"."set_officer_status"("target_user" "uuid", "new_status" "text", "reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_og_badge"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- Auto-mark users who joined before 2026-01-01 as OG
  IF (NEW.created_at < '2026-01-01'::timestamp) THEN
    NEW.is_og_user := true;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_og_badge"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_og_status_for_new_users"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF is_og_period_active() THEN
    NEW.is_og_user = TRUE;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_og_status_for_new_users"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_referral_deadline"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
        BEGIN
            NEW.deadline := NEW.referred_at + INTERVAL '21 days';
            RETURN NEW;
        END;
        $$;


ALTER FUNCTION "public"."set_referral_deadline"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_trollstown_coins_on_insert"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  select up.troll_coins
  into new.troll_coins
  from public.user_profiles up
  where up.user_id = new.user_id;

  new.troll_coins := coalesce(new.troll_coins, 0);
  return new;
end;
$$;


ALTER FUNCTION "public"."set_trollstown_coins_on_insert"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  if to_jsonb(NEW) ? 'updated_at' then
    NEW.updated_at := now();
  end if;
  return NEW;
end;
$$;


ALTER FUNCTION "public"."set_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_user_role"("target_user" "uuid", "new_role" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  caller_role text;
  old_target_role text;
BEGIN
  -- Get caller role
  SELECT role INTO caller_role
  FROM public.profiles
  WHERE id = auth.uid();

  IF caller_role IS NULL THEN
    RAISE EXCEPTION 'Caller has no profile';
  END IF;

  -- Get target current role
  SELECT role INTO old_target_role
  FROM public.profiles
  WHERE id = target_user;

  IF old_target_role IS NULL THEN
    RAISE EXCEPTION 'Target has no profile';
  END IF;

  -- Only allowed roles
  IF new_role NOT IN ('user','troll_officer','lead_troll_officer','admin') THEN
    RAISE EXCEPTION 'Invalid role';
  END IF;

  -- ‚úÖ Rule: ONLY admin can assign admin role
  IF new_role = 'admin' AND caller_role <> 'admin' THEN
    RAISE EXCEPTION 'Only admin can assign admin role';
  END IF;

  -- ‚úÖ Admin can assign any role
  IF caller_role = 'admin' THEN
    UPDATE public.profiles
    SET role = new_role
    WHERE id = target_user;

    INSERT INTO public.role_change_log (changed_by, target_user, old_role, new_role)
    VALUES (auth.uid(), target_user, old_target_role, new_role);

    RETURN;
  END IF;

  -- ‚úÖ Lead troll officer promotion rules
  IF caller_role = 'lead_troll_officer' THEN

    -- user -> troll_officer
    IF old_target_role = 'user' AND new_role = 'troll_officer' THEN
      UPDATE public.profiles
      SET role = new_role
      WHERE id = target_user;

      INSERT INTO public.role_change_log (changed_by, target_user, old_role, new_role)
      VALUES (auth.uid(), target_user, old_target_role, new_role);

      RETURN;
    END IF;

    -- troll_officer -> lead_troll_officer
    IF old_target_role = 'troll_officer' AND new_role = 'lead_troll_officer' THEN
      UPDATE public.profiles
      SET role = new_role
      WHERE id = target_user;

      INSERT INTO public.role_change_log (changed_by, target_user, old_role, new_role)
      VALUES (auth.uid(), target_user, old_target_role, new_role);

      RETURN;
    END IF;

    RAISE EXCEPTION 'Lead troll officers can only promote user->troll_officer or troll_officer->lead_troll_officer';
  END IF;

  -- Everyone else is blocked
  RAISE EXCEPTION 'Not authorized';
END;
$$;


ALTER FUNCTION "public"."set_user_role"("target_user" "uuid", "new_role" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_user_role"("target_user" "uuid", "new_role" "text", "reason" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  caller_role text;
  old_target_role text;
  today_hires int;
  hire_cap int;
BEGIN
  -- Get caller role
  SELECT role INTO caller_role
  FROM public.profiles
  WHERE id = auth.uid();

  IF caller_role IS NULL THEN
    RAISE EXCEPTION 'Caller has no profile';
  END IF;

  -- Get target current role
  SELECT role INTO old_target_role
  FROM public.profiles
  WHERE id = target_user;

  IF old_target_role IS NULL THEN
    RAISE EXCEPTION 'Target has no profile';
  END IF;

  -- Only allowed roles
  IF new_role NOT IN ('user','troll_officer','lead_troll_officer','admin') THEN
    RAISE EXCEPTION 'Invalid role';
  END IF;

  -- ‚úÖ Only admin can assign admin
  IF new_role = 'admin' AND caller_role <> 'admin' THEN
    RAISE EXCEPTION 'Only admin can assign admin role';
  END IF;

  -- ‚úÖ Admin can assign any role
  IF caller_role = 'admin' THEN
    UPDATE public.profiles
    SET role = new_role
    WHERE id = target_user;

    INSERT INTO public.role_change_log (changed_by, target_user, old_role, new_role, reason)
    VALUES (auth.uid(), target_user, old_target_role, new_role, reason);

    RETURN;
  END IF;

  -- ‚úÖ Lead troll officer rules
  IF caller_role = 'lead_troll_officer' THEN

    -- Hire limit (only when promoting user -> troll_officer)
    IF old_target_role = 'user' AND new_role = 'troll_officer' THEN

      SELECT max_hires_per_day INTO hire_cap
      FROM public.hire_limits
      WHERE role = 'lead_troll_officer';

      SELECT COUNT(*) INTO today_hires
      FROM public.role_change_log
      WHERE changed_by = auth.uid()
        AND new_role = 'troll_officer'
        AND created_at >= date_trunc('day', now());

      IF today_hires >= hire_cap THEN
        RAISE EXCEPTION 'Hire limit reached (% per day)', hire_cap;
      END IF;

      UPDATE public.profiles
      SET role = new_role,
          hired_by = auth.uid(),
          hired_at = now(),
          probation_ends_at = now() + interval '7 days',
          officer_status = 'probation'
      WHERE id = target_user;

      INSERT INTO public.role_change_log (changed_by, target_user, old_role, new_role, reason)
      VALUES (auth.uid(), target_user, old_target_role, new_role, reason);

      RETURN;
    END IF;

    -- Promote troll_officer -> lead_troll_officer
    IF old_target_role = 'troll_officer' AND new_role = 'lead_troll_officer' THEN

      UPDATE public.profiles
      SET role = new_role
      WHERE id = target_user;

      INSERT INTO public.role_change_log (changed_by, target_user, old_role, new_role, reason)
      VALUES (auth.uid(), target_user, old_target_role, new_role, reason);

      RETURN;
    END IF;

    -- Demote troll_officer -> user
    IF old_target_role = 'troll_officer' AND new_role = 'user' THEN
      UPDATE public.profiles
      SET role = new_role,
          officer_status = 'active',
          probation_ends_at = NULL
      WHERE id = target_user;

      INSERT INTO public.role_change_log (changed_by, target_user, old_role, new_role, reason)
      VALUES (auth.uid(), target_user, old_target_role, new_role, reason);

      RETURN;
    END IF;

    -- Demote lead_troll_officer -> troll_officer (BLOCKED unless admin)
    IF old_target_role = 'lead_troll_officer' THEN
      RAISE EXCEPTION 'Only admin can demote a lead troll officer';
    END IF;

    RAISE EXCEPTION 'Lead troll officers can only hire/promote/demote within allowed rules';
  END IF;

  RAISE EXCEPTION 'Not authorized';
END;
$$;


ALTER FUNCTION "public"."set_user_role"("target_user" "uuid", "new_role" "text", "reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."some_function"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- NEW is valid here
  IF NEW.battle_id IS NOT NULL THEN

  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."some_function"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."something"("a" integer, "b" "text") RETURNS boolean
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- logic here
END;
$$;


ALTER FUNCTION "public"."something"("a" integer, "b" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."spawn_troll_event"("p_troll_type" "text" DEFAULT 'green'::"text", "p_reward_amount" integer DEFAULT 10, "p_duration_minutes" integer DEFAULT 2) RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  event_id UUID;
BEGIN
  -- Deactivate any existing active events
  UPDATE troll_events SET active = false WHERE active = true;

  -- Create new event
  INSERT INTO troll_events (troll_type, reward_amount, expires_at)
  VALUES (p_troll_type, p_reward_amount, NOW() + INTERVAL '1 minute' * p_duration_minutes)
  RETURNING id INTO event_id;

  RETURN event_id;
END;
$$;


ALTER FUNCTION "public"."spawn_troll_event"("p_troll_type" "text", "p_reward_amount" integer, "p_duration_minutes" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."spend_coins"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_current_balance BIGINT;
  v_new_balance BIGINT;
  v_bonus_message TEXT := NULL;
  v_lucky_bonus BIGINT := 0;
  v_is_lucky BOOLEAN := false;
  v_multiplier NUMERIC;
BEGIN
  -- Check current balance
  SELECT troll_coins INTO v_current_balance
  FROM user_profiles
  WHERE id = p_user_id;

  IF v_current_balance IS NULL THEN
    RAISE EXCEPTION 'User not found';
  END IF;

  IF v_current_balance < p_amount THEN
    RAISE EXCEPTION 'Insufficient funds';
  END IF;

  -- Calculate new balance
  v_new_balance := v_current_balance - p_amount;

  -- Lucky Gift Logic (only for gifts)
  IF p_reason = 'gift_sent' AND p_amount > 0 THEN
    -- 5% chance to trigger lucky gift
    IF random() < 0.05 THEN
      v_is_lucky := true;
      
      -- Determine multiplier tiers
      -- 90% chance: 0.1x - 1x (10-100% back)
      -- 9% chance: 2x - 10x
      -- 1% chance: 10x - 1000x (Jackpot)
      
      DECLARE
        v_tier_roll FLOAT;
      BEGIN
        v_tier_roll := random();
        
        IF v_tier_roll < 0.90 THEN
           v_multiplier := 0.1 + (random() * 0.9); -- 0.1 to 1.0
        ELSIF v_tier_roll < 0.99 THEN
           v_multiplier := 2.0 + (random() * 8.0); -- 2.0 to 10.0
        ELSE
           v_multiplier := 10.0 + (random() * 990.0); -- 10.0 to 1000.0
        END IF;
      END;

      v_lucky_bonus := floor(p_amount * v_multiplier);
      
      -- Add bonus to new balance (net effect: spend less, or even gain)
      v_new_balance := v_new_balance + v_lucky_bonus;
      v_bonus_message := format('LUCKY GIFT! You won %s coins back! (%.1fx multiplier)', v_lucky_bonus, v_multiplier);
    END IF;
  END IF;

  -- Update user balance
  UPDATE user_profiles
  SET troll_coins = v_new_balance
  WHERE id = p_user_id;

  -- Record the transaction (Spend)
  INSERT INTO coin_transactions (
    user_id,
    amount,
    type,
    description,
    metadata
  ) VALUES (
    p_user_id,
    -p_amount, -- Negative for spending
    CASE WHEN p_reason = 'gift_sent' THEN 'gift' ELSE 'spend' END,
    p_reason,
    p_metadata
  );

  -- Record Lucky Bonus if applicable
  IF v_is_lucky THEN
    INSERT INTO coin_transactions (
      user_id,
      amount,
      type,
      description,
      metadata
    ) VALUES (
      p_user_id,
      v_lucky_bonus,
      'lucky_bonus',
      'Lucky Gift Bonus',
      jsonb_build_object('original_gift', p_amount, 'multiplier', v_multiplier)
    );
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'new_balance', v_new_balance,
    'lucky_bonus', v_lucky_bonus,
    'message', v_bonus_message
  );
END;
$$;


ALTER FUNCTION "public"."spend_coins"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text", "p_metadata" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."spend_coins"("p_sender_id" "uuid", "p_receiver_id" "uuid", "p_coin_amount" bigint, "p_source" "text" DEFAULT 'gift'::"text", "p_item" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_sender_balance BIGINT;
  v_gift_id UUID := gen_random_uuid();
BEGIN
  -- Check sender's paid coin balance
  SELECT Troll_coins INTO v_sender_balance
  FROM user_profiles
  WHERE id = p_sender_id;

  IF v_sender_balance IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Sender not found'
    );
  END IF;

  -- Check if sender has enough coins
  IF v_sender_balance < p_coin_amount THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Not enough coins',
      'current_balance', v_sender_balance,
      'required', p_coin_amount
    );
  END IF;

  -- Deduct coins from sender
  UPDATE user_profiles
  SET 
    Troll_coins = Troll_coins - p_coin_amount,
    total_spent_coins = COALESCE(total_spent_coins, 0) + p_coin_amount,
    updated_at = now()
  WHERE id = p_sender_id;

  -- Add coins to receiver (as Troll_coins)
  UPDATE user_profiles
  SET 
    Troll_coins = COALESCE(Troll_coins, 0) + p_coin_amount,
    total_earned_coins = COALESCE(total_earned_coins, 0) + p_coin_amount,
    updated_at = now()
  WHERE id = p_receiver_id;

  -- Insert gift record
  INSERT INTO gifts (
    id,
    sender_id,
    receiver_id,
    coins_spent,
    gift_type,
    message,
    created_at
  )
  VALUES (
    v_gift_id,
    p_sender_id,
    p_receiver_id,
    p_coin_amount,
    'paid',
    COALESCE(p_item, 'Gift'),
    now()
  );

  -- Insert coin transaction record (if table exists)
  BEGIN
    INSERT INTO coin_transactions (
      user_id,
      type,
      amount,
      coin_type,
      description,
      metadata,
      created_at
    )
    VALUES (
      p_sender_id,
      'gift',
      p_coin_amount,
      'troll_coins',
      format('Sent gift: %s', COALESCE(p_item, 'Gift')),
      jsonb_build_object(
        'receiver_id', p_receiver_id,
        'source', p_source,
        'item', p_item,
        'gift_id', v_gift_id
      ),
      now()
    );
  EXCEPTION WHEN OTHERS THEN
    -- coin_transactions table might not exist, ignore
    NULL;
  END;

  -- Create notification for receiver (if function exists)
  BEGIN
    PERFORM create_notification(
      p_receiver_id,
      'gift_received',
      'üéÅ Gift Received!',
      format('You received %s coins from a gift!', p_coin_amount),
      jsonb_build_object(
        'sender_id', p_sender_id,
        'coins_spent', p_coin_amount,
        'gift_id', v_gift_id,
        'item', p_item
      )
    );
  EXCEPTION WHEN OTHERS THEN
    -- create_notification function might not exist, ignore
    NULL;
  END;

  RETURN jsonb_build_object(
    'success', true,
    'gift_id', v_gift_id,
    'coins_spent', p_coin_amount
  );
END;
$$;


ALTER FUNCTION "public"."spend_coins"("p_sender_id" "uuid", "p_receiver_id" "uuid", "p_coin_amount" bigint, "p_source" "text", "p_item" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."spend_coins"("p_sender_id" "uuid", "p_receiver_id" "uuid", "p_coin_amount" bigint, "p_source" "text", "p_item" "text") IS 'Simple function to send coins from one user to another. Deducts from sender and adds to receiver as Troll_coins.';



CREATE OR REPLACE FUNCTION "public"."spend_free_coins"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_wallet record;
  v_remaining bigint;
BEGIN
  IF p_user_id IS NULL THEN
    RAISE EXCEPTION 'Missing user_id';
  END IF;
  IF p_amount IS NULL OR p_amount <= 0 THEN
    RAISE EXCEPTION 'Invalid amount';
  END IF;

  SELECT *
  INTO v_wallet
  FROM wallets
  WHERE user_id = p_user_id
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Wallet row not found for user %', p_user_id;
  END IF;

  v_remaining := COALESCE(v_wallet.trollmonds, 0);
  IF v_remaining < p_amount THEN
    RAISE EXCEPTION 'Insufficient Trollmonds: required %, available %', p_amount, v_remaining;
  END IF;

  UPDATE wallets
  SET trollmonds = v_remaining - p_amount,
      updated_at = NOW()
  WHERE user_id = p_user_id;

  UPDATE user_profiles
  SET free_coin_balance = GREATEST(COALESCE(free_coin_balance, 0) - p_amount, 0),
      total_spent_coins = COALESCE(total_spent_coins, 0) + p_amount,
      updated_at = NOW()
  WHERE id = p_user_id;

  BEGIN
    INSERT INTO coin_transactions (
      user_id,
      type,
      amount,
      coin_type,
      description,
      metadata,
      created_at
    )
    VALUES (
      p_user_id,
      'wheel_spin',
      p_amount,
      'free',
      'Troll Wheel spin',
      jsonb_build_object('reason', p_reason),
      NOW()
    );
  EXCEPTION WHEN undefined_table THEN
    -- coin_transactions table might not exist in older deployments
    NULL;
  END;

  RETURN jsonb_build_object(
    'success', true,
    'remaining', v_remaining - p_amount
  );
END;
$$;


ALTER FUNCTION "public"."spend_free_coins"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."spend_troll_coins"("p_receiver_id" "uuid", "p_amount" bigint, "p_source" "text", "p_item" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- Ensure sender has enough coins
  IF (SELECT troll_coins FROM public.profiles WHERE id = auth.uid()) < p_amount THEN
    RAISE EXCEPTION 'Insufficient troll coins';
  END IF;

  -- Debit sender
  UPDATE public.profiles
  SET troll_coins = troll_coins - p_amount
  WHERE id = auth.uid();

  -- Credit receiver
  UPDATE public.profiles
  SET troll_coins = troll_coins + p_amount
  WHERE id = p_receiver_id;

  -- Log transaction
  INSERT INTO public.transactions (user_id, asset, amount, direction, source, item)
  VALUES (auth.uid(), 'troll_coins', p_amount, 'debit', p_source, p_item);
END;
$$;


ALTER FUNCTION "public"."spend_troll_coins"("p_receiver_id" "uuid", "p_amount" bigint, "p_source" "text", "p_item" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."spend_trollmonds"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_wallet record;
  v_remaining bigint;
BEGIN
  IF p_user_id IS NULL THEN
    RAISE EXCEPTION 'Missing user_id';
  END IF;
  IF p_amount IS NULL OR p_amount <= 0 THEN
    RAISE EXCEPTION 'Invalid amount';
  END IF;

  SELECT *
  INTO v_wallet
  FROM wallets
  WHERE user_id = p_user_id
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Wallet row not found for user %', p_user_id;
  END IF;

  v_remaining := COALESCE(v_wallet.trollmonds, 0);
  IF v_remaining < p_amount THEN
    RAISE EXCEPTION 'Insufficient Trollmonds: required %, available %', p_amount, v_remaining;
  END IF;

  UPDATE wallets
  SET troll_coins = v_remaining - p_amount,
      updated_at = NOW()
  WHERE user_id = p_user_id;

  UPDATE user_profiles
  SET troll_coins = GREATEST(COALESCE(troll_coins, 0) - p_amount, 0),
      total_spent_coins = COALESCE(total_spent_coins, 0) + p_amount,
      updated_at = NOW()
  WHERE id = p_user_id;

  BEGIN
    INSERT INTO coin_transactions (
      user_id,
      type,
      amount,
      coin_type,
      description,
      metadata,
      coin_delta,
      created_at
    )
    VALUES (
      p_user_id,
      'wheel_spin',
      p_amount,
      'trollmonds',
      'Troll Wheel spin',
      jsonb_build_object('reason', p_reason),
      -p_amount,
      NOW()
    );
  EXCEPTION
    WHEN undefined_table THEN
      NULL;
    WHEN others THEN
      NULL;
  END;

  RETURN jsonb_build_object(
    'success', true,
    'remaining', v_remaining - p_amount
  );
END;
$$;


ALTER FUNCTION "public"."spend_trollmonds"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."spend_trollmonds"("p_receiver_id" "uuid", "p_amount" bigint, "p_source" "text", "p_item" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF (SELECT trollmonds FROM public.profiles WHERE id = auth.uid()) < p_amount THEN
    RAISE EXCEPTION 'Insufficient trollmonds';
  END IF;

  UPDATE public.profiles
  SET trollmonds = trollmonds - p_amount
  WHERE id = auth.uid();

  UPDATE public.profiles
  SET trollmonds = trollmonds + p_amount
  WHERE id = p_receiver_id;

  INSERT INTO public.transactions (user_id, asset, amount, direction, source, item)
  VALUES (auth.uid(), 'trollmonds', p_amount, 'debit', p_source, p_item);
END;
$$;


ALTER FUNCTION "public"."spend_trollmonds"("p_receiver_id" "uuid", "p_amount" bigint, "p_source" "text", "p_item" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."spin_wheel"("user_id" "uuid", "cost" integer, "prize_amount" integer, "prize_type" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  user_profile RECORD;
  new_balance INTEGER;
  badge_value TEXT := NULL;
BEGIN
  -- Get current user profile
  SELECT * INTO user_profile
  FROM user_profiles
  WHERE id = user_id;

  IF NOT FOUND THEN
    RETURN json_build_object('error', 'User not found');
  END IF;

  -- Check if user has enough coins
  IF (user_profile.free_coin_balance < cost) THEN
    RETURN json_build_object('error', 'Insufficient coins');
  END IF;

  -- Calculate new balance
  new_balance := user_profile.free_coin_balance - cost;

  -- Apply prize effects
  IF prize_type = 'coins' THEN
    new_balance := new_balance + prize_amount;
  ELSIF prize_type = 'vip' OR prize_type = 'bankrupt' THEN
    -- Bankrupt: lose all free coins
    new_balance := 0;
  ELSIF prize_type = 'jackpot' THEN
    -- Jackpot: award crown badge
    badge_value := 'troll_crown';
  END IF;

  -- Update user profile
  UPDATE user_profiles
  SET free_coin_balance = new_balance,
      badge = COALESCE(badge_value, badge),
      updated_at = NOW()
  WHERE id = user_id;

  -- Record coin transactions
  IF prize_type = 'coins' AND prize_amount > 0 THEN
    INSERT INTO coin_transactions (user_id, type, amount, description)
    VALUES (user_id, 'wheel_win', prize_amount, 'Wheel prize winnings');
  END IF;

  -- Record spin cost
  INSERT INTO coin_transactions (user_id, type, amount, description)
  VALUES (user_id, 'wheel_spin', -cost, 'Wheel spin cost');

  -- Record the spin
  INSERT INTO wheel_spins (user_id, prize_won, coins_spent, coins_won)
  VALUES (user_id, prize_type || ': ' || prize_amount, cost, CASE WHEN prize_type = 'coins' THEN prize_amount ELSE 0 END);

  -- Return updated profile data
  RETURN json_build_object(
    'free_coin_balance', new_balance,
    'badge', COALESCE(badge_value, user_profile.badge)
  );
END;
$$;


ALTER FUNCTION "public"."spin_wheel"("user_id" "uuid", "cost" integer, "prize_amount" integer, "prize_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."start_court_session"("p_room_name" "text", "p_session_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  insert into court_sessions (
    room_name,
    session_id,
    started_at
  )
  values (
    p_room_name,
    p_session_id,
    now()
  );
end;
$$;


ALTER FUNCTION "public"."start_court_session"("p_room_name" "text", "p_session_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."start_court_session"("p_session_id" "uuid", "p_max_boxes" integer DEFAULT 2, "p_room_name" "text" DEFAULT NULL::"text") RETURNS "public"."court_sessions"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_row court_sessions;
  v_actor_id uuid := auth.uid();
  v_has_started_by boolean := false;
  v_sql text;
  v_max_boxes integer := GREATEST(2, LEAST(6, COALESCE(p_max_boxes, 2)));
  v_room_name text := COALESCE(p_room_name, p_session_id::text);
BEGIN
  IF NOT is_court_admin() THEN
    RAISE EXCEPTION 'Not authorized';
  END IF;

  SELECT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'court_sessions'
      AND column_name = 'started_by'
  )
  INTO v_has_started_by;

  IF v_has_started_by THEN
    v_sql := '
      INSERT INTO court_sessions (id, created_by, started_by, status, is_public, max_boxes, room_name)
      VALUES ($1, $2, $2, ''active'', true, $3, $4)
      ON CONFLICT (id) DO UPDATE
        SET status = ''active'',
            is_public = true,
            max_boxes = EXCLUDED.max_boxes,
            room_name = EXCLUDED.room_name,
            started_by = EXCLUDED.started_by,
            updated_at = NOW()
      RETURNING *';
    EXECUTE v_sql INTO v_row USING p_session_id, v_actor_id, v_max_boxes, v_room_name;
  ELSE
    v_sql := '
      INSERT INTO court_sessions (id, created_by, status, is_public, max_boxes, room_name)
      VALUES ($1, $2, ''active'', true, $3, $4)
      ON CONFLICT (id) DO UPDATE
        SET status = ''active'',
            is_public = true,
            max_boxes = EXCLUDED.max_boxes,
            room_name = EXCLUDED.room_name,
            updated_at = NOW()
      RETURNING *';
    EXECUTE v_sql INTO v_row USING p_session_id, v_actor_id, v_max_boxes, v_room_name;
  END IF;

  RETURN v_row;
END;
$_$;


ALTER FUNCTION "public"."start_court_session"("p_session_id" "uuid", "p_max_boxes" integer, "p_room_name" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."start_launch_trial"("p_admin_id" "uuid") RETURNS "public"."system_settings"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_settings public.system_settings;
BEGIN
  DELETE FROM public.system_settings;
  INSERT INTO public.system_settings (
    payout_lock_enabled,
    payout_lock_reason,
    payout_unlock_at,
    trial_started_at,
    trial_started_by,
    updated_at
  )
  VALUES (
    TRUE,
    'Launch Trial Mode: payouts open after 14 days.',
    now() + interval '14 days',
    now(),
    p_admin_id,
    now()
  );
  SELECT * INTO v_settings FROM public.system_settings ORDER BY updated_at DESC LIMIT 1;
  RETURN v_settings;
END
$$;


ALTER FUNCTION "public"."start_launch_trial"("p_admin_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."start_officer_orientation"("p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_orientation RECORD;
BEGIN
  -- Get orientation
  SELECT * INTO v_orientation
  FROM officer_orientations
  WHERE user_id = p_user_id;

  IF v_orientation IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Orientation not found');
  END IF;

  IF v_orientation.status = 'passed' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Orientation already passed');
  END IF;

  IF v_orientation.attempts >= v_orientation.max_attempts THEN
    RETURN jsonb_build_object('success', false, 'error', 'Maximum attempts reached');
  END IF;

  -- Update status to in_progress
  UPDATE officer_orientations
  SET 
    status = 'in_progress',
    started_at = COALESCE(started_at, NOW()),
    updated_at = NOW()
  WHERE id = v_orientation.id;

  RETURN jsonb_build_object(
    'success', true,
    'message', 'Orientation started',
    'orientation_id', v_orientation.id,
    'attempts', v_orientation.attempts,
    'max_attempts', v_orientation.max_attempts
  );
END;
$$;


ALTER FUNCTION "public"."start_officer_orientation"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."start_officer_orientation"("p_user_id" "uuid") IS 'Starts an orientation session';



CREATE OR REPLACE FUNCTION "public"."submit_cashout_request"("p_user_id" "uuid", "p_amount_coins" integer, "p_usd_value" numeric, "p_provider" "text", "p_delivery_method" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_total_balance bigint;
  v_reserved bigint;
  v_available bigint;
  v_request_id uuid;
  cashout_coin_col text;
  insert_sql text;
BEGIN

  -- Detect the coin column used in cashout_requests
  SELECT column_name INTO cashout_coin_col
  FROM information_schema.columns
  WHERE table_schema='public'
    AND table_name='cashout_requests'
    AND column_name IN (
      'requested_coins',
      'amount_coins',
      'coins',
      'coin_amount',
      'troll_coins',
      'requested_amount',
      'requested_troll_coins'
    )
  ORDER BY CASE column_name
    WHEN 'requested_coins' THEN 1
    WHEN 'amount_coins' THEN 2
    WHEN 'coins' THEN 3
    WHEN 'coin_amount' THEN 4
    WHEN 'troll_coins' THEN 5
    WHEN 'requested_amount' THEN 6
    WHEN 'requested_troll_coins' THEN 7
    ELSE 999
  END
  LIMIT 1;

  IF cashout_coin_col IS NULL THEN
    RAISE EXCEPTION 'No coin amount column found in cashout_requests';
  END IF;

  -- Check balance (Total - Reserved)
  SELECT troll_coins, COALESCE(reserved_troll_coins, 0)
  INTO v_total_balance, v_reserved
  FROM public.user_profiles
  WHERE id = p_user_id;

  v_available := v_total_balance - v_reserved;

  IF v_available < p_amount_coins THEN
    RAISE EXCEPTION 'Insufficient balance';
  END IF;

  -- Reserve coins (Do NOT deduct from total yet)
  UPDATE public.user_profiles
  SET reserved_troll_coins = COALESCE(reserved_troll_coins, 0) + p_amount_coins
  WHERE id = p_user_id;

  -- Insert request dynamically with correct coin column
  insert_sql := format(
    'INSERT INTO public.cashout_requests (
        user_id,
        %I,
        usd_value,
        payout_method,
        gift_card_provider,
        delivery_method,
        status,
        processing_time_estimate,
        created_at
     ) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,now())
     RETURNING id',
    cashout_coin_col
  );

  EXECUTE insert_sql
  USING
    p_user_id,
    p_amount_coins,
    p_usd_value,
    'Gift Card',
    p_provider,
    p_delivery_method,
    'pending',
    'Under 30 minutes'
  INTO v_request_id;

  RETURN v_request_id;
END;
$_$;


ALTER FUNCTION "public"."submit_cashout_request"("p_user_id" "uuid", "p_amount_coins" integer, "p_usd_value" numeric, "p_provider" "text", "p_delivery_method" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."submit_id_verification"("p_user_id" "uuid", "p_id_photo_url" "text", "p_id_photo_hash" "text", "p_source" "text" DEFAULT 'signup'::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_existing record;
  v_new_id uuid;
BEGIN
  IF p_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User ID is required');
  END IF;

  IF p_id_photo_url IS NULL OR length(trim(p_id_photo_url)) = 0 THEN
    RETURN jsonb_build_object('success', false, 'error', 'ID photo URL is required');
  END IF;

  IF p_id_photo_hash IS NULL OR length(trim(p_id_photo_hash)) = 0 THEN
    RETURN jsonb_build_object('success', false, 'error', 'ID photo hash is required');
  END IF;

  SELECT id, user_id
    INTO v_existing
  FROM public.verification_requests
  WHERE id_photo_hash = p_id_photo_hash
    AND user_id <> p_user_id
  ORDER BY created_at DESC
  LIMIT 1;

  IF v_existing IS NOT NULL THEN
    UPDATE public.user_profiles
    SET is_banned = true,
        banned_until = NULL
    WHERE id = p_user_id;

    INSERT INTO public.verification_requests (
      user_id,
      id_photo_url,
      selfie_url,
      status,
      admin_note,
      id_photo_hash,
      source,
      duplicate_of_id
    ) VALUES (
      p_user_id,
      p_id_photo_url,
      NULL,
      'denied',
      'Auto-ban: ID reused by another account',
      p_id_photo_hash,
      p_source,
      v_existing.id
    )
    RETURNING id INTO v_new_id;

    RETURN jsonb_build_object(
      'success', false,
      'banned', true,
      'duplicate_of_id', v_existing.id,
      'request_id', v_new_id
    );
  END IF;

  INSERT INTO public.verification_requests (
    user_id,
    id_photo_url,
    selfie_url,
    status,
    id_photo_hash,
    source
  ) VALUES (
    p_user_id,
    p_id_photo_url,
    NULL,
    'pending',
    p_id_photo_hash,
    p_source
  )
  RETURNING id INTO v_new_id;

  RETURN jsonb_build_object('success', true, 'request_id', v_new_id);
END;
$$;


ALTER FUNCTION "public"."submit_id_verification"("p_user_id" "uuid", "p_id_photo_url" "text", "p_id_photo_hash" "text", "p_source" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."submit_officer_quiz"("p_answers" "jsonb", "p_time_taken_seconds" integer, "p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_correct_count INTEGER := 0;
  v_total_count INTEGER := 0;
  v_question RECORD;
  v_answer TEXT;
  v_is_correct BOOLEAN := FALSE;
BEGIN

  FOR v_question IN
    SELECT id, correct_answer
    FROM officer_quiz_questions
    WHERE id IN (SELECT jsonb_object_keys(p_answers)::uuid)
  LOOP
    v_total_count := v_total_count + 1;

    -- Extract user answer safely
    v_answer := p_answers ->> v_question.id::text;

    -- Force comparison even if v_answer is NULL
    v_is_correct := COALESCE(
      LOWER(TRIM(v_answer)) = LOWER(TRIM(v_question.correct_answer)),
      FALSE
    );

    IF v_is_correct THEN
      v_correct_count := v_correct_count + 1;
    END IF;

    INSERT INTO officer_quiz_results (
      id,
      officer_id,
      question_id,
      submitted_answer,
      is_correct,
      time_taken_seconds,
      created_at
    )
    VALUES (
      gen_random_uuid(),
      p_user_id,
      v_question.id,
      v_answer,
      v_is_correct,               -- NEVER NULL now
      p_time_taken_seconds,
      NOW()
    );
  END LOOP;

  RETURN jsonb_build_object(
    'correct', v_correct_count,
    'total', v_total_count,
    'passed', (v_correct_count >= CEIL(v_total_count * 0.7)),
    'percentage', (v_correct_count::numeric / NULLIF(v_total_count,0)) * 100
  );
END;
$$;


ALTER FUNCTION "public"."submit_officer_quiz"("p_answers" "jsonb", "p_time_taken_seconds" integer, "p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."submit_officer_quiz"("p_answers" "jsonb", "p_time_taken_seconds" integer, "p_user_id" "uuid") IS 'Submits quiz answers and grades them';



CREATE OR REPLACE FUNCTION "public"."submit_officer_quiz"("p_user_id" "uuid", "p_answers" "jsonb", "p_time_taken_seconds" integer) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_orientation RECORD;
  v_question RECORD;
  v_answer TEXT;
  v_correct_count INTEGER := 0;
  v_total_questions INTEGER;
  v_score INTEGER;
  v_passed BOOLEAN;
  v_attempt_id UUID;
BEGIN
  -- Get orientation
  SELECT * INTO v_orientation
  FROM officer_orientations
  WHERE user_id = p_user_id AND status = 'in_progress';

  IF v_orientation IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'No active orientation found');
  END IF;

  -- Check attempts
  IF v_orientation.attempts >= v_orientation.max_attempts THEN
    RETURN jsonb_build_object('success', false, 'error', 'Maximum attempts reached');
  END IF;

  -- Count total active questions
  SELECT COUNT(*) INTO v_total_questions
  FROM officer_quiz_questions
  WHERE is_active = true;

  IF v_total_questions = 0 THEN
    RETURN jsonb_build_object('success', false, 'error', 'No quiz questions available');
  END IF;

  -- Grade answers by looping through questions
  FOR v_question IN 
    SELECT id, correct_answer
    FROM officer_quiz_questions
    WHERE is_active = true
    ORDER BY order_index, id
  LOOP
    v_answer := p_answers->>v_question.id::text;
    IF v_answer = v_question.correct_answer THEN
      v_correct_count := v_correct_count + 1;
    END IF;
  END LOOP;

  -- Calculate score
  v_score := ROUND((v_correct_count::NUMERIC / v_total_questions::NUMERIC) * 100);
  v_passed := v_score >= 80;

  -- Create attempt record
  INSERT INTO officer_quiz_attempts (
    user_id,
    orientation_id,
    answers,
    score,
    passed,
    questions_answered,
    correct_answers,
    completed_at,
    time_taken_seconds
  ) VALUES (
    p_user_id,
    v_orientation.id,
    p_answers,
    v_score,
    v_passed,
    v_total_questions,
    v_correct_count,
    NOW(),
    p_time_taken_seconds
  ) RETURNING id INTO v_attempt_id;

  -- Update orientation
  UPDATE officer_orientations
  SET 
    attempts = attempts + 1,
    status = CASE 
      WHEN v_passed THEN 'passed'
      WHEN attempts + 1 >= max_attempts THEN 'failed'
      ELSE 'assigned'
    END,
    completed_at = CASE WHEN v_passed THEN NOW() ELSE completed_at END,
    updated_at = NOW()
  WHERE id = v_orientation.id;

  -- Call complete_orientation function
  PERFORM complete_orientation(p_user_id, v_passed);

  RETURN jsonb_build_object(
    'success', true,
    'passed', v_passed,
    'score', v_score,
    'correct_answers', v_correct_count,
    'total_questions', v_total_questions,
    'attempt_id', v_attempt_id,
    'attempts_remaining', GREATEST(0, v_orientation.max_attempts - v_orientation.attempts - 1),
    'message', CASE 
      WHEN v_passed THEN 'Congratulations! You passed the quiz and are now an active Troll Officer!'
      WHEN v_orientation.attempts + 1 >= v_orientation.max_attempts THEN 'You have reached the maximum number of attempts. Please contact an admin.'
      ELSE format('You scored %s%%. You need 80%% to pass. You have %s attempts remaining.', v_score, GREATEST(0, v_orientation.max_attempts - v_orientation.attempts - 1))
    END
  );
END;
$$;


ALTER FUNCTION "public"."submit_officer_quiz"("p_user_id" "uuid", "p_answers" "jsonb", "p_time_taken_seconds" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."submit_officer_quiz"("p_user_id" "uuid", "p_answers" "jsonb", "p_time_taken_seconds" integer) IS 'Submits quiz answers and grades them';



CREATE OR REPLACE FUNCTION "public"."submit_seller_appeal"("p_application_id" "uuid", "p_appeal_reason" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_application RECORD;
  v_days_since_denial integer;
BEGIN
  -- Get application details
  SELECT * INTO v_application
  FROM applications
  WHERE id = p_application_id AND user_id = auth.uid();

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Application not found');
  END IF;

  IF v_application.type != 'seller' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Only seller applications can be appealed');
  END IF;

  IF v_application.status != 'denied' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Only denied applications can be appealed');
  END IF;

  IF v_application.appeal_requested THEN
    RETURN jsonb_build_object('success', false, 'error', 'Appeal already submitted');
  END IF;

  -- Check if within 7 days of denial
  SELECT EXTRACT(EPOCH FROM (now() - v_application.updated_at)) / 86400 INTO v_days_since_denial;

  IF v_days_since_denial > 7 THEN
    RETURN jsonb_build_object('success', false, 'error', 'Appeal must be submitted within 7 days of denial');
  END IF;

  -- Submit appeal
  UPDATE applications
  SET appeal_requested = true,
      appeal_reason = p_appeal_reason,
      appeal_requested_at = now(),
      appeal_status = 'pending',
      updated_at = now()
  WHERE id = p_application_id;

  -- Create notification for admins
  INSERT INTO notifications (
    user_id,
    type,
    title,
    message,
    metadata
  )
  SELECT
    up.id,
    'seller_appeal_submitted',
    'Seller Appeal Submitted',
    'A seller has submitted an appeal for their denied application',
    jsonb_build_object('application_id', p_application_id, 'appeal_reason', p_appeal_reason)
  FROM user_profiles up
  WHERE up.role IN ('admin', 'officer');

  RETURN jsonb_build_object('success', true, 'message', 'Appeal submitted successfully');
END;
$$;


ALTER FUNCTION "public"."submit_seller_appeal"("p_application_id" "uuid", "p_appeal_reason" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."submit_seller_appeal"("p_application_id" "uuid", "p_appeal_reason" "text") IS 'Allows users to submit appeals for denied seller applications within 7 days';



CREATE OR REPLACE FUNCTION "public"."submit_weekly_report"("p_lead_officer_id" "uuid", "p_week_start" "date", "p_week_end" "date", "p_title" "text", "p_body" "text", "p_incidents" "jsonb" DEFAULT '[]'::"jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_lead_officer user_profiles%ROWTYPE;
BEGIN
  -- Verify the caller is a lead officer or admin
  SELECT * INTO v_lead_officer
  FROM user_profiles
  WHERE id = p_lead_officer_id;

  IF v_lead_officer IS NULL THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Lead officer not found');
  END IF;

  IF NOT (v_lead_officer.is_lead_officer = TRUE OR v_lead_officer.role = 'admin') THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Only lead officers can submit reports');
  END IF;

  -- Verify the caller matches the lead_officer_id (or is admin)
  IF auth.uid() != p_lead_officer_id AND NOT EXISTS (
    SELECT 1 FROM user_profiles 
    WHERE id = auth.uid() 
    AND (role = 'admin' OR is_admin = TRUE)
  ) THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Unauthorized');
  END IF;

  -- Insert or update the report (upsert)
  INSERT INTO weekly_officer_reports (
    lead_officer_id,
    week_start,
    week_end,
    title,
    body,
    incidents
  ) VALUES (
    p_lead_officer_id,
    p_week_start,
    p_week_end,
    p_title,
    p_body,
    p_incidents
  )
  ON CONFLICT (lead_officer_id, week_start, week_end)
  DO UPDATE SET
    title = EXCLUDED.title,
    body = EXCLUDED.body,
    incidents = EXCLUDED.incidents,
    updated_at = NOW();

  RETURN jsonb_build_object('success', TRUE, 'message', 'Report submitted successfully');
END;
$$;


ALTER FUNCTION "public"."submit_weekly_report"("p_lead_officer_id" "uuid", "p_week_start" "date", "p_week_end" "date", "p_title" "text", "p_body" "text", "p_incidents" "jsonb") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."submit_weekly_report"("p_lead_officer_id" "uuid", "p_week_start" "date", "p_week_end" "date", "p_title" "text", "p_body" "text", "p_incidents" "jsonb") IS 'Submits or updates a weekly officer report';



CREATE TABLE IF NOT EXISTS "public"."court_summons" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "summoned_user_id" "uuid" NOT NULL,
    "created_by" "uuid" NOT NULL,
    "reason" "text",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "incident_id" "uuid",
    "scheduled_for" timestamp with time zone,
    "court_session_id" "text",
    "accuser_id" "uuid",
    "defendant_id" "uuid",
    "judge_id" "uuid",
    CONSTRAINT "court_summons_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'resolved'::"text", 'cancelled'::"text"])))
);

ALTER TABLE ONLY "public"."court_summons" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."court_summons" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."summon_to_court"("p_summoned_user_id" "uuid", "p_reason" "text" DEFAULT NULL::"text") RETURNS "public"."court_summons"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_row court_summons;
BEGIN
  IF NOT _is_court_admin() THEN
    RAISE EXCEPTION 'Not authorized';
  END IF;

  INSERT INTO court_summons (
    summoned_user_id,
    created_by,
    reason,
    status
  )
  VALUES (
    p_summoned_user_id,
    auth.uid(),
    p_reason,
    'pending'
  )
  RETURNING * INTO v_row;

  RETURN v_row;
END;
$$;


ALTER FUNCTION "public"."summon_to_court"("p_summoned_user_id" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_action_type"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  new.action_type := new.action;
  return new;
end;
$$;


ALTER FUNCTION "public"."sync_action_type"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_badge_from_role"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  INSERT INTO public.officer_badges (user_id, badge, updated_at)
  VALUES (
    NEW.id,
    CASE NEW.role
      WHEN 'admin' THEN 'Admin'
      WHEN 'lead_troll_officer' THEN 'Lead Troll Officer'
      WHEN 'troll_officer' THEN 'Troll Officer'
      ELSE 'User'
    END,
    now()
  )
  ON CONFLICT (user_id) DO UPDATE
  SET badge = EXCLUDED.badge,
      updated_at = now();

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."sync_badge_from_role"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_empire_applicant_id"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  -- If applicant_id not provided, copy from user_id
  if new.applicant_id is null then
    new.applicant_id := new.user_id;
  end if;

  -- If user_id not provided, copy from applicant_id
  if new.user_id is null then
    new.user_id := new.applicant_id;
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."sync_empire_applicant_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_family_coins"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- If one is changed, copy to the other
  IF NEW.total_coins IS DISTINCT FROM OLD.total_coins THEN
    NEW.family_coins := NEW.total_coins;
  ELSIF NEW.family_coins IS DISTINCT FROM OLD.family_coins THEN
    NEW.total_coins := NEW.family_coins;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."sync_family_coins"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_key_columns"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.setting_key := NEW.key;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."sync_key_columns"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_troll_battle_broadcasters"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF NEW.broadcaster1_id IS NULL AND NEW.host_id IS NOT NULL THEN
    NEW.broadcaster1_id := NEW.host_id;
  END IF;
  IF NEW.broadcaster2_id IS NULL AND NEW.challenger_id IS NOT NULL THEN
    NEW.broadcaster2_id := NEW.challenger_id;
  END IF;

  IF NEW.host_id IS NULL AND NEW.broadcaster1_id IS NOT NULL THEN
    NEW.host_id := NEW.broadcaster1_id;
  END IF;
  IF NEW.challenger_id IS NULL AND NEW.broadcaster2_id IS NOT NULL THEN
    NEW.challenger_id := NEW.broadcaster2_id;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."sync_troll_battle_broadcasters"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_troll_role"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- Determine troll_role based on hierarchy
  -- 1. Admin (Highest)
  IF NEW.is_admin = true OR NEW.role = 'admin' THEN
    NEW.troll_role := 'admin';
  
  -- 2. Lead Troll Officer
  ELSIF NEW.is_lead_officer = true OR NEW.role = 'lead_troll_officer' THEN
    NEW.troll_role := 'lead_troll_officer';
  
  -- 3. Troll Officer
  ELSIF NEW.is_troll_officer = true OR NEW.role = 'troll_officer' THEN
    NEW.troll_role := 'troll_officer';
  
  -- 4. Troller
  ELSIF NEW.is_troller = true OR NEW.role = 'troller' THEN
    NEW.troll_role := 'troller';
    
  -- 5. Broadcaster
  ELSIF NEW.role = 'broadcaster' THEN
    NEW.troll_role := 'broadcaster';
    
  -- 6. Family roles
  ELSIF NEW.role = 'family_leader' THEN
    NEW.troll_role := 'family_leader';
  ELSIF NEW.role = 'member' OR NEW.role = 'troll_family' THEN
    NEW.troll_role := 'troll_family';
    
  -- 7. Empire Partner
  ELSIF NEW.role = 'empire_partner' THEN
    NEW.troll_role := 'empire_partner';
    
  -- 8. Secretary
  ELSIF NEW.role = 'secretary' THEN
    NEW.troll_role := 'secretary';

  -- 9. HR Admin
  ELSIF NEW.role = 'hr_admin' THEN
    NEW.troll_role := 'hr_admin';

  -- 10. Default/Fallback
  ELSE
    -- If troll_role is not already set or we are recalculating, set to user or keep existing role if valid
    IF NEW.troll_role IS NULL THEN
        NEW.troll_role := COALESCE(NEW.role, 'user');
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."sync_troll_role"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_trollstown_coins_from_profiles"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  update public.trollstown_properties
  set troll_coins = new.troll_coins
  where user_id = new.user_id;

  return new;
end;
$$;


ALTER FUNCTION "public"."sync_trollstown_coins_from_profiles"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_user_entrance_effects_cache"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  update public.user_profiles
  set entrance_effects = (
    select coalesce(jsonb_agg(effect_id), '[]'::jsonb)
    from public.user_entrance_effects
    where user_id = new.user_id
  ),
  updated_at = now()
  where id = new.user_id;

  return new;
end;
$$;


ALTER FUNCTION "public"."sync_user_entrance_effects_cache"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_vault_tokens"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- If vault_tokens changes, update the legacy columns
  IF NEW.vault_tokens IS DISTINCT FROM OLD.vault_tokens THEN
    NEW.family_coins := NEW.vault_tokens;
    NEW.total_coins := NEW.vault_tokens;
  -- If legacy columns change, update vault_tokens
  ELSIF NEW.family_coins IS DISTINCT FROM OLD.family_coins THEN
    NEW.vault_tokens := NEW.family_coins;
    NEW.total_coins := NEW.family_coins;
  ELSIF NEW.total_coins IS DISTINCT FROM OLD.total_coins THEN
    NEW.vault_tokens := NEW.total_coins;
    NEW.family_coins := NEW.total_coins;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."sync_vault_tokens"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_wallet_balance_to_profile"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  -- Mirror the wallet totals into the profile so the sidebar and other UI stay consistent
  UPDATE user_profiles
  SET
    paid_coin_balance = COALESCE(NEW.paid_coins, paid_coin_balance),
    free_coin_balance = COALESCE(NEW.trollmonds, free_coin_balance),
    updated_at = NOW()
  WHERE id = NEW.user_id;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."sync_wallet_balance_to_profile"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."toggle_anti_hack_system"("p_admin_id" "uuid", "p_code" "text", "p_enabled" boolean) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_admin RECORD;
BEGIN
  -- Validate admin
  SELECT id, role, is_admin
  INTO v_admin
  FROM user_profiles
  WHERE id = p_admin_id;

  IF v_admin IS NULL OR (v_admin.role <> 'admin' AND v_admin.is_admin IS NOT TRUE) THEN
    RETURN jsonb_build_object(
      'success', FALSE,
      'error', 'Only admins can toggle the anti-hack system'
    );
  END IF;

  -- Update settings
  UPDATE system_settings
  SET 
    anti_hack_enabled = p_enabled,
    anti_hack_code = p_code,
    updated_at = NOW()
  WHERE id = 'anti-hack-main';  -- your main system settings row ID

  -- Log the event
  INSERT INTO security_logs (
    event,
    user_id,
    details,
    created_at
  ) VALUES (
    'anti_hack_toggled',
    p_admin_id,
    jsonb_build_object(
      'enabled', p_enabled,
      'code', p_code
    ),
    NOW()
  );

  RETURN jsonb_build_object(
    'success', TRUE,
    'message', 'Anti-hack system updated successfully',
    'enabled', p_enabled
  );
END;
$$;


ALTER FUNCTION "public"."toggle_anti_hack_system"("p_admin_id" "uuid", "p_code" "text", "p_enabled" boolean) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."toggle_anti_hack_system"("p_admin_id" "uuid", "p_code" "text", "p_enabled" boolean) IS 'Toggles anti-hack system with admin code 1903';



CREATE OR REPLACE FUNCTION "public"."toggle_entrance_effect"("p_user_id" "uuid", "p_item_id" "uuid", "p_active" boolean) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_effect_id text;
  v_auth_user uuid;
BEGIN
  -- Validate caller is the same as p_user_id
  v_auth_user := auth.uid();
  IF v_auth_user IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  IF v_auth_user <> p_user_id THEN
    RAISE EXCEPTION 'Unauthorized: user mismatch';
  END IF;

  -- Verify the inventory record exists and get effect_id (TEXT)
  SELECT effect_id INTO v_effect_id
  FROM user_entrance_effects
  WHERE id = p_item_id
    AND user_id = p_user_id;

  IF v_effect_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'not_owned');
  END IF;

  -- Enforce single-active: deactivate all first
  UPDATE user_entrance_effects
  SET is_active = false
  WHERE user_id = p_user_id;

  -- Activate or deactivate the requested effect
  UPDATE user_entrance_effects
  SET is_active = p_active
  WHERE id = p_item_id
    AND user_id = p_user_id;

  -- Sync the user's active_entrance_effect column
  IF p_active THEN
    UPDATE user_profiles
    SET active_entrance_effect = v_effect_id
    WHERE id = p_user_id;
  ELSE
    UPDATE user_profiles
    SET active_entrance_effect = NULL
    WHERE id = p_user_id AND active_entrance_effect = v_effect_id;
  END IF;

  RETURN jsonb_build_object('success', true, 'effect_id', v_effect_id, 'active', p_active);
END;
$$;


ALTER FUNCTION "public"."toggle_entrance_effect"("p_user_id" "uuid", "p_item_id" "uuid", "p_active" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."toggle_follow"("target_user_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    is_following BOOLEAN;
BEGIN
    IF auth.uid() = target_user_id THEN
        RAISE EXCEPTION 'Cannot follow yourself';
    END IF;

    SELECT EXISTS(
        SELECT 1 FROM user_follows 
        WHERE follower_id = auth.uid() AND following_id = target_user_id
    ) INTO is_following;

    IF is_following THEN
        DELETE FROM user_follows 
        WHERE follower_id = auth.uid() AND following_id = target_user_id;
        RETURN false; -- No longer following
    ELSE
        INSERT INTO user_follows (follower_id, following_id)
        VALUES (auth.uid(), target_user_id);
        RETURN true; -- Now following
    END IF;
END;
$$;


ALTER FUNCTION "public"."toggle_follow"("target_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."toggle_wall_post_like"("p_post_id" "uuid", "p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_liked BOOLEAN;
  v_likes_count BIGINT;
BEGIN
  -- Check if user already liked this post
  SELECT EXISTS(
    SELECT 1 FROM troll_wall_likes
    WHERE post_id = p_post_id AND user_id = p_user_id
  ) INTO v_liked;

  IF v_liked THEN
    -- Unlike: remove like record
    DELETE FROM troll_wall_likes
    WHERE post_id = p_post_id AND user_id = p_user_id;
    
    -- Decrement likes count
    UPDATE troll_wall_posts
    SET likes = GREATEST(0, likes - 1)
    WHERE id = p_post_id;
    
    v_liked := false;
  ELSE
    -- Like: add like record
    INSERT INTO troll_wall_likes (post_id, user_id)
    VALUES (p_post_id, p_user_id)
    ON CONFLICT (post_id, user_id) DO NOTHING;
    
    -- Increment likes count
    UPDATE troll_wall_posts
    SET likes = likes + 1
    WHERE id = p_post_id;
    
    v_liked := true;
  END IF;

  -- Get updated likes count
  SELECT likes INTO v_likes_count
  FROM troll_wall_posts
  WHERE id = p_post_id;

  RETURN jsonb_build_object(
    'liked', v_liked,
    'likes_count', v_likes_count
  );
END;
$$;


ALTER FUNCTION "public"."toggle_wall_post_like"("p_post_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."toggle_wall_post_reaction"("p_post_id" "uuid", "p_reaction_type" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_existing BOOLEAN;
  v_reaction_count BIGINT;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT EXISTS(
    SELECT 1 FROM troll_wall_reactions
    WHERE post_id = p_post_id AND user_id = v_user_id AND reaction_type = p_reaction_type
  ) INTO v_existing;

  IF v_existing THEN
    DELETE FROM troll_wall_reactions
    WHERE post_id = p_post_id AND user_id = v_user_id AND reaction_type = p_reaction_type;
  ELSE
    DELETE FROM troll_wall_reactions
    WHERE post_id = p_post_id AND user_id = v_user_id;

    INSERT INTO troll_wall_reactions (post_id, user_id, reaction_type)
    VALUES (p_post_id, v_user_id, p_reaction_type);
  END IF;

  SELECT COUNT(*) INTO v_reaction_count
  FROM troll_wall_reactions
  WHERE post_id = p_post_id AND reaction_type = p_reaction_type;

  RETURN jsonb_build_object(
    'reaction_type', p_reaction_type,
    'removed', v_existing,
    'reaction_count', v_reaction_count
  );
END;
$$;


ALTER FUNCTION "public"."toggle_wall_post_reaction"("p_post_id" "uuid", "p_reaction_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."toggle_wall_post_reaction"("p_post_id" "uuid", "p_user_id" "uuid", "p_reaction_type" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_existing BOOLEAN;
  v_reaction_count BIGINT;
BEGIN
  SELECT EXISTS(
    SELECT 1 FROM troll_wall_reactions
    WHERE post_id = p_post_id AND user_id = p_user_id AND reaction_type = p_reaction_type
  ) INTO v_existing;

  IF v_existing THEN
    DELETE FROM troll_wall_reactions
    WHERE post_id = p_post_id AND user_id = p_user_id AND reaction_type = p_reaction_type;
  ELSE
    DELETE FROM troll_wall_reactions
    WHERE post_id = p_post_id AND user_id = p_user_id;
    
    INSERT INTO troll_wall_reactions (post_id, user_id, reaction_type)
    VALUES (p_post_id, p_user_id, p_reaction_type);
  END IF;

  SELECT COUNT(*) INTO v_reaction_count
  FROM troll_wall_reactions
  WHERE post_id = p_post_id AND reaction_type = p_reaction_type;

  RETURN jsonb_build_object(
    'reaction_type', p_reaction_type,
    'removed', v_existing,
    'reaction_count', v_reaction_count
  );
END;
$$;


ALTER FUNCTION "public"."toggle_wall_post_reaction"("p_post_id" "uuid", "p_user_id" "uuid", "p_reaction_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."touch_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."touch_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."track_broadcaster_earnings"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $_$
BEGIN
  -- Calculate USD value (assuming 100 coins = $1)
  INSERT INTO broadcaster_earnings (
    broadcaster_id,
    gift_id,
    coins_received,
    usd_value,
    created_at
  ) VALUES (
    NEW.receiver_id,
    NEW.id,
    NEW.coins_spent,
    NEW.coins_spent / 100.0,
    NOW()
  );
  RETURN NEW;
END;
$_$;


ALTER FUNCTION "public"."track_broadcaster_earnings"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_revoke_property_insurance_on_transfer"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  IF NEW.user_id IS DISTINCT FROM OLD.user_id THEN
    NEW.insurance_active := false;
    NEW.insurance_policy_id := NULL;
    NEW.insured_at := NULL;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_revoke_property_insurance_on_transfer"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_award_streamer_xp"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    v_duration_mins INTEGER;
    v_xp_amount INTEGER;
BEGIN
    -- Only run when stream ends (is_live changes to false, or ended_at is set)
    IF (OLD.is_live = true AND NEW.is_live = false) OR (OLD.ended_at IS NULL AND NEW.ended_at IS NOT NULL) THEN
        
        -- Calculate duration in minutes
        -- If ended_at is null (just flipped is_live), use NOW()
        -- If start_time is null, skip
        IF NEW.start_time IS NOT NULL THEN
            v_duration_mins := EXTRACT(EPOCH FROM (COALESCE(NEW.ended_at, NOW()) - NEW.start_time)) / 60;
            
            -- Ensure positive duration
            IF v_duration_mins > 0 THEN
                -- Award 10 XP per minute
                v_xp_amount := v_duration_mins * 10;
                
                -- Cap per stream? Maybe 3000 XP (5 hours)
                v_xp_amount := LEAST(v_xp_amount, 3000);
                
                -- Award XP
                PERFORM add_xp(NEW.broadcaster_id, v_xp_amount, 'stream');
            END IF;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_award_streamer_xp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_cleanup_sessions"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- Run cleanup every 100 inserts to keep the table manageable
    IF (SELECT COUNT(*) FROM active_sessions) % 100 = 0 THEN
        PERFORM cleanup_inactive_sessions();
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_cleanup_sessions"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trollstown_compute_stage"("p_population" bigint, "p_properties" bigint) RETURNS integer
    LANGUAGE "sql" IMMUTABLE
    SET "search_path" TO 'public', 'extensions'
    AS $$
  select least(
    10,
    1
    + floor(log(10, 1 + greatest(p_population, 0)))::int
    + floor(greatest(p_properties, 0) / 100)::int
  );
$$;


ALTER FUNCTION "public"."trollstown_compute_stage"("p_population" bigint, "p_properties" bigint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trollstown_process_rent_cycle"("p_cycle_start" timestamp with time zone, "p_cycle_end" timestamp with time zone) RETURNS TABLE("user_id" "uuid", "property_id" "uuid", "rent_due" bigint, "status" "text", "deducted_amount" bigint, "court_case_id" "uuid")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare
  r record;
  v_wallet_coins bigint;
  v_due bigint;
  v_case_id uuid;
begin
  -- Loop all non-evicted properties
  for r in
    select p.id as property_id, p.owner_id as user_id, p.property_value
    from public.trollstown_properties p
    where p.is_evicted = false
  loop
    v_case_id := null;
    v_due := floor(r.property_value * 0.10);

    -- Ensure wallet exists
    insert into public.wallets(user_id, troll_coins, trollmonds)
    values (r.user_id, 0, 0)
    on conflict (user_id) do nothing;

    select w.troll_coins into v_wallet_coins
    from public.wallets w
    where w.user_id = r.user_id
    for update;

    if v_wallet_coins >= v_due then
      -- Deduct rent
      update public.wallets
      set troll_coins = troll_coins - v_due,
          updated_at = now()
      where user_id = r.user_id;

      insert into public.trollstown_rent_cycles(
        user_id, property_id, rent_due, cycle_start, cycle_end, status, deducted_amount
      ) values (
        r.user_id, r.property_id, v_due, p_cycle_start, p_cycle_end, 'paid', v_due
      );

      user_id := r.user_id;
      property_id := r.property_id;
      rent_due := v_due;
      status := 'paid';
      deducted_amount := v_due;
      court_case_id := null;
      return next;

    else
      -- Failed: create rent cycle
      insert into public.trollstown_rent_cycles(
        user_id, property_id, rent_due, cycle_start, cycle_end, status, deducted_amount
      ) values (
        r.user_id, r.property_id, v_due, p_cycle_start, p_cycle_end, 'failed', 0
      );

      -- Create court case
      insert into public.trollcourt_cases(
        defendant_id, case_type, title, description, status, property_id, rent_due
      ) values (
        r.user_id,
        'Failure to Pay Rent',
        'Summons: Failure to Pay Rent',
        format('User failed to pay rent. Property %s rent due: %s Troll Coins. Balance at failure: %s Troll Coins.',
               r.property_id::text, v_due::text, v_wallet_coins::text),
        'open',
        r.property_id,
        v_due
      ) returning id into v_case_id;

      -- Evict property
      update public.trollstown_properties
      set is_evicted = true,
          evicted_at = now(),
          updated_at = now()
      where id = r.property_id;

      -- Public eviction record
      insert into public.trollstown_evictions(user_id, property_id, reason, rent_due)
      values (r.user_id, r.property_id, 'Failure to Pay Rent', v_due);

      user_id := r.user_id;
      property_id := r.property_id;
      rent_due := v_due;
      status := 'failed';
      deducted_amount := 0;
      court_case_id := v_case_id;
      return next;
    end if;
  end loop;

  return;
end;
$$;


ALTER FUNCTION "public"."trollstown_process_rent_cycle"("p_cycle_start" timestamp with time zone, "p_cycle_end" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trollstown_refresh_city_state"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare
  v_pop bigint;
  v_props bigint;
  v_cases bigint;
  v_stage int;
begin
  select count(*) into v_pop from auth.users;
  select count(*) into v_props from public.trollstown_properties where is_evicted = false;
  select count(*) into v_cases from public.trollcourt_cases where status = 'open';

  v_stage := public.trollstown_compute_stage(v_pop, v_props);

  -- upsert singleton row
  insert into public.trollstown_city_state(
    population_count, total_properties, active_court_cases, stage, updated_at
  ) values (v_pop, v_props, v_cases, v_stage, now())
  on conflict ((1)) do update
  set population_count = excluded.population_count,
      total_properties = excluded.total_properties,
      active_court_cases = excluded.active_court_cases,
      stage = excluded.stage,
      updated_at = now();
end;
$$;


ALTER FUNCTION "public"."trollstown_refresh_city_state"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."unban_ip_address"("p_ip_address" "inet", "p_officer_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_officer_profile user_profiles%ROWTYPE;
BEGIN
  SELECT * INTO v_officer_profile
  FROM user_profiles
  WHERE id = p_officer_id
    AND (
      is_admin = true
      OR is_troll_officer = true
      OR is_lead_officer = true
      OR role IN ('admin', 'troll_officer', 'lead_troll_officer')
    );

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'You do not have permission to unban IP addresses.'
    );
  END IF;

  UPDATE ip_bans
  SET
    is_active = false,
    updated_at = now()
  WHERE ip_address = p_ip_address
    AND is_active = true;

  RETURN jsonb_build_object(
    'success', true,
    'message', 'IP address unbanned successfully'
  );
END;
$$;


ALTER FUNCTION "public"."unban_ip_address"("p_ip_address" "inet", "p_officer_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."unban_ip_address"("p_ip_address" "inet", "p_officer_id" "uuid") IS 'Allows officers to unban IP addresses';



CREATE OR REPLACE FUNCTION "public"."unban_officer"("p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_officer RECORD;
  v_actor RECORD;
BEGIN
  -- Get actor (must be admin or lead officer)
  SELECT * INTO v_actor
  FROM user_profiles
  WHERE id = auth.uid()
    AND (role = 'admin' OR is_admin = true OR is_lead_officer = true);

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Only admins and lead officers can unban officers');
  END IF;

  -- Get officer to unban
  SELECT * INTO v_officer
  FROM user_profiles
  WHERE id = p_user_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', FALSE, 'error', 'Officer not found');
  END IF;

  -- Unban the officer
  UPDATE user_profiles
  SET 
    is_banned = FALSE,
    banned_until = NULL,
    updated_at = NOW()
  WHERE id = p_user_id;
  
  -- Remove ban reason from metadata if metadata column exists
  BEGIN
    UPDATE user_profiles
    SET metadata = COALESCE(metadata, '{}'::jsonb) - 'ban_reason'
    WHERE id = p_user_id;
  EXCEPTION WHEN OTHERS THEN
    -- metadata column might not exist, ignore
    NULL;
  END;

  -- Log the action (if officer_actions table exists)
  BEGIN
    INSERT INTO officer_actions (
      officer_id,
      target_user_id,
      action_type,
      reason
    ) VALUES (
      auth.uid(), -- The officer performing the action
      p_user_id,  -- The target officer being unbanned
      'unban',
      'Officer unbanned'
    );
  EXCEPTION WHEN OTHERS THEN
    -- Table might not exist or have different schema, ignore
    NULL;
  END;

  RETURN jsonb_build_object('success', TRUE, 'message', 'Officer unbanned successfully');
END;
$$;


ALTER FUNCTION "public"."unban_officer"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."unban_officer"("p_user_id" "uuid") IS 'Unbans an officer (lead officers and admins only)';



CREATE OR REPLACE FUNCTION "public"."update_abuse_reports_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_abuse_reports_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_admin_tax_reviews_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_admin_tax_reviews_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_battle_coins"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF NEW.gift_type = 'paid' THEN
    IF NEW.receiver_id = (SELECT host_id FROM troll_battles WHERE id = NEW.battle_id) THEN
      UPDATE troll_battles
      SET host_paid_coins = host_paid_coins + NEW.coins_spent,
          updated_at = now()
      WHERE id = NEW.battle_id;
    ELSIF NEW.receiver_id = (SELECT challenger_id FROM troll_battles WHERE id = NEW.battle_id) THEN
      UPDATE troll_battles
      SET challenger_paid_coins = challenger_paid_coins + NEW.coins_spent,
          updated_at = now()
      WHERE id = NEW.battle_id;
    END IF;
  ELSE
    IF NEW.receiver_id = (SELECT host_id FROM troll_battles WHERE id = NEW.battle_id) THEN
      UPDATE troll_battles
      SET host_free_coins = host_free_coins + NEW.coins_spent,
          updated_at = now()
      WHERE id = NEW.battle_id;
    ELSIF NEW.receiver_id = (SELECT challenger_id FROM troll_battles WHERE id = NEW.battle_id) THEN
      UPDATE troll_battles
      SET challenger_free_coins = challenger_free_coins + NEW.coins_spent,
          updated_at = now()
      WHERE id = NEW.battle_id;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_battle_coins"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_court_docket_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_court_docket_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_court_judge"("p_session_id" "text", "p_judge_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  UPDATE court_sessions
  SET judge_id = p_judge_id
  WHERE id = p_session_id::uuid;
END;
$$;


ALTER FUNCTION "public"."update_court_judge"("p_session_id" "text", "p_judge_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_creator_applications_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_creator_applications_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_creator_earnings"("p_user_id" "uuid", "p_amount_cents" integer, "p_year" integer, "p_month" integer) RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_total_year int;
BEGIN
  -- Update earnings...
  
  -- Get total for the year
  SELECT COALESCE(SUM(net_earnings_cents),0)
  INTO v_total_year
  FROM creator_earnings
  WHERE user_id = p_user_id AND year = p_year;

  -- üî• Only valid here, inside the function:
  IF v_total_year >= 60000 THEN
    INSERT INTO notifications (user_id, message, type)
    VALUES (
      p_user_id,
      'üìÑ You have reached $600 in earnings. Tax reporting required.',
      'warning'
    );
  END IF;

END;
$_$;


ALTER FUNCTION "public"."update_creator_earnings"("p_user_id" "uuid", "p_amount_cents" integer, "p_year" integer, "p_month" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_district_progress"("p_user_id" "uuid", "p_district_id" "uuid", "p_onboarding_completed" boolean DEFAULT NULL::boolean, "p_feature_explored" character varying DEFAULT NULL::character varying) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_progress RECORD;
BEGIN
  -- Get or create progress record
  SELECT * INTO v_progress
  FROM user_district_progress
  WHERE user_id = p_user_id AND district_id = p_district_id;

  IF NOT FOUND THEN
    -- Create new progress record
    INSERT INTO user_district_progress (
      user_id, district_id, onboarding_completed, features_explored, visit_count, last_visited_at
    ) VALUES (
      p_user_id, p_district_id,
      COALESCE(p_onboarding_completed, false),
      CASE WHEN p_feature_explored IS NOT NULL THEN ARRAY[p_feature_explored] ELSE ARRAY[]::TEXT[] END,
      1, NOW()
    );
  ELSE
    -- Update existing progress
    UPDATE user_district_progress
    SET
      onboarding_completed = COALESCE(p_onboarding_completed, onboarding_completed),
      features_explored = CASE
        WHEN p_feature_explored IS NOT NULL AND NOT (p_feature_explored = ANY(features_explored))
        THEN features_explored || p_feature_explored
        ELSE features_explored
      END,
      visit_count = visit_count + 1,
      last_visited_at = NOW(),
      updated_at = NOW()
    WHERE user_id = p_user_id AND district_id = p_district_id;
  END IF;

  RETURN jsonb_build_object('success', true, 'message', 'District progress updated');
END;
$$;


ALTER FUNCTION "public"."update_district_progress"("p_user_id" "uuid", "p_district_id" "uuid", "p_onboarding_completed" boolean, "p_feature_explored" character varying) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."update_district_progress"("p_user_id" "uuid", "p_district_id" "uuid", "p_onboarding_completed" boolean, "p_feature_explored" character varying) IS 'Updates user progress in a district (visits, onboarding completion, features explored)';



CREATE OR REPLACE FUNCTION "public"."update_empire_applications_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_empire_applications_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_hr_employees_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_hr_employees_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_interview_sessions_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_interview_sessions_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_job_applications_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_job_applications_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_officer_live_assignments_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_officer_live_assignments_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_officer_orientation_results_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_officer_orientation_results_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_officer_performance"("p_officer_id" "uuid", "p_score_change" integer, "p_event_type" character varying, "p_reason" "text" DEFAULT NULL::"text", "p_triggered_by" "uuid" DEFAULT NULL::"uuid", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    old_score INTEGER;
    new_score INTEGER;
    new_rating VARCHAR(20);
BEGIN
    -- Get current score
    SELECT current_score INTO old_score
    FROM officer_performance
    WHERE officer_id = p_officer_id;

    -- If no record exists, create one
    IF old_score IS NULL THEN
        INSERT INTO officer_performance (officer_id, current_score, lifetime_score)
        VALUES (p_officer_id, 100, 100);
        old_score := 100;
    END IF;

    -- Calculate new score (minimum 0)
    new_score := GREATEST(0, old_score + p_score_change);

    -- Determine rating based on score
    new_rating := CASE
        WHEN new_score >= 150 THEN 'elite'
        WHEN new_score >= 120 THEN 'excellent'
        WHEN new_score >= 90 THEN 'good'
        WHEN new_score >= 70 THEN 'standard'
        ELSE 'needs_improvement'
    END;

    -- Update performance record
    UPDATE officer_performance
    SET
        current_score = new_score,
        lifetime_score = lifetime_score + p_score_change,
        performance_rating = new_rating,
        updated_at = NOW()
    WHERE officer_id = p_officer_id;

    -- Log the performance event
    INSERT INTO reputation_events (
        target_id, reputation_type, event_type, score_change,
        previous_score, new_score, reason, triggered_by, metadata
    ) VALUES (
        p_officer_id, 'officer', p_event_type, p_score_change,
        old_score, new_score, p_reason, p_triggered_by, p_metadata
    );
END;
$$;


ALTER FUNCTION "public"."update_officer_performance"("p_officer_id" "uuid", "p_score_change" integer, "p_event_type" character varying, "p_reason" "text", "p_triggered_by" "uuid", "p_metadata" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_officer_promotion"("p_user_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE user_profiles
  SET
    role = 'troll_officer'::TEXT,
    is_troll_officer = TRUE,
    updated_at = NOW()
  WHERE id = p_user_id;
  
  RETURN FOUND;
END;
$$;


ALTER FUNCTION "public"."update_officer_promotion"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_officer_shift_logs_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_officer_shift_logs_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_officer_tier_badge"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF NEW.officer_level IS NOT NULL THEN
    NEW.officer_tier_badge := CASE
      WHEN NEW.officer_level = 1 THEN 'blue'
      WHEN NEW.officer_level = 2 THEN 'orange'
      WHEN NEW.officer_level = 3 THEN 'red'
      WHEN NEW.officer_level = 4 THEN 'purple'
      WHEN NEW.officer_level = 5 THEN 'gold'
      ELSE 'blue'
    END;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_officer_tier_badge"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_officer_work_sessions_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_officer_work_sessions_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_payment_logs_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_payment_logs_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_payout_requests_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_payout_requests_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_platform_revenue_on_payment"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_platform_fee DECIMAL(10, 2);
BEGIN
  IF NEW.status = 'COMPLETED' THEN

    -- Revenue
    INSERT INTO public.platform_revenue (date, total_revenue, transaction_count)
    VALUES (CURRENT_DATE, NEW.amount_usd, 1)
    ON CONFLICT (date) DO UPDATE
    SET
      total_revenue = public.platform_revenue.total_revenue + NEW.amount_usd,
      transaction_count = public.platform_revenue.transaction_count + 1,
      updated_at = NOW();

    -- Profit (example: 10% fee)
    v_platform_fee := NEW.amount_usd * 0.10;

    INSERT INTO public.platform_profit (date, total_profit, payment_count)
    VALUES (CURRENT_DATE, v_platform_fee, 1)
    ON CONFLICT (date) DO UPDATE
    SET
      total_profit = public.platform_profit.total_profit + v_platform_fee,
      payment_count = public.platform_profit.payment_count + 1,
      updated_at = NOW();

  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_platform_revenue_on_payment"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_post_engagement_counts"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  IF TG_TABLE_NAME = 'troll_post_comments' THEN
    UPDATE troll_posts
    SET comments_count = (
      SELECT COUNT(*) FROM troll_post_comments WHERE post_id = NEW.post_id
    )
    WHERE id = NEW.post_id;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_post_engagement_counts"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_provider_costs_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin
  new.updated_at = now();
  return new;
end;
$$;


ALTER FUNCTION "public"."update_provider_costs_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_royal_family_duration"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_title RECORD;
  v_duration_days INTEGER;
  v_current_perk_level INTEGER;
  v_updated_count INTEGER := 0;
BEGIN
  -- Update duration for all active titles
  FOR v_title IN
    SELECT id, user_id, admin_id, assigned_at
    FROM royal_family_titles
    WHERE is_active = true
    AND title_type IN ('wife', 'husband')
  LOOP
    -- Calculate duration in days
    v_duration_days := EXTRACT(EPOCH FROM (NOW() - v_title.assigned_at)) / 86400;

    -- Update duration
    UPDATE royal_family_titles
    SET duration_days = v_duration_days,
        updated_at = NOW()
    WHERE id = v_title.id;

    -- Get current perk level
    SELECT COALESCE(MAX(perk_level), 0) INTO v_current_perk_level
    FROM royal_family_perks
    WHERE title_id = v_title.id;

    -- Unlock perks based on duration tiers
    -- Tier 1: 7 days
    IF v_duration_days >= 7 AND v_current_perk_level < 1 THEN
      INSERT INTO royal_family_perks (title_id, perk_type, perk_level)
      VALUES
        (v_title.id, 'profile_glow', 1),
        (v_title.id, 'chat_highlight', 1);
      v_updated_count := v_updated_count + 1;
    END IF;

    -- Tier 2: 14 days
    IF v_duration_days >= 14 AND v_current_perk_level < 2 THEN
      INSERT INTO royal_family_perks (title_id, perk_type, perk_level)
      VALUES
        (v_title.id, 'gift_bonus', 2),
        (v_title.id, 'entrance_text', 2);
      v_updated_count := v_updated_count + 1;
    END IF;

    -- Tier 3: 30 days
    IF v_duration_days >= 30 AND v_current_perk_level < 3 THEN
      INSERT INTO royal_family_perks (title_id, perk_type, perk_level)
      VALUES
        (v_title.id, 'chat_badge', 3);
      v_updated_count := v_updated_count + 1;
    END IF;

    -- Tier 4: 60 days
    IF v_duration_days >= 60 AND v_current_perk_level < 4 THEN
      INSERT INTO royal_family_perks (title_id, perk_type, perk_level)
      VALUES
        (v_title.id, 'vip_panel', 4),
        (v_title.id, 'crown_upgrade', 4);
      v_updated_count := v_updated_count + 1;
    END IF;

    -- Tier 5: 90 days
    IF v_duration_days >= 90 AND v_current_perk_level < 5 THEN
      INSERT INTO royal_family_perks (title_id, perk_type, perk_level)
      VALUES
        (v_title.id, 'legacy_badge', 5);
      v_updated_count := v_updated_count + 1;
    END IF;
  END LOOP;

  RETURN v_updated_count;
END;
$$;


ALTER FUNCTION "public"."update_royal_family_duration"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."update_royal_family_duration"() IS 'Updates title durations and unlocks perks based on time held';



CREATE OR REPLACE FUNCTION "public"."update_seller_reliability"("p_seller_id" "uuid", "p_score_change" integer, "p_event_type" character varying, "p_reason" "text" DEFAULT NULL::"text", "p_triggered_by" "uuid" DEFAULT NULL::"uuid", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    old_score INTEGER;
    new_score INTEGER;
    new_tier VARCHAR(20);
BEGIN
    -- Get current score
    SELECT current_score INTO old_score
    FROM seller_reliability
    WHERE seller_id = p_seller_id;

    -- If no record exists, create one
    IF old_score IS NULL THEN
        INSERT INTO seller_reliability (seller_id, current_score, lifetime_score)
        VALUES (p_seller_id, 100, 100);
        old_score := 100;
    END IF;

    -- Calculate new score (minimum 0)
    new_score := GREATEST(0, old_score + p_score_change);

    -- Determine tier based on score
    new_tier := CASE
        WHEN new_score >= 150 THEN 'platinum'
        WHEN new_score >= 120 THEN 'gold'
        WHEN new_score >= 90 THEN 'silver'
        WHEN new_score >= 70 THEN 'standard'
        ELSE 'suspended'
    END;

    -- Update reliability record
    UPDATE seller_reliability
    SET
        current_score = new_score,
        lifetime_score = lifetime_score + p_score_change,
        reliability_tier = new_tier,
        is_high_risk = (new_score < 50),
        updated_at = NOW()
    WHERE seller_id = p_seller_id;

    -- Log the reliability event
    INSERT INTO reputation_events (
        target_id, reputation_type, event_type, score_change,
        previous_score, new_score, reason, triggered_by, metadata
    ) VALUES (
        p_seller_id, 'seller', p_event_type, p_score_change,
        old_score, new_score, p_reason, p_triggered_by, p_metadata
    );
END;
$$;


ALTER FUNCTION "public"."update_seller_reliability"("p_seller_id" "uuid", "p_score_change" integer, "p_event_type" character varying, "p_reason" "text", "p_triggered_by" "uuid", "p_metadata" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_stores_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_stores_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_stream_coins_from_gift"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  UPDATE public.streams
  SET total_gifts_coins = COALESCE(total_gifts_coins, 0) + NEW.coins_spent
  WHERE id = NEW.stream_id;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_stream_coins_from_gift"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_tax_status"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $_$
begin
  -- if user has earned ‚â• $600, mark as tax_required
  update public.profiles
  set tax_status = 'required',
      tax_last_updated = now()
  where id = new.user_id
  and (
    select sum(cash_amount)
    from payout_requests
    where user_id = new.user_id and status = 'paid'
  ) >= 600;

  return new;
end;
$_$;


ALTER FUNCTION "public"."update_tax_status"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_user_reputation"("p_user_id" "uuid", "p_score_change" integer, "p_event_type" character varying, "p_reason" "text" DEFAULT NULL::"text", "p_triggered_by" "uuid" DEFAULT NULL::"uuid", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    old_score INTEGER;
    new_score INTEGER;
    new_tier VARCHAR(20);
BEGIN
    -- Get current score
    SELECT current_score INTO old_score
    FROM user_reputation
    WHERE user_id = p_user_id;

    -- If no record exists, create one
    IF old_score IS NULL THEN
        INSERT INTO user_reputation (user_id, current_score, lifetime_score)
        VALUES (p_user_id, 100, 100);
        old_score := 100;
    END IF;

    -- Calculate new score (minimum 0)
    new_score := GREATEST(0, old_score + p_score_change);

    -- Update reputation record
    UPDATE user_reputation
    SET
        current_score = new_score,
        lifetime_score = lifetime_score + p_score_change,
        updated_at = NOW(),
        reputation_tier = CASE
            WHEN new_score >= 150 THEN 'excellent'
            WHEN new_score >= 100 THEN 'good'
            WHEN new_score >= 50 THEN 'warning'
            WHEN new_score >= 10 THEN 'poor'
            ELSE 'banned'
        END,
        is_escalation_priority = (new_score < 50)
    WHERE user_id = p_user_id;

    -- Update violation tracking based on event type
    IF p_event_type IN ('violation', 'court_outcome') THEN
        UPDATE user_reputation
        SET
            violations_count = violations_count + 1,
            last_violation_date = NOW()
        WHERE user_id = p_user_id;
    END IF;

    -- Log the reputation event
    INSERT INTO reputation_events (
        target_id, reputation_type, event_type, score_change,
        previous_score, new_score, reason, triggered_by, metadata
    ) VALUES (
        p_user_id, 'user', p_event_type, p_score_change,
        old_score, new_score, p_reason, p_triggered_by, p_metadata
    );
END;
$$;


ALTER FUNCTION "public"."update_user_reputation"("p_user_id" "uuid", "p_score_change" integer, "p_event_type" character varying, "p_reason" "text", "p_triggered_by" "uuid", "p_metadata" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_viewer_count"("p_stream_id" "uuid", "p_count" integer) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  UPDATE public.streams
  SET current_viewers = p_count
  WHERE id = p_stream_id;
END;
$$;


ALTER FUNCTION "public"."update_viewer_count"("p_stream_id" "uuid", "p_count" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_wallet_balance"("p_user_id" "uuid", "p_currency" "text", "p_amount" bigint, "p_reason" "text") RETURNS TABLE("troll_coins" bigint, "trollmods" bigint)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
begin

  -- enforce currency
  if p_currency not in ('troll_coins', 'trollmods') then
    raise exception 'Invalid currency. Only troll_coins and trollmods allowed.';
  end if;

  -- ensure wallet row exists
  insert into user_wallets(user_id, troll_coins, trollmods)
  values (p_user_id, 0, 0)
  on conflict (user_id) do nothing;

  -- apply update
  if p_currency = 'troll_coins' then
    update user_wallets
    set troll_coins = troll_coins + p_amount,
        updated_at = now()
    where user_id = p_user_id;

  elsif p_currency = 'trollmods' then
    update user_wallets
    set trollmods = trollmods + p_amount,
        updated_at = now()
    where user_id = p_user_id;
  end if;

  -- log transaction
  insert into wallet_transactions(user_id, type, currency, amount, reason, source)
  values (
    p_user_id,
    case when p_amount >= 0 then 'credit' else 'debit' end,
    p_currency,
    p_amount,
    p_reason,
    'syncsql'
  );

  -- return balances
  return query
  select uw.troll_coins, uw.trollmods
  from user_wallets uw
  where uw.user_id = p_user_id;

end;
$$;


ALTER FUNCTION "public"."update_wallet_balance"("p_user_id" "uuid", "p_currency" "text", "p_amount" bigint, "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_weekly_reports_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_weekly_reports_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."upgrade_property_slot"("p_property_id" "uuid", "p_upgrade_type" "text", "p_target_level" integer) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
DECLARE
  v_user_id UUID := auth.uid();
  v_current_level INTEGER;
  v_upgrade_cost INTEGER;
  v_user_coins INTEGER;
  v_new_value INTEGER;
  v_new_rent INTEGER;
  v_new_risk INTEGER;
BEGIN
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM public.trollstown_properties
    WHERE id = p_property_id AND user_id = v_user_id
  ) THEN
    RETURN jsonb_build_object('success', false, 'error', 'Property not found or does not belong to you');
  END IF;

  IF p_target_level < 1 OR p_target_level > 5 THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid upgrade level. Must be between 1 and 5');
  END IF;

  INSERT INTO public.trollstown_property_upgrades (property_id, user_id)
  VALUES (p_property_id, v_user_id)
  ON CONFLICT (property_id) DO NOTHING;

  SELECT CASE p_upgrade_type
      WHEN 'materials'  THEN materials_level
      WHEN 'furniture'  THEN furniture_level
      WHEN 'appliances' THEN appliances_level
      WHEN 'security'   THEN security_level
      ELSE NULL
    END
  INTO v_current_level
  FROM public.trollstown_property_upgrades
  WHERE property_id = p_property_id;

  IF v_current_level IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Invalid upgrade type');
  END IF;

  IF v_current_level >= p_target_level THEN
    RETURN jsonb_build_object('success', false, 'error', 'Already at this upgrade level or higher');
  END IF;

  SELECT cost_troll_coins
  INTO v_upgrade_cost
  FROM public.trollstown_upgrade_config
  WHERE upgrade_type = p_upgrade_type
    AND level = p_target_level;

  IF v_upgrade_cost IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Upgrade config missing for that level/type');
  END IF;

  SELECT paid_coin_balance
  INTO v_user_coins
  FROM public.user_profiles
  WHERE id = v_user_id;

  IF v_user_coins < v_upgrade_cost THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Insufficient Troll Coins',
      'required', v_upgrade_cost,
      'available', v_user_coins
    );
  END IF;

  UPDATE public.user_profiles
  SET paid_coin_balance = paid_coin_balance - v_upgrade_cost
  WHERE id = v_user_id;

  EXECUTE format(
    'UPDATE public.trollstown_property_upgrades
     SET %I_level = $1,
         updated_at = NOW(),
         last_upgraded_at = NOW()
     WHERE property_id = $2',
    p_upgrade_type
  )
  USING p_target_level, p_property_id;

  SELECT
    public.calculate_property_value(
      base_value,
      materials_level,
      furniture_level,
      appliances_level,
      security_level
    ),
    public.calculate_rent(
      base_rent,
      materials_level,
      furniture_level,
      appliances_level,
      security_level
    ),
    public.calculate_eviction_risk(
      materials_level,
      furniture_level,
      appliances_level,
      security_level
    )
  INTO v_new_value, v_new_rent, v_new_risk
  FROM public.trollstown_property_upgrades
  WHERE property_id = p_property_id;

  UPDATE public.trollstown_property_upgrades
  SET
    current_value = v_new_value,
    current_rent = v_new_rent,
    eviction_risk = v_new_risk
  WHERE property_id = p_property_id;

  RETURN jsonb_build_object(
    'success', true,
    'upgrade_type', p_upgrade_type,
    'new_level', p_target_level,
    'cost', v_upgrade_cost,
    'new_value', v_new_value,
    'new_rent', v_new_rent,
    'new_risk', v_new_risk,
    'remaining_coins', (v_user_coins - v_upgrade_cost)
  );
END;
$_$;


ALTER FUNCTION "public"."upgrade_property_slot"("p_property_id" "uuid", "p_upgrade_type" "text", "p_target_level" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."user_has_approved_trolltract"("p_user_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM creator_applications 
        WHERE user_id = p_user_id 
        AND status = 'approved' 
        AND is_trolltract_required = true
    );
END;
$$;


ALTER FUNCTION "public"."user_has_approved_trolltract"("p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_promo_code"("p_code" "text") RETURNS TABLE("id" "uuid", "code" "text", "discount_percent" integer, "is_active" boolean, "expiration_date" timestamp with time zone)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    pc.id,
    pc.code,
    pc.discount_percent,
    pc.is_active,
    pc.expiration_date
  FROM promo_codes pc
  WHERE pc.code = p_code
    AND pc.is_active = TRUE
    AND (pc.expiration_date IS NULL OR pc.expiration_date > NOW());

END;
$$;


ALTER FUNCTION "public"."validate_promo_code"("p_code" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_promo_code"("p_user_id" "uuid", "p_code" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_promo RECORD;
BEGIN
  -- Check promo
  SELECT *
  INTO v_promo
  FROM promo_codes
  WHERE code = p_code
    AND is_active = TRUE
    AND (expires_at IS NULL OR expires_at > NOW());

  IF v_promo IS NULL THEN
    RETURN jsonb_build_object(
      'success', FALSE,
      'error', 'Invalid or expired promo code'
    );
  END IF;

  -- Check if redeemed already
  IF EXISTS (
    SELECT 1 FROM promo_redemptions
    WHERE promo_id = v_promo.id
    AND user_id = p_user_id
  ) THEN
    RETURN jsonb_build_object(
      'success', FALSE,
      'error', 'Promo code already redeemed'
    );
  END IF;

  -- Award coins
  UPDATE user_profiles
  SET coins = coins + v_promo.coin_reward
  WHERE id = p_user_id;

  -- Log redemption
  INSERT INTO promo_redemptions (
    promo_id,
    user_id,
    redeemed_at
  ) VALUES (
    v_promo.id,
    p_user_id,
    NOW()
  );

  RETURN jsonb_build_object(
    'success', TRUE,
    'message', 'Promo code redeemed',
    'reward', v_promo.coin_reward
  );
END;
$$;


ALTER FUNCTION "public"."validate_promo_code"("p_user_id" "uuid", "p_code" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_promo_code"("p_code" "text", "p_original_price" numeric, "p_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  promo_record RECORD;
  usage_count INT;
  discounted_price NUMERIC;
BEGIN
  -- 1. Find promo code
  SELECT *
  INTO promo_record
  FROM promo_codes
  WHERE code = p_code;

  IF promo_record IS NULL THEN
    RETURN jsonb_build_object('valid', false, 'message', 'Invalid promo code');
  END IF;

  -- 2. Check expiration
  IF promo_record.expiry_date < NOW() THEN
    RETURN jsonb_build_object('valid', false, 'message', 'Promo code expired');
  END IF;

  -- 3. Check if user already used it
  SELECT COUNT(*)
  INTO usage_count
  FROM promo_code_usages
  WHERE user_id = p_user_id
    AND code = p_code;

  IF usage_count >= promo_record.max_uses_per_user THEN
    RETURN jsonb_build_object('valid', false, 'message', 'Promo code already used');
  END IF;

  -- 4. Apply discount (supports % or fixed)
  IF promo_record.discount_type = 'percentage' THEN
    discounted_price := p_original_price - (p_original_price * promo_record.discount_value / 100);
  ELSE
    discounted_price := p_original_price - promo_record.discount_value;
  END IF;

  IF discounted_price < 0 THEN
    discounted_price := 0;
  END IF;

  -- 5. Valid result
  RETURN jsonb_build_object(
    'valid', true,
    'message', 'Promo code applied',
    'discounted_price', discounted_price,
    'discount_type', promo_record.discount_type,
    'discount_value', promo_record.discount_value
  );
END;
$$;


ALTER FUNCTION "public"."validate_promo_code"("p_code" "text", "p_original_price" numeric, "p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_promo_code"("p_code" "text", "p_user_id" "uuid", "p_original_price" numeric) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_promo RECORD;
  v_user_is_empire_partner BOOLEAN;
  v_has_used_code BOOLEAN;
  v_discount_amount NUMERIC;
  v_final_price NUMERIC;
BEGIN
  -- Get promo code
  SELECT * INTO v_promo
  FROM promo_codes
  WHERE code = UPPER(TRIM(p_code))
    AND is_active = true
    AND (valid_until IS NULL OR valid_until > NOW())
    AND (valid_from IS NULL OR valid_from <= NOW());

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Invalid or expired promo code'
    );
  END IF;

  -- Check if user is empire partner (if required)
  IF v_promo.is_empire_partner_only THEN
    SELECT COALESCE(is_empire_partner, false) INTO v_user_is_empire_partner
    FROM user_profiles
    WHERE id = p_user_id;

    IF NOT v_user_is_empire_partner THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'This promo code is only available for Empire Partners'
      );
    END IF;
  END IF;

  -- Check max uses
  IF v_promo.max_uses IS NOT NULL AND v_promo.current_uses >= v_promo.max_uses THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'This promo code has reached its usage limit'
    );
  END IF;

  -- Check if user has already used this code (one-time use per user)
  SELECT EXISTS(
    SELECT 1 FROM promo_code_uses
    WHERE promo_code_id = v_promo.id AND user_id = p_user_id
  ) INTO v_has_used_code;

  IF v_has_used_code THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'You have already used this promo code'
    );
  END IF;

  -- Calculate discount
  IF v_promo.discount_percent > 0 THEN
    v_discount_amount := (p_original_price * v_promo.discount_percent / 100.0);
  ELSIF v_promo.discount_amount IS NOT NULL THEN
    v_discount_amount := LEAST(v_promo.discount_amount, p_original_price);
  ELSE
    v_discount_amount := 0;
  END IF;

  v_final_price := GREATEST(0, p_original_price - v_discount_amount);

  RETURN jsonb_build_object(
    'success', true,
    'promo_id', v_promo.id,
    'code', v_promo.code,
    'discount_percent', v_promo.discount_percent,
    'discount_amount', v_discount_amount,
    'original_price', p_original_price,
    'final_price', v_final_price
  );
END;
$$;


ALTER FUNCTION "public"."validate_promo_code"("p_code" "text", "p_user_id" "uuid", "p_original_price" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."verify_user"("p_user_id" "uuid", "p_payment_method" "text", "p_amount" numeric, "p_payment_reference" "text" DEFAULT NULL::"text") RETURNS json
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_current_status BOOLEAN;
BEGIN
  -- Get current verification status
  SELECT is_verified INTO v_current_status
  FROM user_profiles
  WHERE id = p_user_id;

  -- If already verified, return early
  IF v_current_status = TRUE THEN
    RETURN json_build_object('success', false, 'error', 'User already verified');
  END IF;

  -- Update user profile
  UPDATE user_profiles
  SET 
    is_verified = TRUE,
    verification_date = NOW(),
    verification_paid_amount = p_amount,
    verification_payment_method = p_payment_method,
    updated_at = NOW()
  WHERE id = p_user_id;

  -- Log transaction
  INSERT INTO verification_transactions (user_id, payment_method, amount, payment_reference, status)
  VALUES (p_user_id, p_payment_method, p_amount, p_payment_reference, 'completed');

  RETURN json_build_object('success', true, 'verified', TRUE);
END;
$$;


ALTER FUNCTION "public"."verify_user"("p_user_id" "uuid", "p_payment_method" "text", "p_amount" numeric, "p_payment_reference" "text") OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."abuse_reports" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "reported_by" "uuid" NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "offender_user_id" "uuid",
    "reason" "text" NOT NULL,
    "severity" integer DEFAULT 1,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "reviewed" boolean DEFAULT false
);

ALTER TABLE ONLY "public"."abuse_reports" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."abuse_reports" OWNER TO "postgres";


COMMENT ON TABLE "public"."abuse_reports" IS 'Reports submitted by officers about abusive behavior';



CREATE TABLE IF NOT EXISTS "public"."action_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "actor_id" "uuid",
    "target_id" "uuid",
    "action_type" "text" NOT NULL,
    "details" "jsonb" DEFAULT '{}'::"jsonb",
    "ip_address" "text",
    "user_agent" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_day" "date"
);


ALTER TABLE "public"."action_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."active_sessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "session_id" "uuid" NOT NULL,
    "device_info" "jsonb" DEFAULT '{}'::"jsonb",
    "ip_address" "text",
    "user_agent" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "last_active" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean DEFAULT true
);


ALTER TABLE "public"."active_sessions" OWNER TO "postgres";


COMMENT ON TABLE "public"."active_sessions" IS 'Tracks active user sessions to prevent concurrent logins from different devices';



CREATE TABLE IF NOT EXISTS "public"."activity_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "action" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "amount" numeric DEFAULT 0 NOT NULL
);

ALTER TABLE ONLY "public"."activity_log" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."activity_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."activity_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "target_user_id" "uuid",
    "action" "text" NOT NULL,
    "amount" numeric(12,2),
    "unit" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "gifter_id" "uuid",
    "receiver_id" "uuid"
);

ALTER TABLE ONLY "public"."activity_logs" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."activity_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."admin_adjustments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "admin_id" "uuid" NOT NULL,
    "target_user_id" "uuid" NOT NULL,
    "adjustment_type" "text" NOT NULL,
    "amount" integer NOT NULL,
    "reason" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "admin_adjustments_adjustment_type_check" CHECK (("adjustment_type" = ANY (ARRAY['paid_coins'::"text", 'free_coins'::"text"])))
);

ALTER TABLE ONLY "public"."admin_adjustments" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."admin_adjustments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."admin_broadcasts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "message" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone
);

ALTER TABLE ONLY "public"."admin_broadcasts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."admin_broadcasts" OWNER TO "postgres";


COMMENT ON TABLE "public"."admin_broadcasts" IS 'City-wide admin announcements broadcast to all live streams';



CREATE TABLE IF NOT EXISTS "public"."admin_coin_pool" (
    "id" boolean DEFAULT true NOT NULL,
    "troll_coins" bigint DEFAULT 0 NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."admin_coin_pool" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."admin_coin_revenue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "transaction_id" "text",
    "provider" "text" DEFAULT 'paypal'::"text" NOT NULL,
    "status" "text" DEFAULT 'completed'::"text" NOT NULL,
    "usd_amount" numeric(12,2) DEFAULT 0 NOT NULL,
    "coin_amount" integer DEFAULT 0 NOT NULL,
    "note" "text",
    "raw_payload" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "year" integer,
    "month" integer,
    "month_start" "date"
);

ALTER TABLE ONLY "public"."admin_coin_revenue" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."admin_coin_revenue" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."admin_flags" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."admin_flags" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."admin_flags" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."admin_gift_totals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "admin_id" "uuid" NOT NULL,
    "total_troll_coins" bigint DEFAULT 0,
    "last_gift_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."admin_gift_totals" OWNER TO "postgres";


COMMENT ON TABLE "public"."admin_gift_totals" IS 'Tracks cumulative paid coin gifts to admins for royal family qualification';



CREATE TABLE IF NOT EXISTS "public"."admin_pool" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "text" DEFAULT 'admin'::"text" NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "note" "text",
    "trollcoins_balance" bigint DEFAULT 0 NOT NULL,
    CONSTRAINT "admin_pool_role_check" CHECK (("role" = ANY (ARRAY['admin'::"text", 'moderator'::"text", 'super_admin'::"text"]))),
    CONSTRAINT "admin_pool_trollcoins_balance_nonnegative" CHECK (("trollcoins_balance" >= 0))
);


ALTER TABLE "public"."admin_pool" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."admin_tax_reviews" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "reviewer_id" "uuid",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."admin_tax_reviews" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."admin_tax_reviews" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."admin_top_buyers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "username" "text",
    "display_name" "text",
    "total_usd_spent" numeric(12,2) DEFAULT 0 NOT NULL,
    "total_coins_purchased" bigint DEFAULT 0 NOT NULL,
    "purchase_count" integer DEFAULT 0 NOT NULL,
    "last_purchase_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."admin_top_buyers" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."admin_top_buyers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_agreements" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "username" "text" NOT NULL,
    "email" "text",
    "agreement_version" "text" DEFAULT '1.0'::"text" NOT NULL,
    "terms_accepted" boolean DEFAULT true NOT NULL,
    "accepted_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "ip_address" "text",
    "user_agent" "text",
    "digital_signature" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "agreed_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."user_agreements" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_agreements" OWNER TO "postgres";


COMMENT ON TABLE "public"."user_agreements" IS 'Stores user agreement acceptances and digital signatures for Troll City';



COMMENT ON COLUMN "public"."user_agreements"."ip_address" IS 'IP address of the user when accepting the agreement';



COMMENT ON COLUMN "public"."user_agreements"."user_agent" IS 'Browser/device information when accepting the agreement';



COMMENT ON COLUMN "public"."user_agreements"."digital_signature" IS 'SHA256 hash of user_id + agreement_version + timestamp for verification';



CREATE OR REPLACE VIEW "public"."agreement_stats" WITH ("security_invoker"='true') AS
 SELECT "count"(*) AS "total_agreements",
    "count"(*) FILTER (WHERE ("accepted_at" >= CURRENT_DATE)) AS "accepted_today",
    "count"(*) FILTER (WHERE ("accepted_at" >= (CURRENT_DATE - '7 days'::interval))) AS "accepted_this_week",
    "round"(((("count"(*) FILTER (WHERE ("terms_accepted" = true)))::numeric / (NULLIF("count"(*), 0))::numeric) * (100)::numeric), 1) AS "compliance_rate_percent"
   FROM "public"."user_agreements";


ALTER VIEW "public"."agreement_stats" OWNER TO "postgres";


COMMENT ON VIEW "public"."agreement_stats" IS 'Statistics view for agreement compliance and acceptance metrics';



CREATE TABLE IF NOT EXISTS "public"."ai_action_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "context_type" "text" NOT NULL,
    "context_id" "uuid",
    "ai_output" "text" NOT NULL,
    "applied" boolean DEFAULT false,
    "applied_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "ai_action_logs_context_type_check" CHECK (("context_type" = ANY (ARRAY['court'::"text", 'interview'::"text", 'hr'::"text", 'moderation'::"text", 'admin'::"text"])))
);

ALTER TABLE ONLY "public"."ai_action_logs" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_action_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."app_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "setting_key" "text" NOT NULL,
    "setting_value" "jsonb",
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "key" "text",
    "value" "jsonb"
);

ALTER TABLE ONLY "public"."app_settings" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."app_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."app_updates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "cancelled" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."app_updates" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."app_updates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."applications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "type" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text",
    "reason" "text",
    "goals" "text",
    "data" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "reviewed_at" timestamp with time zone,
    "reviewed_by" "uuid",
    "role_applied" "text",
    "application_data" "jsonb" DEFAULT '{}'::"jsonb",
    "lead_officer_approved" boolean DEFAULT false NOT NULL,
    "lead_officer_approved_at" timestamp with time zone,
    "application_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "lead_officer_reviewed_at" timestamp with time zone,
    "lead_officer_reviewed_by" "uuid",
    "appeal_requested" boolean DEFAULT false NOT NULL,
    "appeal_message" "text",
    "appeal_submitted_at" timestamp with time zone,
    "appeal_status" "text" DEFAULT 'none'::"text" NOT NULL,
    "appeal_reviewed_at" timestamp with time zone,
    "appeal_reviewed_by" "uuid",
    "training_score" integer DEFAULT 0 NOT NULL,
    "training_completed" boolean DEFAULT false NOT NULL,
    "training_completed_at" timestamp with time zone,
    "training_required" boolean DEFAULT true NOT NULL,
    "training_attempts" integer DEFAULT 0 NOT NULL,
    "training_last_attempt_at" timestamp with time zone,
    "experience" "text",
    "experience_years" integer,
    "experience_level" "text",
    "portfolio_url" "text",
    "bio" "text",
    "training_passed" boolean DEFAULT false NOT NULL,
    "appeal_reason" "text",
    "appeal_requested_at" timestamp with time zone,
    "appeal_notes" "text",
    "contact_email" "text",
    "product_types" "text"[] DEFAULT '{}'::"text"[] NOT NULL,
    "store_description" "text",
    "store_name" "text",
    CONSTRAINT "applications_appeal_status_check" CHECK (("appeal_status" = ANY (ARRAY['none'::"text", 'pending'::"text", 'approved'::"text", 'denied'::"text"]))),
    CONSTRAINT "applications_role_applied_check" CHECK (("role_applied" = ANY (ARRAY['lead_troll_officer'::"text", 'troll_officer'::"text", 'troller'::"text"])))
);

ALTER TABLE ONLY "public"."applications" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."applications" OWNER TO "postgres";


COMMENT ON TABLE "public"."applications" IS 'All user applications including lead officer, troll officer, troller, and family';



CREATE TABLE IF NOT EXISTS "public"."badge_definitions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "badge_type" "text" NOT NULL,
    "level" integer NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "icon_url" "text",
    "required_xp" bigint DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."badge_definitions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."badge_definitions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."balance_ledger" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "currency" "text" NOT NULL,
    "amount" bigint NOT NULL,
    "event" "text" NOT NULL,
    "source" "text" DEFAULT 'syncsql'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "balance_ledger_currency_check" CHECK (("currency" = ANY (ARRAY['troll_coins'::"text", 'trollmods'::"text"])))
);

ALTER TABLE ONLY "public"."balance_ledger" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."balance_ledger" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_participants" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid",
    "user_id" "uuid",
    "username" "text",
    "joined_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "left_at" timestamp with time zone,
    "is_active" boolean DEFAULT true NOT NULL,
    "slot" integer
);

ALTER TABLE ONLY "public"."stream_participants" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_participants" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_battles" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "host_id" "uuid",
    "challenger_id" "uuid",
    "start_time" timestamp with time zone,
    "end_time" timestamp with time zone,
    "winner_id" "uuid",
    "status" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "host_troll_coins" bigint DEFAULT 0 NOT NULL,
    "challenger_troll_coins" bigint DEFAULT 0 NOT NULL,
    "broadcaster1_id" "uuid",
    "broadcaster2_id" "uuid",
    "host_stream_id" "uuid",
    "challenger_stream_id" "uuid",
    CONSTRAINT "troll_battles_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'active'::"text", 'completed'::"text"])))
);

ALTER TABLE ONLY "public"."troll_battles" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_battles" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."battle_arena_view" WITH ("security_invoker"='true') AS
 SELECT "id",
    "host_id",
    "challenger_id",
    "start_time",
    "end_time",
    "winner_id",
    "status",
    "created_at",
    "host_troll_coins",
    "challenger_troll_coins",
    "broadcaster1_id",
    "broadcaster2_id",
    "host_stream_id",
    "challenger_stream_id",
    ( SELECT "json_agg"("sp".* ORDER BY "sp"."joined_at") AS "json_agg"
           FROM "public"."stream_participants" "sp"
          WHERE (("sp"."stream_id" = "tb"."host_stream_id") AND ("sp"."is_active" = true))) AS "host_guests",
    ( SELECT "json_agg"("sp2".* ORDER BY "sp2"."joined_at") AS "json_agg"
           FROM "public"."stream_participants" "sp2"
          WHERE (("sp2"."stream_id" = "tb"."challenger_stream_id") AND ("sp2"."is_active" = true))) AS "challenger_guests"
   FROM "public"."troll_battles" "tb";


ALTER VIEW "public"."battle_arena_view" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."battle_gifts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "battle_id" "uuid" NOT NULL,
    "sender_id" "uuid" NOT NULL,
    "receiver_id" "uuid" NOT NULL,
    "coins_spent" bigint NOT NULL,
    "gift_type" "text" NOT NULL,
    "gift_name" "text",
    "message" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "coin_amount" integer NOT NULL,
    CONSTRAINT "battle_gifts_gift_type_check" CHECK (("gift_type" = ANY (ARRAY['paid'::"text", 'free'::"text"])))
);

ALTER TABLE ONLY "public"."battle_gifts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."battle_gifts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."battle_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "battle_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "opponent_id" "uuid" NOT NULL,
    "won" boolean NOT NULL,
    "paid_coins_received" bigint DEFAULT 0 NOT NULL,
    "paid_coins_sent" bigint DEFAULT 0 NOT NULL,
    "battle_duration_seconds" integer,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."battle_history" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."battle_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."battle_rewards" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "battle_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "reward_type" "text" NOT NULL,
    "reward_value" numeric(10,2),
    "badge_name" "text",
    "expires_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "battle_rewards_reward_type_check" CHECK (("reward_type" = ANY (ARRAY['trophy'::"text", 'coin_multiplier'::"text", 'badge'::"text"])))
);

ALTER TABLE ONLY "public"."battle_rewards" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."battle_rewards" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."battle_sessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid",
    "opponent_stream_id" "uuid",
    "host_id" "uuid",
    "opponent_id" "uuid",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "start_at" timestamp with time zone,
    "end_at" timestamp with time zone,
    "duration_seconds" integer,
    "host_score" bigint DEFAULT 0 NOT NULL,
    "opponent_score" bigint DEFAULT 0 NOT NULL,
    "winner_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."battle_sessions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."battle_sessions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."blocked_users" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "blocker_id" "uuid" NOT NULL,
    "blocked_id" "uuid" NOT NULL,
    "blocked_name" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."blocked_users" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."blocked_users" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."broadcast_background_themes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "slug" "text" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "preview_url" "text",
    "background_type" "text" DEFAULT 'image'::"text" NOT NULL,
    "background_asset_url" "text",
    "background_css" "text",
    "price_coins" integer DEFAULT 0 NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "rarity" "text",
    "sort_order" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "asset_type" "text",
    "video_webm_url" "text",
    "video_mp4_url" "text",
    "image_url" "text",
    "reactive_enabled" boolean DEFAULT false NOT NULL,
    "reactive_style" "text" DEFAULT 'none'::"text" NOT NULL,
    "reactive_intensity" real DEFAULT 0.5 NOT NULL,
    CONSTRAINT "broadcast_background_themes_reactive_intensity_range" CHECK ((("reactive_intensity" >= (0)::double precision) AND ("reactive_intensity" <= (1)::double precision)))
);


ALTER TABLE "public"."broadcast_background_themes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."broadcast_cycle_stats" (
    "cycle_start" timestamp with time zone NOT NULL,
    "cycle_end" timestamp with time zone NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "broadcaster_id" "uuid" NOT NULL,
    "live_viewers" integer DEFAULT 0 NOT NULL,
    "paid_coins_received" bigint DEFAULT 0 NOT NULL,
    "chat_messages" bigint DEFAULT 0 NOT NULL,
    "reactions" bigint DEFAULT 0 NOT NULL,
    "popularity_score" numeric(18,2) DEFAULT 0 NOT NULL,
    "computed_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "broadcast_cycle_stats_chat_messages_check" CHECK (("chat_messages" >= 0)),
    CONSTRAINT "broadcast_cycle_stats_live_viewers_check" CHECK (("live_viewers" >= 0)),
    CONSTRAINT "broadcast_cycle_stats_paid_coins_received_check" CHECK (("paid_coins_received" >= 0)),
    CONSTRAINT "broadcast_cycle_stats_reactions_check" CHECK (("reactions" >= 0))
);

ALTER TABLE ONLY "public"."broadcast_cycle_stats" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."broadcast_cycle_stats" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."broadcast_seats" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid",
    "seat_index" integer NOT NULL,
    "user_id" "uuid",
    "status" "text" DEFAULT 'open'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "room" "text",
    "username" "text",
    "avatar_url" "text",
    "role" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "assigned_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "broadcast_seats_seat_index_check" CHECK ((("seat_index" >= 1) AND ("seat_index" <= 5))),
    CONSTRAINT "broadcast_seats_status_check" CHECK (("status" = ANY (ARRAY['open'::"text", 'reserved'::"text", 'live'::"text", 'closed'::"text"])))
);

ALTER TABLE ONLY "public"."broadcast_seats" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."broadcast_seats" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."broadcast_seat_bans" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "room" "text" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "banned_until" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid",
    "reason" "text",
    CONSTRAINT "broadcast_seat_bans_pkey" PRIMARY KEY ("id")
);

ALTER TABLE "public"."broadcast_seat_bans" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."broadcast_theme_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "theme_id" "uuid" NOT NULL,
    "event_type" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "broadcaster_id" "uuid",
    "payload" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "room_id" "uuid"
);


ALTER TABLE "public"."broadcast_theme_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."broadcast_tokens" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "token" "text" NOT NULL,
    "role" "text" DEFAULT 'viewer'::"text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."broadcast_tokens" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."broadcast_tokens" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."broadcaster_applications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "full_name" "text" NOT NULL,
    "email" "text" NOT NULL,
    "phone" "text",
    "country" "text",
    "date_of_birth" "date",
    "tax_form_status" "text" DEFAULT 'pending'::"text",
    "id_verification_status" "text" DEFAULT 'pending'::"text",
    "ssn_last4" "text",
    "document_upload_url" "text",
    "ban_status" boolean DEFAULT false,
    "application_status" "text" DEFAULT 'pending'::"text",
    "rejection_reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "reviewed_at" timestamp with time zone,
    "reviewed_by" "uuid",
    "kyc_provider" "text",
    "kyc_session_id" "text",
    "kyc_status" "text" DEFAULT 'pending'::"text",
    "tax_status" "text" DEFAULT 'pending'::"text",
    "ein_last4" "text",
    "w9_form_url" "text",
    "country_code" "text",
    "is_us_person" boolean DEFAULT true,
    "address" "text",
    "bank_routing_number" "text",
    "bank_holder_name" "text",
    "bank_account_type" "text",
    "bank_country" "text",
    "bank_verified" boolean DEFAULT false,
    "bank_account_last_four" "text",
    "ein" "text",
    "id_verification_submitted" boolean DEFAULT false,
    "id_verification_url" "text",
    "is_business" boolean DEFAULT false,
    "ssn_last_four" "text",
    "tax_form_submitted" boolean DEFAULT false,
    "tax_form_url" "text",
    "username" "text",
    "status" "text" DEFAULT 'pending'::"text",
    "reviewer_id" "uuid",
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."broadcaster_applications" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."broadcaster_applications" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."broadcaster_earnings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "broadcaster_id" "uuid",
    "gift_id" "uuid",
    "coins_received" integer NOT NULL,
    "usd_value" numeric(10,2),
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."broadcaster_earnings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."broadcaster_metrics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "viewers" integer DEFAULT 0 NOT NULL,
    "peak_viewers" integer DEFAULT 0 NOT NULL,
    "coins_today" bigint DEFAULT 0 NOT NULL,
    "gifts_count" integer DEFAULT 0 NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."broadcaster_metrics" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."broadcaster_metrics" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."call_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "caller_id" "uuid" NOT NULL,
    "receiver_id" "uuid" NOT NULL,
    "room_id" "text" NOT NULL,
    "type" "text" NOT NULL,
    "duration_minutes" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "ended_at" timestamp with time zone,
    CONSTRAINT "call_history_duration_minutes_check" CHECK (("duration_minutes" >= 0)),
    CONSTRAINT "call_history_type_check" CHECK (("type" = ANY (ARRAY['audio'::"text", 'video'::"text"])))
);

ALTER TABLE ONLY "public"."call_history" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."call_history" OWNER TO "postgres";


COMMENT ON TABLE "public"."call_history" IS 'Stores call history records';



CREATE TABLE IF NOT EXISTS "public"."call_minutes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "audio_minutes" integer DEFAULT 0 NOT NULL,
    "video_minutes" integer DEFAULT 0 NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "call_minutes_audio_minutes_check" CHECK (("audio_minutes" >= 0)),
    CONSTRAINT "call_minutes_video_minutes_check" CHECK (("video_minutes" >= 0))
);

ALTER TABLE ONLY "public"."call_minutes" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."call_minutes" OWNER TO "postgres";


COMMENT ON TABLE "public"."call_minutes" IS 'Stores call minute balances for users';



CREATE TABLE IF NOT EXISTS "public"."call_sessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "call_type" "text" NOT NULL,
    "status" "text" DEFAULT 'active'::"text",
    "room_name" "text" NOT NULL,
    "caller_id" "uuid" NOT NULL,
    "caller_name" "text",
    "caller_token" "text",
    "receiver_id" "uuid" NOT NULL,
    "receiver_name" "text",
    "receiver_token" "text",
    "minutes_used" integer DEFAULT 0,
    "started_at" timestamp with time zone,
    "ended_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."call_sessions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."call_sessions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."call_sound_catalog" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "slug" "text" NOT NULL,
    "name" "text" NOT NULL,
    "sound_type" "text" NOT NULL,
    "asset_url" "text" NOT NULL,
    "price_coins" integer DEFAULT 0 NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."call_sound_catalog" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."call_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "call_session_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "call_type" "text" NOT NULL,
    "type" "text" NOT NULL,
    "minutes" integer NOT NULL,
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."call_transactions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."call_transactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."case_audit_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "case_id" "uuid",
    "actor_id" "uuid",
    "action" "text" NOT NULL,
    "details" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."case_audit_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."case_evidence" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "case_id" "uuid",
    "uploader_id" "uuid",
    "evidence_type" "text" NOT NULL,
    "url" "text",
    "description" "text",
    "is_verified" boolean DEFAULT false,
    "verified_by" "uuid",
    "weight" "text" DEFAULT 'Medium'::"text",
    "notes" "text",
    "is_locked" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "case_evidence_evidence_type_check" CHECK (("evidence_type" = ANY (ARRAY['screenshot'::"text", 'video'::"text", 'chat_log'::"text", 'transaction_log'::"text", 'livestream_timestamp'::"text", 'profile_link'::"text", 'witness_statement'::"text", 'other'::"text"]))),
    CONSTRAINT "case_evidence_weight_check" CHECK (("weight" = ANY (ARRAY['Strong'::"text", 'Medium'::"text", 'Weak'::"text"])))
);


ALTER TABLE "public"."case_evidence" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."case_participants" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "case_id" "uuid",
    "user_id" "uuid",
    "role" "text" NOT NULL,
    "permissions" "jsonb" DEFAULT '{}'::"jsonb",
    "joined_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "case_participants_role_check" CHECK (("role" = ANY (ARRAY['Plaintiff'::"text", 'Defendant'::"text", 'Witness'::"text", 'Jury'::"text", 'Officer'::"text", 'Spectator'::"text", 'Judge'::"text"])))
);


ALTER TABLE "public"."case_participants" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."case_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "case_type" "text" NOT NULL,
    "default_severity" "text" NOT NULL,
    "required_evidence_types" "text"[] DEFAULT '{}'::"text"[],
    "recommended_sanctions" "jsonb" DEFAULT '[]'::"jsonb",
    "default_questions" "text"[] DEFAULT '{}'::"text"[],
    "suggested_actions" "jsonb" DEFAULT '[]'::"jsonb",
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "case_templates_default_severity_check" CHECK (("default_severity" = ANY (ARRAY['Low'::"text", 'Medium'::"text", 'High'::"text", 'Critical'::"text"])))
);


ALTER TABLE "public"."case_templates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."cashout_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "coin_amount" integer NOT NULL,
    "cash_amount" numeric NOT NULL,
    "currency" "text" DEFAULT 'USD'::"text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "provider" "text" DEFAULT 'square'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "email" "text",
    "eligible" boolean DEFAULT false,
    "hold_until" timestamp with time zone,
    "rejected_reason" "text",
    "tax_form_status" "text" DEFAULT 'unknown'::"text",
    "gift_card_provider" "text" DEFAULT 'Visa'::"text",
    "delivery_method" "text" DEFAULT 'App Delivery'::"text",
    "gift_card_code" "text",
    "gift_card_number" "text",
    "gift_card_cvv" "text",
    "gift_card_expiry" "text",
    "security_checks_passed" boolean DEFAULT false,
    "processing_time_estimate" "text" DEFAULT 'Under 30 minutes'::"text",
    "username" "text",
    "requested_at" timestamp with time zone DEFAULT "now"(),
    "fee_applied" numeric(12,2),
    "usd_after_fee" numeric(12,2),
    "transaction_ref" "text"
);

ALTER TABLE ONLY "public"."cashout_requests" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."cashout_requests" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."cashout_tiers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "coin_amount" bigint NOT NULL,
    "cash_amount" numeric(12,2) NOT NULL,
    "currency" "text" DEFAULT 'USD'::"text",
    "processing_fee_percentage" numeric(6,2) DEFAULT 0,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."cashout_tiers" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."cashout_tiers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."city_districts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" character varying(100) NOT NULL,
    "display_name" character varying(100) NOT NULL,
    "description" "text",
    "icon" character varying(50) DEFAULT 'MapPin'::character varying,
    "color" character varying(20) DEFAULT '#6366f1'::character varying,
    "background_image_url" "text",
    "required_role" character varying(50) DEFAULT 'user'::character varying,
    "required_permissions" "text"[],
    "is_active" boolean DEFAULT true,
    "sort_order" integer DEFAULT 0,
    "features" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."city_districts" OWNER TO "postgres";


COMMENT ON TABLE "public"."city_districts" IS 'Districts/areas within Troll City with role-based access';



CREATE TABLE IF NOT EXISTS "public"."city_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "event_type" character varying(50) NOT NULL,
    "title" character varying(200) NOT NULL,
    "description" "text",
    "start_time" timestamp with time zone NOT NULL,
    "end_time" timestamp with time zone NOT NULL,
    "is_active" boolean DEFAULT false,
    "global_announcement" boolean DEFAULT false,
    "banner_image_url" "text",
    "event_config" "jsonb" DEFAULT '{}'::"jsonb",
    "rewards_config" "jsonb" DEFAULT '{}'::"jsonb",
    "participation_count" integer DEFAULT 0,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."city_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."clan_rewards" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid" NOT NULL,
    "reward_type" "text" NOT NULL,
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."clan_rewards" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."clan_rewards" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."clan_vault" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid" NOT NULL,
    "balance" integer DEFAULT 0 NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."clan_vault" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."clan_vault" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."coin_audit_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "item_id" "uuid",
    "action" "text" NOT NULL,
    "amount" integer DEFAULT 0 NOT NULL,
    "note" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "details" "jsonb"
);


ALTER TABLE "public"."coin_audit_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."coin_ledger" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "counterparty_id" "uuid",
    "type" "text" NOT NULL,
    "direction" "text" NOT NULL,
    "coin_type" "text" DEFAULT 'paid'::"text" NOT NULL,
    "coins" bigint DEFAULT 0 NOT NULL,
    "amount_usd" numeric(12,2),
    "meta" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "amount_coins" integer DEFAULT 0,
    CONSTRAINT "coin_ledger_coin_type_check" CHECK (("coin_type" = ANY (ARRAY['paid'::"text", 'free'::"text"]))),
    CONSTRAINT "coin_ledger_direction_check" CHECK (("direction" = ANY (ARRAY['credit'::"text", 'debit'::"text"])))
);

ALTER TABLE ONLY "public"."coin_ledger" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."coin_ledger" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."coin_packages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "coins" integer NOT NULL,
    "price_usd" numeric(10,2) NOT NULL,
    "paypal_sku" "text" NOT NULL,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."coin_packages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."coin_pool_contributions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "sender_id" "uuid" NOT NULL,
    "gift_id" "uuid",
    "base_paid_coins" bigint NOT NULL,
    "contributed_troll_coins" bigint NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "trollmonds_pool_contributions_base_paid_coins_check" CHECK (("base_paid_coins" > 0)),
    CONSTRAINT "trollmonds_pool_contributions_contributed_trollmonds_check" CHECK (("contributed_troll_coins" >= 0))
);

ALTER TABLE ONLY "public"."coin_pool_contributions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."coin_pool_contributions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."coin_purchases" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "coins" bigint NOT NULL,
    "amount" numeric(12,2),
    "order_id" "text",
    "status" "text" DEFAULT 'completed'::"text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."coin_purchases" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."coin_purchases" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."coin_reward_pool" (
    "pool_key" "text" NOT NULL,
    "balance" bigint DEFAULT 0 NOT NULL,
    "last_updated" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "coin_reward_pool_balance_check" CHECK (("balance" >= 0))
);

ALTER TABLE ONLY "public"."coin_reward_pool" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."coin_reward_pool" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."coin_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "type" "text" DEFAULT 'unknown'::"text" NOT NULL,
    "amount" integer DEFAULT 0 NOT NULL,
    "description" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "source_type" "text",
    "source_id" "text",
    "balance_after" integer,
    "referral_reward" boolean DEFAULT false,
    "coin_amount" integer DEFAULT 0,
    "gift_name" "text",
    "coins_awarded" integer,
    "usd_amount" numeric(10,2),
    "transaction_date" timestamp with time zone DEFAULT "now"(),
    "source" "text",
    "status" "text" DEFAULT 'completed'::"text",
    "paypal_order_id" "text",
    "paypal_transaction_id" "text",
    "external_id" "text",
    "payer_email" "text",
    "payment_status" "text",
    "payment_method" "text",
    "coin_type" "text" DEFAULT 'paid'::"text" NOT NULL,
    "from_user_id" "uuid",
    "from_user_name" "text",
    "to_user_id" "uuid",
    "to_user_name" "text",
    "broadcaster_share" bigint DEFAULT 0,
    "app_share" bigint DEFAULT 0,
    "coins" bigint,
    "battle_id" "uuid",
    "coin_delta" integer DEFAULT 0 NOT NULL,
    "notes" "text" DEFAULT ''::"text",
    "platform_profit" numeric(12,2) DEFAULT 0,
    "liability" numeric(12,2) DEFAULT 0,
    "paypal_capture_id" "text",
    CONSTRAINT "coin_transactions_coin_type_check" CHECK (("coin_type" = ANY (ARRAY['paid'::"text", 'free'::"text", 'troll_coins'::"text"]))),
    CONSTRAINT "coin_transactions_source_check" CHECK (("source" = ANY (ARRAY['purchase'::"text", 'gift'::"text", 'wheel'::"text", 'bonus'::"text"]))),
    CONSTRAINT "coin_transactions_type_check" CHECK (("type" = ANY (ARRAY['store_purchase'::"text", 'wheel_spin'::"text", 'perk_purchase'::"text", 'admin_adjustment'::"text", 'reward'::"text", 'entrance_effect'::"text", 'gift'::"text", 'purchase'::"text", 'insurance_purchase'::"text", 'broadcast_theme_purchase'::"text", 'call_sound_purchase'::"text"])))
);

ALTER TABLE ONLY "public"."coin_transactions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."coin_transactions" OWNER TO "postgres";


COMMENT ON TABLE "public"."coin_transactions" IS 'Master log of all coin movements in the system';



COMMENT ON COLUMN "public"."coin_transactions"."type" IS 'Transaction type: purchase, gift, spin, cashout, etc';



COMMENT ON COLUMN "public"."coin_transactions"."amount" IS 'Number of coins - positive for credits (added), negative for debits (spent)';



COMMENT ON COLUMN "public"."coin_transactions"."metadata" IS 'JSON object with transaction-specific details (payment_id, package_id, etc)';



COMMENT ON COLUMN "public"."coin_transactions"."balance_after" IS 'Total coin balance (paid + free) snapshot after this transaction';



COMMENT ON COLUMN "public"."coin_transactions"."paypal_order_id" IS 'Unique PayPal Order ID to prevent duplicate processing';



COMMENT ON COLUMN "public"."coin_transactions"."external_id" IS 'External payment provider transaction/capture ID';



COMMENT ON COLUMN "public"."coin_transactions"."coin_type" IS 'paid (purchased) or free (promotional)';



COMMENT ON COLUMN "public"."coin_transactions"."platform_profit" IS 'Platform revenue in USD (after payment processor fees)';



COMMENT ON COLUMN "public"."coin_transactions"."liability" IS 'Platform liability in USD (coins that could be cashed out)';



CREATE TABLE IF NOT EXISTS "public"."coinback_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "source" "text" NOT NULL,
    "base_paid_coins" bigint NOT NULL,
    "bonus_coins" bigint NOT NULL,
    "related_gift_id" "uuid",
    "related_external_id" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "coinback_log_base_paid_coins_check" CHECK (("base_paid_coins" >= 0)),
    CONSTRAINT "coinback_log_bonus_coins_check" CHECK (("bonus_coins" >= 0)),
    CONSTRAINT "coinback_log_source_check" CHECK (("source" = ANY (ARRAY['gift_send'::"text", 'coin_purchase'::"text"])))
);

ALTER TABLE ONLY "public"."coinback_log" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."coinback_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."config" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "key" "text" NOT NULL,
    "value" "text",
    "description" "text",
    "category" "text",
    "is_public" boolean DEFAULT false NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."config" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."config" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."content" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "creatorid" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "thumbnailurl" "text",
    "videourl" "text" NOT NULL,
    "contenttype" "text" NOT NULL,
    "published" boolean DEFAULT false,
    "createdat" timestamp without time zone DEFAULT "now"(),
    "totalcoinsearned" integer DEFAULT 0,
    "totalgiftsreceived" integer DEFAULT 0,
    "isfeatured" boolean DEFAULT false,
    "featuredat" timestamp without time zone,
    "istrendingeligible" boolean DEFAULT true,
    CONSTRAINT "content_contenttype_check" CHECK (("contenttype" = ANY (ARRAY['short'::"text", 'movie'::"text"])))
);

ALTER TABLE ONLY "public"."content" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."content" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."conversation_members" (
    "conversation_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "text" DEFAULT 'member'::"text" NOT NULL,
    "joined_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."conversation_members" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."conversation_messages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "conversation_id" "uuid" NOT NULL,
    "sender_id" "uuid" NOT NULL,
    "body" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."conversation_messages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."conversations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid"
);


ALTER TABLE "public"."conversations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."court_ai_messages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
    "case_id" "uuid",
    "session_id" "uuid",
    "role" "text" NOT NULL,
    "content" "text" NOT NULL,
    "meta" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "court_ai_messages_role_check" CHECK (("role" = ANY (ARRAY['user'::"text", 'assistant'::"text", 'system'::"text"])))
);


ALTER TABLE "public"."court_ai_messages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."court_box_members" (
    "session_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."court_box_members" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."court_box_members" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."court_cases" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "status" "text" DEFAULT 'waiting'::"text" NOT NULL,
    "judge_id" "uuid",
    "defendant_id" "uuid",
    "title" "text",
    "charges" "text",
    "notes" "text",
    "started_at" timestamp with time zone,
    "ended_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "accuser" "uuid",
    "defendant" "uuid",
    "description" "text",
    "evidence" "jsonb",
    "startedAt" timestamp with time zone,
    "witnesses" "jsonb",
    "plaintiff_id" "uuid",
    "case_type" "text",
    CONSTRAINT "court_cases_status_check" CHECK (("status" = ANY (ARRAY['waiting'::"text", 'in_session'::"text", 'adjourned'::"text"])))
);

ALTER TABLE ONLY "public"."court_cases" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."court_cases" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."court_docket" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "case_type" "text" NOT NULL,
    "scheduled_at" timestamp with time zone NOT NULL,
    "status" "text" DEFAULT 'scheduled'::"text" NOT NULL,
    "assigned_officer" "uuid",
    "notes" "text",
    "court_session_id" "uuid",
    "appeal_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "missed_at" timestamp with time zone,
    CONSTRAINT "court_docket_case_type_check" CHECK (("case_type" = ANY (ARRAY['violation'::"text", 'appeal'::"text", 'complaint'::"text", 'other'::"text"]))),
    CONSTRAINT "court_docket_status_check" CHECK (("status" = ANY (ARRAY['scheduled'::"text", 'in_session'::"text", 'completed'::"text", 'missed'::"text", 'dismissed'::"text"])))
);


ALTER TABLE "public"."court_docket" OWNER TO "postgres";


COMMENT ON TABLE "public"."court_docket" IS 'Court docket system for managing scheduled court cases and hearings';



CREATE TABLE IF NOT EXISTS "public"."court_rulings_archive" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "court_session_id" "uuid",
    "case_type" character varying(50) NOT NULL,
    "severity_level" integer NOT NULL,
    "ruling" character varying(50) NOT NULL,
    "consequence_applied" character varying(100),
    "duration_applied" character varying(100),
    "reasoning_summary" "text",
    "precedent_citation" "text",
    "judge_notes" "text",
    "is_public" boolean DEFAULT true,
    "appeal_status" character varying(20) DEFAULT 'none'::character varying,
    "appealed_ruling_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."court_rulings_archive" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."court_schedules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "case_id" "uuid",
    "defendant_user_id" "uuid",
    "defendant_name" "text",
    "judge_officer_id" "uuid",
    "judge_officer_name" "text",
    "scheduled_date" timestamp with time zone NOT NULL,
    "required_coins" bigint DEFAULT 0,
    "officer_stream_active" boolean DEFAULT false,
    "status" "text" DEFAULT 'scheduled'::"text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."court_schedules" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."court_schedules" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."creator_earnings" WITH ("security_invoker"='true') AS
 SELECT "u"."id" AS "user_id",
    "u"."username",
    "u"."total_earned_coins",
    "count"("ct"."id") AS "gift_count",
    "sum"("ct"."coins_awarded") AS "gift_coin_total"
   FROM ("public"."user_profiles" "u"
     LEFT JOIN "public"."coin_transactions" "ct" ON ((("u"."id" = "ct"."user_id") AND ("ct"."source" = 'gift'::"text"))))
  GROUP BY "u"."id", "u"."username", "u"."total_earned_coins";


ALTER VIEW "public"."creator_earnings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."creator_migration_claims" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "platform_name" "text" NOT NULL,
    "platform_user_id" "text" NOT NULL,
    "platform_profile_url" "text",
    "proof_screenshot_url" "text",
    "verification_status" "text" DEFAULT 'pending'::"text",
    "verified_by" "uuid",
    "verified_at" timestamp with time zone,
    "rejection_reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."creator_migration_claims" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."creator_yearly_payouts" WITH ("security_invoker"='true') AS
 SELECT "user_id",
    "date_part"('year'::"text", "created_at") AS "year",
    "sum"("cash_amount") AS "total_payout_usd",
    "sum"("coin_amount") AS "total_payout_coins"
   FROM "public"."payout_requests"
  WHERE ("status" = 'paid'::"text")
  GROUP BY "user_id", ("date_part"('year'::"text", "created_at"))
  ORDER BY ("date_part"('year'::"text", "created_at")) DESC;


ALTER VIEW "public"."creator_yearly_payouts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."creators_over_600" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "creator_id" "uuid",
    "username" "text",
    "display_name" "text",
    "total_usd_earned" numeric(12,2) DEFAULT 0 NOT NULL,
    "total_coins_earned" bigint DEFAULT 0 NOT NULL,
    "reached_threshold" boolean DEFAULT false NOT NULL,
    "threshold_usd" numeric(12,2) DEFAULT 600 NOT NULL,
    "first_reached_at" timestamp with time zone,
    "last_updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."creators_over_600" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."creators_over_600" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."critical_alerts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "alert_type" "text" NOT NULL,
    "severity" "text" DEFAULT 'critical'::"text" NOT NULL,
    "title" "text" NOT NULL,
    "message" "text" NOT NULL,
    "related_table" "text",
    "related_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "resolved" boolean DEFAULT false NOT NULL,
    "resolved_by" "uuid",
    "resolved_at" timestamp with time zone,
    CONSTRAINT "critical_alerts_alert_type_check" CHECK (("alert_type" = ANY (ARRAY['giftcard_failed'::"text", 'cashout_failed'::"text", 'system_error'::"text", 'security'::"text"]))),
    CONSTRAINT "critical_alerts_severity_check" CHECK (("severity" = ANY (ARRAY['high'::"text", 'critical'::"text"])))
);

ALTER TABLE ONLY "public"."critical_alerts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."critical_alerts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."daily_giveaways" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "giveaway_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "troll_coins_awarded" bigint DEFAULT 0
);

ALTER TABLE ONLY "public"."daily_giveaways" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."daily_giveaways" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."daily_logins" (
    "user_id" "uuid" NOT NULL,
    "last_login_date" "date",
    "streak" integer DEFAULT 0,
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."daily_logins" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."daily_rewards" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "day_number" integer NOT NULL,
    "coins_earned" bigint NOT NULL,
    "date" "date" NOT NULL,
    "click_timestamp" timestamp with time zone,
    "claimed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."daily_rewards" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."daily_rewards" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."declined_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "package_id" "uuid",
    "amount_usd" numeric(10,2),
    "currency" "text" DEFAULT 'USD'::"text",
    "error_code" "text",
    "error_message" "text",
    "error_details" "jsonb",
    "payment_provider" "text" DEFAULT 'square'::"text",
    "source_id" "text",
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."declined_transactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."deed_transfers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "deed_id" "uuid" NOT NULL,
    "from_user_id" "uuid",
    "to_user_id" "uuid",
    "transfer_price" numeric(12,2) DEFAULT 0 NOT NULL,
    "transfer_note" "text",
    "transferred_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."deed_transfers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."deeds" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "property_id" "uuid" NOT NULL,
    "owner_user_id" "uuid" DEFAULT "auth"."uid"(),
    "deed_type" "text" DEFAULT 'standard'::"text",
    "purchase_price" numeric(12,2) DEFAULT 0 NOT NULL,
    "acquired_at" timestamp with time zone DEFAULT "now"(),
    "current_owner_user_id" "uuid" DEFAULT "auth"."uid"()
);


ALTER TABLE "public"."deeds" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."district_announcements" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "district_id" "uuid",
    "title" character varying(200) NOT NULL,
    "content" "text" NOT NULL,
    "announcement_type" character varying(50) DEFAULT 'info'::character varying,
    "is_active" boolean DEFAULT true,
    "expires_at" timestamp with time zone,
    "created_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."district_announcements" OWNER TO "postgres";


COMMENT ON TABLE "public"."district_announcements" IS 'Announcements and notifications for specific districts';



CREATE TABLE IF NOT EXISTS "public"."district_features" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "district_id" "uuid" NOT NULL,
    "feature_name" character varying(100) NOT NULL,
    "feature_type" character varying(50) NOT NULL,
    "route_path" character varying(200),
    "required_role" character varying(50) DEFAULT 'user'::character varying,
    "required_permissions" "text"[],
    "is_enabled" boolean DEFAULT true,
    "sort_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."district_features" OWNER TO "postgres";


COMMENT ON TABLE "public"."district_features" IS 'Specific features available within each district';



CREATE OR REPLACE VIEW "public"."district_navigation" AS
 SELECT "id",
    "name",
    "display_name",
    "description",
    "icon",
    "color",
    "background_image_url",
    "required_role",
    "required_permissions",
    "is_active",
    "sort_order",
    "features",
    "created_at",
    "updated_at"
   FROM "public"."city_districts" "cd"
  WHERE ("is_active" = true)
  ORDER BY "sort_order";


ALTER VIEW "public"."district_navigation" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."earnings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "status" "text" DEFAULT 'pending'::"text",
    CONSTRAINT "earnings_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text"])))
);

ALTER TABLE ONLY "public"."earnings" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."earnings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."economy_abuse_flags" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "related_user_id" "uuid",
    "stream_id" "uuid",
    "flag_type" "text" NOT NULL,
    "confidence" numeric(3,2) NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "economy_abuse_flags_confidence_check" CHECK ((("confidence" >= (0)::numeric) AND ("confidence" <= (1)::numeric)))
);

ALTER TABLE ONLY "public"."economy_abuse_flags" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."economy_abuse_flags" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."economy_summary" WITH ("security_invoker"='true') AS
 SELECT "sum"("usd_amount") AS "total_revenue",
    "sum"("coins_awarded") AS "total_coin_flow",
    "count"(*) AS "total_transactions",
    "count"(DISTINCT "user_id") AS "active_spenders"
   FROM "public"."coin_transactions"
  WHERE ("status" = 'completed'::"text");


ALTER VIEW "public"."economy_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."empire_applications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "status" "text" NOT NULL,
    "payment_type" "text",
    "amount_paid" numeric(10,2),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "reviewed_at" timestamp with time zone,
    "reviewed_by" "uuid",
    "payment_id" "text",
    "payment_status" "text" DEFAULT 'pending'::"text",
    "payment_verified" boolean DEFAULT false,
    "payment_amount" integer DEFAULT 0,
    "applicant_id" "uuid",
    CONSTRAINT "empire_applications_payment_type_check" CHECK (("payment_type" = ANY (ARRAY['paid_coins'::"text", 'card_payment'::"text"]))),
    CONSTRAINT "empire_applications_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text"])))
);

ALTER TABLE ONLY "public"."empire_applications" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."empire_applications" OWNER TO "postgres";


COMMENT ON TABLE "public"."empire_applications" IS 'Tracks Empire Partner Program applications and payments';



CREATE TABLE IF NOT EXISTS "public"."empire_partner_rewards" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "referrer_id" "uuid" NOT NULL,
    "referred_user_id" "uuid" NOT NULL,
    "coins_awarded" bigint DEFAULT 10000 NOT NULL,
    "rewarded_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."empire_partner_rewards" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."empire_partner_rewards" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."empire_partners" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "approved_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "empire_partners_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'suspended'::"text", 'revoked'::"text"])))
);


ALTER TABLE "public"."empire_partners" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."empire_referrals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "referrer_id" "uuid" NOT NULL,
    "referrer_name" "text",
    "referred_id" "uuid",
    "referred_name" "text",
    "referred_email" "text",
    "referred_paid_coins" bigint DEFAULT 0,
    "status" "text" DEFAULT 'pending'::"text",
    "milestone_reached" boolean DEFAULT false,
    "reward_claimed" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."empire_referrals" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."empire_referrals" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."empire_rewards" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "trigger_event" "text" NOT NULL,
    "reward_amount" bigint DEFAULT 500 NOT NULL,
    "reward_currency" "text" DEFAULT 'trollmonds'::"text" NOT NULL,
    "active" boolean DEFAULT true NOT NULL
);

ALTER TABLE ONLY "public"."empire_rewards" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."empire_rewards" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."entrance_effect_catalog" (
    "id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text" NOT NULL,
    "cost_coins" integer NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "is_enabled" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."entrance_effect_catalog" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."entrance_effects" (
    "id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "icon" "text" NOT NULL,
    "coin_cost" integer NOT NULL,
    "rarity" "text" NOT NULL,
    "description" "text",
    "animation_type" "text",
    "sound_effect" "text",
    "duration_seconds" integer DEFAULT 5,
    "image_url" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "entrance_effects_coin_cost_check" CHECK (("coin_cost" >= 0))
);


ALTER TABLE "public"."entrance_effects" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."error_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "route" "text",
    "message" "text",
    "stack" "text",
    "severity" "text" DEFAULT 'error'::"text",
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "resolved" boolean DEFAULT false
);

ALTER TABLE ONLY "public"."error_logs" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."error_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."escalation_matrix" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "violation_type" character varying(50) NOT NULL,
    "severity_level" integer NOT NULL,
    "violation_count_threshold" integer NOT NULL,
    "time_window_days" integer NOT NULL,
    "consequence_type" character varying(50) NOT NULL,
    "consequence_duration_minutes" integer,
    "court_required" boolean DEFAULT false,
    "auto_escalate" boolean DEFAULT true,
    "points_deducted" integer DEFAULT 0,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."escalation_matrix" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."escalation_reports" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "original_report_id" "uuid",
    "escalated_by" "uuid" NOT NULL,
    "escalated_to" "uuid" NOT NULL,
    "escalation_level" "text" NOT NULL,
    "reason" "text" NOT NULL,
    "description" "text",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "reviewed_at" timestamp with time zone,
    "resolved_at" timestamp with time zone,
    CONSTRAINT "escalation_reports_escalation_level_check" CHECK (("escalation_level" = ANY (ARRAY['officer'::"text", 'admin'::"text"]))),
    CONSTRAINT "escalation_reports_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'reviewing'::"text", 'resolved'::"text", 'rejected'::"text"])))
);

ALTER TABLE ONLY "public"."escalation_reports" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."escalation_reports" OWNER TO "postgres";


COMMENT ON TABLE "public"."escalation_reports" IS 'Tracks escalation chain: user -> officer -> admin';



CREATE TABLE IF NOT EXISTS "public"."event_participants" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "event_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "participation_type" character varying(50) DEFAULT 'viewer'::character varying,
    "points_earned" integer DEFAULT 0,
    "rewards_claimed" "jsonb" DEFAULT '[]'::"jsonb",
    "joined_at" timestamp with time zone DEFAULT "now"(),
    "last_activity" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."event_participants" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."executive_intake" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "category" "text" NOT NULL,
    "severity" "text" DEFAULT 'normal'::"text" NOT NULL,
    "status" "text" DEFAULT 'open'::"text" NOT NULL,
    "subject" "text" NOT NULL,
    "details" "text" NOT NULL,
    "related_table" "text",
    "related_id" "uuid",
    "submitted_by" "uuid",
    "assigned_secretary" "uuid",
    "secretary_notes" "text",
    "escalated_to_admin" boolean DEFAULT false NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "executive_intake_category_check" CHECK (("category" = ANY (ARRAY['report'::"text", 'support_ticket'::"text", 'major_complaint'::"text", 'payout'::"text", 'other'::"text"]))),
    CONSTRAINT "executive_intake_severity_check" CHECK (("severity" = ANY (ARRAY['low'::"text", 'normal'::"text", 'high'::"text", 'critical'::"text"]))),
    CONSTRAINT "executive_intake_status_check" CHECK (("status" = ANY (ARRAY['open'::"text", 'in_review'::"text", 'resolved'::"text", 'escalated'::"text"])))
);

ALTER TABLE ONLY "public"."executive_intake" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."executive_intake" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."executive_reports" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "report_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "title" "text" NOT NULL,
    "summary" "text" NOT NULL,
    "created_by" "uuid" NOT NULL,
    "reviewed_by_admin" boolean DEFAULT false NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."executive_reports" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."executive_reports" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."families" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "founder_id" "uuid",
    "emoji" "text",
    "color_theme" "text",
    "family_code" "text",
    "is_active" boolean DEFAULT true,
    "level" integer DEFAULT 1,
    "total_coins" bigint DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "banner_url" "text",
    "war_wins" integer DEFAULT 0,
    "war_losses" integer DEFAULT 0,
    "clan_vault_coins" integer DEFAULT 0
);

ALTER TABLE ONLY "public"."families" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."families" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."family_activity_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid" NOT NULL,
    "actor_id" "uuid",
    "activity_type" "text" NOT NULL,
    "message" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "user_id" "uuid"
);

ALTER TABLE ONLY "public"."family_activity_log" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_activity_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."family_badges_earned" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid" NOT NULL,
    "badge_id" "uuid" NOT NULL,
    "earned_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."family_badges_earned" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_badges_earned" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."family_boosts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid" NOT NULL,
    "boost_type" "text" NOT NULL,
    "boost_value" integer DEFAULT 15,
    "starts_at" timestamp with time zone DEFAULT "now"(),
    "ends_at" timestamp with time zone NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."family_boosts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_boosts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."family_invites" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid" NOT NULL,
    "inviter_id" "uuid" NOT NULL,
    "invitee_id" "uuid",
    "invitee_email" "text",
    "status" "text" DEFAULT 'pending'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone DEFAULT ("now"() + '7 days'::interval),
    CONSTRAINT "family_invites_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'accepted'::"text", 'rejected'::"text", 'expired'::"text"])))
);

ALTER TABLE ONLY "public"."family_invites" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_invites" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."family_lounge_messages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "message" "text" NOT NULL,
    "message_type" "text" DEFAULT 'chat'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);

ALTER TABLE ONLY "public"."family_lounge_messages" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_lounge_messages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."family_members" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "text" DEFAULT 'member'::"text",
    "is_royal_troll" boolean DEFAULT false,
    "rank_name" "text",
    "xp_earned" integer DEFAULT 0,
    "contribution_points" integer DEFAULT 0,
    "joined_by" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tasks_completed" integer DEFAULT 0,
    "wars_participated" integer DEFAULT 0,
    "wars_won" integer DEFAULT 0,
    "recruiting_bonus" integer DEFAULT 0
);

ALTER TABLE ONLY "public"."family_members" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_members" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."family_seasons" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid" NOT NULL,
    "season_number" integer NOT NULL,
    "starts_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "ends_at" timestamp with time zone,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."family_seasons" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_seasons" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."family_shop_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "item_code" "text",
    "name" "text" NOT NULL,
    "description" "text",
    "category" "text" DEFAULT 'perk'::"text",
    "icon_url" "text",
    "price_family_coins" integer DEFAULT 0 NOT NULL,
    "price_family_xp" integer DEFAULT 0 NOT NULL,
    "is_active" boolean DEFAULT true,
    "is_limited" boolean DEFAULT false,
    "stock_limit" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "cost_family_coins" integer DEFAULT 0 NOT NULL,
    "cost_vault_tokens" integer DEFAULT 0 NOT NULL,
    "cost_family_xp" integer DEFAULT 0 NOT NULL
);


ALTER TABLE "public"."family_shop_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."family_shop_purchases" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid" NOT NULL,
    "item_id" "uuid" NOT NULL,
    "purchased_by" "uuid",
    "quantity" integer DEFAULT 1 NOT NULL,
    "total_cost_family_coins" integer DEFAULT 0 NOT NULL,
    "total_cost_family_xp" integer DEFAULT 0 NOT NULL,
    "status" "text" DEFAULT 'completed'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "family_shop_purchases_status_check" CHECK (("status" = ANY (ARRAY['completed'::"text", 'refunded'::"text", 'reversed'::"text"])))
);


ALTER TABLE "public"."family_shop_purchases" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."family_stats" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid" NOT NULL,
    "family_coins" bigint DEFAULT 0,
    "family_xp" bigint DEFAULT 0,
    "family_level" integer DEFAULT 1,
    "total_members" integer DEFAULT 0,
    "total_streams" integer DEFAULT 0,
    "total_gifts_sent" integer DEFAULT 0,
    "total_gifts_received" integer DEFAULT 0,
    "weekly_score" bigint DEFAULT 0,
    "wins" integer DEFAULT 0,
    "losses" integer DEFAULT 0,
    "last_activity_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "total_coins" bigint DEFAULT 0,
    "vault_tokens" bigint DEFAULT 0
);

ALTER TABLE ONLY "public"."family_stats" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_stats" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."family_tasks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid",
    "created_by" "uuid",
    "assigned_to" "uuid",
    "status" character varying(50) DEFAULT 'pending'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "task_title" "text" NOT NULL,
    "task_description" "text",
    "reward_family_coins" bigint DEFAULT 0,
    "reward_family_xp" integer DEFAULT 0,
    "metric" "text",
    "expires_at" timestamp with time zone,
    "ends_at" timestamp with time zone,
    "goal_value" integer DEFAULT 0 NOT NULL,
    "current_value" integer DEFAULT 0 NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "family_tasks_status_check" CHECK ((("status")::"text" = ANY ((ARRAY['active'::character varying, 'completed'::character varying, 'expired'::character varying])::"text"[])))
);

ALTER TABLE ONLY "public"."family_tasks" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_tasks" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."family_tasks_new" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid" NOT NULL,
    "task_type" "text" NOT NULL,
    "category" "text",
    "title" "text" NOT NULL,
    "description" "text",
    "reward_coins" bigint DEFAULT 0,
    "reward_xp" integer DEFAULT 0,
    "completion_rules" "text" DEFAULT 'individual'::"text",
    "max_participants" integer DEFAULT 1,
    "duration_hours" integer DEFAULT 24,
    "difficulty" "text" DEFAULT 'medium'::"text",
    "deadline" timestamp with time zone,
    "status" "text" DEFAULT 'active'::"text",
    "active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."family_tasks_new" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_tasks_new" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."family_war_stats" (
    "family_id" "uuid" NOT NULL,
    "war_xp" bigint DEFAULT 0,
    "war_level" integer DEFAULT 1,
    "total_war_points" bigint DEFAULT 0,
    "weekly_war_points" bigint DEFAULT 0,
    "wins" integer DEFAULT 0,
    "losses" integer DEFAULT 0,
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."family_war_stats" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_war_stats" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."family_wars" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "attacking_family_id" "uuid" NOT NULL,
    "defending_family_id" "uuid" NOT NULL,
    "war_type" "text" DEFAULT 'standard'::"text",
    "status" "text" DEFAULT 'pending'::"text",
    "start_time" timestamp with time zone,
    "end_time" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "family_a_id" "uuid",
    "family_b_id" "uuid"
);

ALTER TABLE ONLY "public"."family_wars" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_wars" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."follows" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "follower_id" "uuid" NOT NULL,
    "following_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."follows" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."follows" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ghost_presence_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid" NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "window_start" timestamp with time zone DEFAULT "now"(),
    "minutes_in_ghost_mode" integer DEFAULT 0
);

ALTER TABLE ONLY "public"."ghost_presence_logs" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."ghost_presence_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gift_bonus_tracker" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "sender_id" "uuid",
    "gift_count" integer DEFAULT 0,
    "total_spent" integer DEFAULT 0,
    "last_gift_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."gift_bonus_tracker" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_bonus_tracker" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gift_card_redemptions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "gift_card_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "coin_amount" integer NOT NULL,
    "redeemed_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    CONSTRAINT "gift_card_redemptions_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'redeemed'::"text", 'reversed'::"text", 'expired'::"text"])))
);


ALTER TABLE "public"."gift_card_redemptions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gift_cards" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" "text" NOT NULL,
    "coin_amount" integer NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "expires_at" timestamp with time zone,
    "redeemed_at" timestamp with time zone,
    "redeemed_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "gift_cards_coin_amount_check" CHECK (("coin_amount" > 0))
);


ALTER TABLE "public"."gift_cards" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gift_catalog" (
    "gift_slug" "text" NOT NULL,
    "name" "text" NOT NULL,
    "category" "text" NOT NULL,
    "tier" "text" NOT NULL,
    "coin_cost" integer NOT NULL,
    "animation_type" "text",
    "description" "text",
    "emoji" "text",
    "popularity_score" integer,
    "image_url" "text"
);

ALTER TABLE ONLY "public"."gift_catalog" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_catalog" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gift_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "icon" "text",
    "value" integer NOT NULL,
    "category" "text" DEFAULT 'Common'::"text",
    "icon_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "status" "text" DEFAULT 'active'::"text",
    "gift_slug" "text",
    "coin_cost" integer DEFAULT 0,
    CONSTRAINT "gift_items_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'inactive'::"text", 'removed'::"text"])))
);

ALTER TABLE ONLY "public"."gift_items" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gift_leaderboard_entries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "leaderboard_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "family_id" "uuid",
    "rank" integer NOT NULL,
    "score" bigint DEFAULT 0 NOT NULL,
    "coins_spent" bigint DEFAULT 0,
    "gifts_sent" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."gift_leaderboard_entries" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_leaderboard_entries" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gift_leaderboards" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "leaderboard_type" "text" NOT NULL,
    "start_date" "date" NOT NULL,
    "end_date" "date" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."gift_leaderboards" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_leaderboards" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gifts" (
    "gift_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid",
    "sender_id" "uuid" NOT NULL,
    "receiver_id" "uuid",
    "coins_spent" bigint DEFAULT 0 NOT NULL,
    "gift_type" "text",
    "message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean DEFAULT true,
    "troll_coins" bigint DEFAULT 0 NOT NULL,
    "source" "text" DEFAULT 'paid'::"text" NOT NULL,
    "name" "text" DEFAULT ''::"text" NOT NULL,
    "icon" "text" DEFAULT ''::"text" NOT NULL,
    "coin_cost" integer DEFAULT 0 NOT NULL,
    "animation_type" "text" DEFAULT 'default'::"text" NOT NULL,
    "description" "text",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "battle_id" "uuid",
    "quantity" integer DEFAULT 1,
    "currency" "text" DEFAULT 'troll_coins'::"text",
    "slug" "text",
    "gift_slug" "text",
    "id" "uuid" DEFAULT "gen_random_uuid"()
);

ALTER TABLE ONLY "public"."gifts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."gifts" OWNER TO "postgres";


COMMENT ON COLUMN "public"."gifts"."receiver_id" IS 'Target user_id for gift (can be host, opponent, or guest)';



COMMENT ON COLUMN "public"."gifts"."battle_id" IS 'Optional battle_id for gifts sent during battles';



CREATE OR REPLACE VIEW "public"."gift_ledger" WITH ("security_invoker"='true') AS
 SELECT "gift_id" AS "id",
    "sender_id",
    "receiver_id",
    "coins_spent" AS "coins",
        CASE
            WHEN ("battle_id" IS NOT NULL) THEN true
            ELSE false
        END AS "is_battle",
        CASE
            WHEN ("message" ~~* '%event%'::"text") THEN true
            ELSE false
        END AS "is_event",
    COALESCE("gift_type", 'gift'::"text") AS "source",
    "created_at"
   FROM "public"."gifts"
  WHERE ("receiver_id" IS NOT NULL);


ALTER VIEW "public"."gift_ledger" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gift_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "from_user_id" "uuid" NOT NULL,
    "to_user_id" "uuid" NOT NULL,
    "coins" bigint NOT NULL,
    "message" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "sender_id" "uuid",
    "receiver_id" "uuid",
    "gift_slug" "text"
);

ALTER TABLE ONLY "public"."gift_transactions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_transactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gift_xp_stats" (
    "user_id" "uuid" NOT NULL,
    "gifter_xp" bigint DEFAULT 0,
    "gifter_level" integer DEFAULT 1,
    "total_coins_spent" bigint DEFAULT 0,
    "streamer_xp" bigint DEFAULT 0,
    "streamer_level" integer DEFAULT 1,
    "total_coins_received" bigint DEFAULT 0,
    "last_updated" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."gift_xp_stats" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_xp_stats" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."giftcard_fulfillments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "cashout_id" "uuid" NOT NULL,
    "provider" "text",
    "amount_usd" numeric(10,2) NOT NULL,
    "purchase_reference" "text",
    "giftcard_code" "text",
    "giftcard_link" "text",
    "delivered_to_user" boolean DEFAULT false NOT NULL,
    "delivered_at" timestamp with time zone,
    "fulfillment_status" "text" DEFAULT 'not_started'::"text" NOT NULL,
    "processed_by" "uuid",
    "processed_at" timestamp with time zone,
    "failure_reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "giftcard_fulfillments_fulfillment_status_check" CHECK (("fulfillment_status" = ANY (ARRAY['not_started'::"text", 'purchased'::"text", 'linked'::"text", 'delivered'::"text", 'failed'::"text"])))
);

ALTER TABLE ONLY "public"."giftcard_fulfillments" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."giftcard_fulfillments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gifts_owned" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "gift_slug" "text" NOT NULL,
    "quantity" integer DEFAULT 0 NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."gifts_owned" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."gifts_owned" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."group_chats" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "created_by" "uuid",
    "is_private" boolean DEFAULT false,
    "member_count" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."group_chats" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."group_chats" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."hire_fire_actions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "lead_id" "uuid" NOT NULL,
    "officer_id" "uuid" NOT NULL,
    "action" "text",
    "reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."hire_fire_actions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."hire_fire_actions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."hire_limits" (
    "role" "text" NOT NULL,
    "max_hires_per_day" integer NOT NULL
);

ALTER TABLE ONLY "public"."hire_limits" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."hire_limits" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."home_feature_cycles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "start_time" timestamp without time zone NOT NULL,
    "end_time" timestamp without time zone NOT NULL,
    "total_spent_coins" bigint DEFAULT 0,
    "reward_paid" boolean DEFAULT false,
    "winner_user_id" "uuid",
    "created_at" timestamp without time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."home_feature_cycles" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."home_feature_cycles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."home_feature_spend" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "cycle_id" "uuid",
    "user_id" "uuid",
    "coins_spent" bigint NOT NULL,
    "created_at" timestamp without time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."home_feature_spend" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."home_feature_spend" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."honorary_family_members" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "admin_id" "uuid" NOT NULL,
    "assigned_by" "uuid" NOT NULL,
    "title" character varying(100) DEFAULT 'Honorary Family Member'::character varying,
    "is_active" boolean DEFAULT true,
    "assigned_at" timestamp with time zone DEFAULT "now"(),
    "removed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."honorary_family_members" OWNER TO "postgres";


COMMENT ON TABLE "public"."honorary_family_members" IS 'Admin-assigned honorary family members';



CREATE TABLE IF NOT EXISTS "public"."hr_employees" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "text" NOT NULL,
    "department" "text",
    "hire_date" "date",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "employment_type" "text",
    CONSTRAINT "hr_employees_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'active'::"text", 'terminated'::"text"])))
);

ALTER TABLE ONLY "public"."hr_employees" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."hr_employees" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."hr_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "target_staff_id" "uuid",
    "target_user_id" "uuid",
    "action" "text" NOT NULL,
    "performed_by" "uuid" NOT NULL,
    "before" "jsonb" DEFAULT '{}'::"jsonb",
    "after" "jsonb" DEFAULT '{}'::"jsonb",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."hr_events" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."hr_events" OWNER TO "postgres";


COMMENT ON TABLE "public"."hr_events" IS 'Append-only audit log of all HR actions for compliance and tracking purposes';



CREATE TABLE IF NOT EXISTS "public"."hr_notes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "target_staff_id" "uuid",
    "target_user_id" "uuid",
    "note" "text" NOT NULL,
    "created_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."hr_notes" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."hr_notes" OWNER TO "postgres";


COMMENT ON TABLE "public"."hr_notes" IS 'HR notes and comments associated with staff members for internal documentation';



CREATE TABLE IF NOT EXISTS "public"."identity_reward_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "type" "text" NOT NULL,
    "amount" numeric(12,2),
    "data" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."identity_reward_logs" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."identity_reward_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."incidents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "reported_by" "uuid",
    "assigned_to" "uuid",
    "stream_id" "text",
    "category" "text",
    "description" "text",
    "evidence" "jsonb",
    "status" "text" DEFAULT 'open'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "incidents_status_check" CHECK (("status" = ANY (ARRAY['open'::"text", 'investigating'::"text", 'closed'::"text", 'escalated'::"text"])))
);

ALTER TABLE ONLY "public"."incidents" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."incidents" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."insurance" (
    "id" "text" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean DEFAULT true,
    "insurance_code" "text",
    "protection_type" "text" DEFAULT 'basic'::"text",
    CONSTRAINT "insurance_code_format" CHECK (("insurance_code" ~ '^insurance_[a-z0-9_]+$'::"text")),
    CONSTRAINT "insurance_id_format" CHECK (("id" ~ '^insurance_[a-z0-9_]+$'::"text"))
);

ALTER TABLE ONLY "public"."insurance" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."insurance" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."insurance_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "protection_type" "text" NOT NULL,
    "event_type" "text" NOT NULL,
    "blocked_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "insurance_logs_protection_type_check" CHECK (("protection_type" = ANY (ARRAY['bankrupt'::"text", 'kick'::"text", 'full'::"text"])))
);


ALTER TABLE "public"."insurance_logs" OWNER TO "postgres";


COMMENT ON TABLE "public"."insurance_logs" IS 'Audit trail for insurance usage to prevent fraud';



COMMENT ON COLUMN "public"."insurance_logs"."protection_type" IS 'Type of protection that was used';



COMMENT ON COLUMN "public"."insurance_logs"."event_type" IS 'The event that was blocked (bankrupt, kick, etc.)';



CREATE TABLE IF NOT EXISTS "public"."insurance_options" (
    "id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "cost" integer NOT NULL,
    "description" "text" NOT NULL,
    "duration_hours" integer NOT NULL,
    "protection_type" "text" NOT NULL,
    "icon" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "insurance_options_cost_check" CHECK (("cost" >= 0)),
    CONSTRAINT "insurance_options_protection_type_check" CHECK (("protection_type" = ANY (ARRAY['bankrupt'::"text", 'kick'::"text", 'full'::"text"])))
);


ALTER TABLE "public"."insurance_options" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."insurance_packages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text",
    "level" "text",
    "cost" integer,
    "duration_days" integer,
    "benefits" "text"[],
    "is_active" boolean DEFAULT true
);

ALTER TABLE ONLY "public"."insurance_packages" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."insurance_packages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."insurance_plans" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "coverage_description" "text",
    "price_paid_coins" bigint NOT NULL,
    "duration_days" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."insurance_plans" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."insurance_plans" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."interview_sessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "admin_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "room_name" "text" NOT NULL,
    "status" "text" DEFAULT 'active'::"text" NOT NULL,
    "started_at" timestamp with time zone DEFAULT "now"(),
    "ended_at" timestamp with time zone,
    "locked_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "interview_sessions_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'completed'::"text", 'hired'::"text", 'rejected'::"text"])))
);

ALTER TABLE ONLY "public"."interview_sessions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."interview_sessions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."inventory_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "icon" "text",
    "coin_price" bigint DEFAULT 0 NOT NULL,
    "currency" "text" DEFAULT 'paid'::"text" NOT NULL,
    "category" "text",
    "type" "text" DEFAULT 'item'::"text" NOT NULL,
    "animation_type" "text" NOT NULL,
    "animation_asset" "text",
    "sound_asset" "text",
    "status" "text" DEFAULT 'active'::"text" NOT NULL,
    "is_stackable" boolean DEFAULT true,
    "is_consumable" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean GENERATED ALWAYS AS (("status" = 'active'::"text")) STORED,
    "troll_coin_value" bigint DEFAULT 0,
    CONSTRAINT "inventory_items_currency_check" CHECK (("currency" = ANY (ARRAY['paid'::"text", 'trollmonds'::"text", 'free'::"text"]))),
    CONSTRAINT "inventory_items_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'inactive'::"text", 'removed'::"text"]))),
    CONSTRAINT "inventory_items_type_check" CHECK (("type" = ANY (ARRAY['item'::"text", 'effect'::"text", 'badge'::"text", 'ticket'::"text", 'digital'::"text"])))
);

ALTER TABLE ONLY "public"."inventory_items" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."inventory_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ip_bans" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ip_address" "inet" NOT NULL,
    "banned_by" "uuid",
    "ban_reason" "text" NOT NULL,
    "ban_details" "text",
    "banned_until" timestamp with time zone,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."ip_bans" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."ip_bans" OWNER TO "postgres";


COMMENT ON TABLE "public"."ip_bans" IS 'IP address bans issued by troll officers and admins';



CREATE OR REPLACE VIEW "public"."irs_threshold_tracking" WITH ("security_invoker"='true') AS
 SELECT "p"."id" AS "user_id",
    "p"."username",
    ("date_part"('year'::"text", "pr"."created_at"))::integer AS "year",
    "sum"(COALESCE("pr"."cash_amount", "pr"."amount_usd", (0)::numeric)) AS "total_paid_usd",
    "count"(*) AS "payout_count",
        CASE
            WHEN ("sum"(COALESCE("pr"."cash_amount", "pr"."amount_usd", (0)::numeric)) >= (600)::numeric) THEN true
            ELSE false
        END AS "requires_1099",
        CASE
            WHEN ("sum"(COALESCE("pr"."cash_amount", "pr"."amount_usd", (0)::numeric)) >= (600)::numeric) THEN 'REQUIRED'::"text"
            WHEN ("sum"(COALESCE("pr"."cash_amount", "pr"."amount_usd", (0)::numeric)) >= (500)::numeric) THEN 'WARNING'::"text"
            ELSE 'OK'::"text"
        END AS "threshold_status",
    "max"("pr"."created_at") AS "last_payout_date"
   FROM ("public"."user_profiles" "p"
     JOIN "public"."payout_requests" "pr" ON (("pr"."user_id" = "p"."id")))
  WHERE ("pr"."status" = 'paid'::"text")
  GROUP BY "p"."id", "p"."username", ("date_part"('year'::"text", "pr"."created_at"))
  ORDER BY (("date_part"('year'::"text", "pr"."created_at"))::integer) DESC, ("sum"(COALESCE("pr"."cash_amount", "pr"."amount_usd", (0)::numeric))) DESC;


ALTER VIEW "public"."irs_threshold_tracking" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."job_applications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "interview_id" "uuid",
    "application_data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "status" "text" DEFAULT 'submitted'::"text" NOT NULL,
    "submitted_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "job_applications_status_check" CHECK (("status" = ANY (ARRAY['submitted'::"text", 'reviewed'::"text", 'approved'::"text", 'rejected'::"text"])))
);

ALTER TABLE ONLY "public"."job_applications" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."job_applications" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."kick_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "kicked_user_id" "uuid",
    "kicked_by_user_id" "uuid",
    "stream_id" "uuid",
    "kick_cost_paid" integer DEFAULT 500,
    "re_entry_fee_paid" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."kick_logs" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."kick_logs" OWNER TO "postgres";


COMMENT ON TABLE "public"."kick_logs" IS 'Logs of all kick actions with costs and re-entry fees';



CREATE OR REPLACE VIEW "public"."kick_logs_moderation" WITH ("security_invoker"='true') AS
 SELECT "kl"."id",
    "kl"."created_at",
    "kl"."stream_id",
    "kl"."kick_cost_paid",
    "kl"."re_entry_fee_paid",
    "kl"."kicked_user_id",
    "ku"."username" AS "kicked_username",
    "kl"."kicked_by_user_id",
    "kb"."username" AS "kicked_by_username"
   FROM (("public"."kick_logs" "kl"
     LEFT JOIN "public"."user_profiles" "ku" ON (("ku"."id" = "kl"."kicked_user_id")))
     LEFT JOIN "public"."user_profiles" "kb" ON (("kb"."id" = "kl"."kicked_by_user_id")));


ALTER VIEW "public"."kick_logs_moderation" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."live_streams" AS
 SELECT "id",
    "broadcaster_id",
    "title",
    "category",
    "status",
    "start_time",
    "end_time",
    "current_viewers",
    "total_gifts_coins",
    "total_unique_gifters",
    "total_free_gifts",
    "total_earnings_usd",
    "final_viewers",
    "final_total_coins",
    "final_earnings_usd",
    "thumbnail_url",
    "agora_channel",
    "agora_token",
    "created_at",
    "updated_at",
    "owner_id",
    "livekit_url",
    "user_id",
    "room_name",
    "is_live",
    "max_beams",
    "current_participants",
    "started_at",
    "ended_at",
    "duration",
    "livekit_room_name",
    "is_testing_mode",
    "popularity",
    "viewer_count",
    "streamer_id",
    "livekit_room",
    "recording_url",
    "recording_storage_path",
    "save_requested",
    "save_requested_by",
    "save_requested_at",
    "saved_to_admin_archive",
    "saved_at",
    "audience_type",
    "is_paid",
    "entry_price_coins",
    "allow_gifts",
    "max_guest_slots",
    "description",
    "pricing_type",
    "pricing_value",
    "gift_multiplier",
    "like_price",
    "family_xp_bonus",
    "family_coin_bonus",
    "notify_followers",
    "notify_family",
    "allow_officer_free_join",
    "moderator_mode",
    "total_likes",
    "host_user_id"
   FROM "public"."streams"
  WHERE ("status" = 'live'::"text");


ALTER VIEW "public"."live_streams" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."lucky_coin_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "gift_id" "uuid",
    "spent_paid_coins" bigint NOT NULL,
    "multiplier" integer,
    "troll_coins_awarded" bigint DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "lucky_trollmond_events_multiplier_check" CHECK (("multiplier" = ANY (ARRAY[100, 200, 500, 1000, 10000]))),
    CONSTRAINT "lucky_trollmond_events_spent_paid_coins_check" CHECK (("spent_paid_coins" > 0))
);

ALTER TABLE ONLY "public"."lucky_coin_events" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."lucky_coin_events" OWNER TO "postgres";


COMMENT ON TABLE "public"."lucky_coin_events" IS 'Audit trail for lucky trollmond events';



CREATE TABLE IF NOT EXISTS "public"."mai_appeals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "case_type" "text" NOT NULL,
    "case_id" "text" NOT NULL,
    "appellant_user_id" "uuid" NOT NULL,
    "appeal_reason" "text",
    "original_action" "jsonb",
    "secondary_review" "jsonb",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "decided_at" timestamp with time zone,
    "decided_by" "uuid",
    CONSTRAINT "mai_appeals_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'reviewed'::"text", 'upheld'::"text", 'downgraded'::"text", 'escalated'::"text", 'rejected'::"text"])))
);

ALTER TABLE ONLY "public"."mai_appeals" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."mai_appeals" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."mai_incidents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "source" "text" NOT NULL,
    "stream_id" "uuid",
    "host_user_id" "uuid",
    "involved_user_ids" "uuid"[] DEFAULT '{}'::"uuid"[],
    "verified_violation" boolean DEFAULT false NOT NULL,
    "safety_ai_flags" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "chat_logs" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "audio_transcripts" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "prior_user_history" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "troll_court_status" "text",
    "clerk_report" "jsonb",
    "judge_action" "jsonb",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "processed_at" timestamp with time zone,
    CONSTRAINT "mai_incidents_source_check" CHECK (("source" = ANY (ARRAY['live_stream'::"text", 'dm_messages'::"text", 'troll_court_chat'::"text", 'tromody_chat'::"text"]))),
    CONSTRAINT "mai_incidents_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processed'::"text", 'actioned'::"text", 'dismissed'::"text"])))
);

ALTER TABLE ONLY "public"."mai_incidents" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."mai_incidents" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."mai_overrides" (
    "key" "text" NOT NULL,
    "enabled" boolean DEFAULT false NOT NULL,
    "reason" "text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "expires_at" timestamp with time zone
);

ALTER TABLE ONLY "public"."mai_overrides" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."mai_overrides" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."mai_timeline_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "event_type" "text" NOT NULL,
    "actor_user_id" "uuid",
    "target_user_id" "uuid",
    "stream_id" "uuid",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "sensitive_hash" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."mai_timeline_events" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."mai_timeline_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."mai_user_memory" (
    "user_id" "uuid" NOT NULL,
    "opt_in" boolean DEFAULT false NOT NULL,
    "preferences" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."mai_user_memory" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."mai_user_memory" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."marketplace_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "price_coins" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "title" "text",
    "type" "text"
);

ALTER TABLE ONLY "public"."marketplace_items" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."marketplace_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."message_receipts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "message_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "delivered_at" timestamp with time zone,
    "read_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."message_receipts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."message_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "sender_id" "uuid",
    "receiver_id" "uuid",
    "message" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "message_requests_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'accepted'::"text", 'declined'::"text"])))
);

ALTER TABLE ONLY "public"."message_requests" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."message_requests" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."messages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid",
    "user_id" "uuid",
    "sender_id" "uuid",
    "receiver_id" "uuid",
    "content" "text",
    "message_type" "text" DEFAULT 'chat'::"text",
    "gift_amount" bigint,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "seen" boolean DEFAULT false,
    "read_at" timestamp with time zone,
    CONSTRAINT "messages_message_type_check" CHECK (("message_type" = ANY (ARRAY['chat'::"text", 'gift'::"text", 'entrance'::"text", 'dm'::"text", 'system'::"text", 'officer'::"text", 'broadcast'::"text"])))
);

ALTER TABLE ONLY "public"."messages" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."messages" OWNER TO "postgres";


COMMENT ON COLUMN "public"."messages"."message_type" IS 'Message type: dm (direct), system (system alerts), officer (officer messages), broadcast (broadcasts), chat (stream chat), gift, entrance';



COMMENT ON COLUMN "public"."messages"."seen" IS 'Whether the receiver has seen/read this message';



COMMENT ON COLUMN "public"."messages"."read_at" IS 'Timestamp when the receiver read/seen this message';



CREATE TABLE IF NOT EXISTS "public"."millionaire_hall_of_fame" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "sender_id" "uuid",
    "receiver_id" "uuid",
    "gift_name" "text" NOT NULL,
    "coins_spent" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."millionaire_hall_of_fame" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."millionaire_hall_of_fame" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."moderation_actions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "report_id" "uuid",
    "officer_id" "uuid",
    "action" "text",
    "details" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "ban_expires_at" timestamp with time zone,
    "ban_duration_hours" integer,
    "honesty_message_shown" boolean DEFAULT false,
    "reason" "text" NOT NULL,
    "target_user_id" "uuid",
    "actor_id" "uuid",
    "action_type" "text",
    "status" "text",
    CONSTRAINT "moderation_actions_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'expired'::"text", 'appealed'::"text", 'revoked'::"text"])))
);

ALTER TABLE ONLY "public"."moderation_actions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."moderation_actions" OWNER TO "postgres";


COMMENT ON COLUMN "public"."moderation_actions"."ban_expires_at" IS 'When the ban expires (NULL for permanent)';



COMMENT ON COLUMN "public"."moderation_actions"."ban_duration_hours" IS 'Duration of ban in hours';



COMMENT ON COLUMN "public"."moderation_actions"."honesty_message_shown" IS 'Whether honesty message was shown to user';



CREATE TABLE IF NOT EXISTS "public"."moderation_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid" NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "target_user_id" "uuid",
    "action_type" "text" NOT NULL,
    "reason" "text",
    "context" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "bonus_coins" integer DEFAULT 0 NOT NULL
);

ALTER TABLE ONLY "public"."moderation_events" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."moderation_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."moderation_fee_settings" (
    "id" integer DEFAULT 1 NOT NULL,
    "kick_fee_coins" integer DEFAULT 500 NOT NULL,
    "kick_reentry_fee_coins" integer DEFAULT 250 NOT NULL,
    "ban_restoration_fee_coins" integer DEFAULT 2000 NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "updated_by" "uuid",
    CONSTRAINT "moderation_fee_settings_ban_restoration_fee_coins_check" CHECK (("ban_restoration_fee_coins" >= 0)),
    CONSTRAINT "moderation_fee_settings_kick_fee_coins_check" CHECK (("kick_fee_coins" >= 0)),
    CONSTRAINT "moderation_fee_settings_kick_reentry_fee_coins_check" CHECK (("kick_reentry_fee_coins" >= 0))
);

ALTER TABLE ONLY "public"."moderation_fee_settings" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."moderation_fee_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."moderation_notes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "moderator_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "note" "text",
    "type" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."moderation_notes" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."moderation_notes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."moderation_reports" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "reporter_id" "uuid" NOT NULL,
    "reported_user_id" "uuid" NOT NULL,
    "stream_id" "uuid",
    "report_reason" "text" NOT NULL,
    "report_details" "text",
    "status" "text" DEFAULT 'pending'::"text",
    "resolved_by" "uuid",
    "resolved_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "moderation_reports_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'reviewed'::"text", 'resolved'::"text"])))
);

ALTER TABLE ONLY "public"."moderation_reports" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."moderation_reports" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."moderation_reports_view" WITH ("security_invoker"='true') AS
 SELECT "mr"."id" AS "report_id",
    "mr"."reporter_id",
    "u1"."username" AS "reporter_username",
    "mr"."reported_user_id",
    "u2"."username" AS "reported_username",
    "mr"."report_reason",
    "mr"."report_details",
    "mr"."stream_id",
    "s"."title" AS "stream_title",
    "mr"."created_at",
    "mr"."status",
    "mr"."resolved_by",
    "u3"."username" AS "resolved_by_username",
    "mr"."resolved_at"
   FROM (((("public"."moderation_reports" "mr"
     LEFT JOIN "public"."user_profiles" "u1" ON (("mr"."reporter_id" = "u1"."id")))
     LEFT JOIN "public"."user_profiles" "u2" ON (("mr"."reported_user_id" = "u2"."id")))
     LEFT JOIN "public"."user_profiles" "u3" ON (("mr"."resolved_by" = "u3"."id")))
     LEFT JOIN "public"."streams" "s" ON (("mr"."stream_id" = "s"."id")))
  ORDER BY "mr"."created_at" DESC;


ALTER VIEW "public"."moderation_reports_view" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."monthly_earnings_breakdown" WITH ("security_invoker"='true') AS
 SELECT "p"."id" AS "user_id",
    "p"."username",
    "date_trunc"('month'::"text", "g"."created_at") AS "month",
    "sum"("g"."coins_spent") AS "coins_earned_from_gifts",
    "count"(DISTINCT "g"."gift_id") AS "gift_count",
    "count"(DISTINCT "g"."sender_id") AS "unique_gifters",
    "sum"(
        CASE
            WHEN ("g"."gift_type" = 'paid'::"text") THEN "g"."coins_spent"
            ELSE (0)::bigint
        END) AS "paid_coins_earned",
    "sum"(
        CASE
            WHEN ("g"."gift_type" = 'free'::"text") THEN "g"."coins_spent"
            ELSE (0)::bigint
        END) AS "free_coins_earned"
   FROM ("public"."user_profiles" "p"
     JOIN "public"."gifts" "g" ON (("g"."receiver_id" = "p"."id")))
  WHERE (("p"."is_broadcaster" = true) OR ("p"."total_earned_coins" > 0))
  GROUP BY "p"."id", "p"."username", ("date_trunc"('month'::"text", "g"."created_at"))
  ORDER BY ("date_trunc"('month'::"text", "g"."created_at")) DESC, ("sum"("g"."coins_spent")) DESC;


ALTER VIEW "public"."monthly_earnings_breakdown" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."notifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "type" "text",
    "title" "text",
    "message" "text",
    "content" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "read" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "is_read" boolean DEFAULT false,
    "is_sent" boolean DEFAULT false,
    "body" "text"
);

ALTER TABLE ONLY "public"."notifications" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."notifications" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."notifications_view" WITH ("security_invoker"='true') AS
 SELECT "n"."id",
    "n"."user_id",
    "n"."type",
    "n"."title",
    "n"."message",
    "n"."content",
    "n"."metadata",
    "n"."read",
    "n"."created_at",
    "n"."is_read",
    "n"."is_sent",
    "up"."username",
    "up"."avatar_url"
   FROM ("public"."notifications" "n"
     LEFT JOIN "public"."user_profiles" "up" ON (("up"."id" = "n"."user_id")))
  ORDER BY "n"."created_at" DESC;


ALTER VIEW "public"."notifications_view" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."observer_ratings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "event_id" "uuid" NOT NULL,
    "score" integer NOT NULL,
    "verdict" "text" NOT NULL,
    "policy_tags" "text"[],
    "feedback" "text",
    "model_version" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."observer_ratings" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."observer_ratings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_actions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid",
    "target_user_id" "uuid",
    "action_type" "text" NOT NULL,
    "fee_coins" integer DEFAULT 0 NOT NULL,
    "reason" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "coins_awarded" integer DEFAULT 0 NOT NULL,
    CONSTRAINT "officer_actions_action_type_check" CHECK (("action_type" = ANY (ARRAY['kick'::"text", 'ban'::"text", 'mute'::"text", 'warning'::"text"])))
);


ALTER TABLE "public"."officer_actions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_activity" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid",
    "message" "text",
    "time" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."officer_activity" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_activity" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_applications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "status" "text" DEFAULT 'pending'::"text",
    "training_score" integer,
    "experience" "text",
    "social_links" "text",
    "notes" "text",
    "reviewed_by" "uuid",
    "reviewed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "officer_applications_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'denied'::"text"])))
);

ALTER TABLE ONLY "public"."officer_applications" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_applications" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_availability" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid" NOT NULL,
    "day_of_week" "text" NOT NULL,
    "available_start" time without time zone,
    "available_end" time without time zone,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."officer_availability" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_availability" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_badges" (
    "user_id" "uuid" NOT NULL,
    "badge" "text" DEFAULT 'User'::"text" NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."officer_badges" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_badges" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_chat" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "username" "text" NOT NULL,
    "role" "text" NOT NULL,
    "message" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."officer_chat" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_chat" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_earnings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid",
    "action_id" "uuid",
    "commission_coins" integer NOT NULL,
    "usd_value" numeric(10,2),
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."officer_earnings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_hours" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid" NOT NULL,
    "shift_id" "uuid" NOT NULL,
    "hours_worked" numeric,
    "date" "date",
    "status" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."officer_hours" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_hours" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_live_assignments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid" NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "joined_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "left_at" timestamp with time zone,
    "status" "text" DEFAULT 'active'::"text" NOT NULL,
    "auto_clocked_out" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "ghost_mode_active" boolean DEFAULT false,
    "last_activity" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."officer_live_assignments" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_live_assignments" OWNER TO "postgres";


COMMENT ON TABLE "public"."officer_live_assignments" IS 'Tracks when troll officers join and leave live streams for admin monitoring';



CREATE TABLE IF NOT EXISTS "public"."officer_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid" NOT NULL,
    "action" "text",
    "target_user" "uuid",
    "target_stream" "uuid",
    "description" "text",
    "severity" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."officer_logs" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_mission_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid" NOT NULL,
    "mission_type" "text" NOT NULL,
    "stream_id" "uuid",
    "completed_at" timestamp with time zone DEFAULT "now"(),
    "coins_awarded" integer,
    "reputation_awarded" integer
);

ALTER TABLE ONLY "public"."officer_mission_logs" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_mission_logs" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."officer_monthly_payroll" WITH ("security_invoker"='true') AS
 SELECT "u"."username",
    "date_trunc"('month'::"text", "osl"."clock_in_time") AS "month",
    "count"(*) AS "total_shifts",
    "sum"("osl"."hours_worked") AS "total_hours",
    "sum"("osl"."coins_earned") AS "total_coins",
    "sum"(
        CASE
            WHEN ("osl"."paid" = false) THEN "osl"."coins_earned"
            ELSE 0
        END) AS "unpaid_coins"
   FROM ("public"."officer_shift_logs" "osl"
     JOIN "public"."user_profiles" "u" ON (("u"."id" = "osl"."officer_id")))
  GROUP BY "u"."username", ("date_trunc"('month'::"text", "osl"."clock_in_time"))
  ORDER BY ("date_trunc"('month'::"text", "osl"."clock_in_time")) DESC;


ALTER VIEW "public"."officer_monthly_payroll" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_orientation_results" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "score" integer DEFAULT 0 NOT NULL,
    "has_passed" boolean DEFAULT false NOT NULL,
    "completed_at" timestamp with time zone DEFAULT "now"(),
    "submitted_answers" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."officer_orientation_results" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_orientation_results" OWNER TO "postgres";


COMMENT ON TABLE "public"."officer_orientation_results" IS 'Stores officer orientation quiz results and submitted answers';



COMMENT ON COLUMN "public"."officer_orientation_results"."score" IS 'Number of correct answers';



COMMENT ON COLUMN "public"."officer_orientation_results"."has_passed" IS 'Whether the user passed (score >= 80%)';



COMMENT ON COLUMN "public"."officer_orientation_results"."submitted_answers" IS 'JSON object mapping question IDs to user answers';



CREATE TABLE IF NOT EXISTS "public"."officer_orientations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "status" "text" DEFAULT 'assigned'::"text" NOT NULL,
    "assigned_at" timestamp with time zone DEFAULT "now"(),
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "attempts" integer DEFAULT 0,
    "max_attempts" integer DEFAULT 3,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "officer_orientations_status_check" CHECK (("status" = ANY (ARRAY['assigned'::"text", 'in_progress'::"text", 'passed'::"text", 'failed'::"text"])))
);


ALTER TABLE "public"."officer_orientations" OWNER TO "postgres";


COMMENT ON TABLE "public"."officer_orientations" IS 'Tracks officer orientation assignments and completion status';



CREATE TABLE IF NOT EXISTS "public"."officer_payouts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid" NOT NULL,
    "shift_log_id" "uuid",
    "free_coins_redeemed" bigint NOT NULL,
    "troll_coins_received" integer NOT NULL,
    "usd_amount" numeric(10,2) NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "requested_at" timestamp with time zone DEFAULT "now"(),
    "processed_at" timestamp with time zone,
    "admin_id" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "officer_payouts_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'paid'::"text", 'rejected'::"text"])))
);


ALTER TABLE "public"."officer_payouts" OWNER TO "postgres";


COMMENT ON TABLE "public"."officer_payouts" IS 'Tracks officer cashouts after completed shifts';



CREATE TABLE IF NOT EXISTS "public"."officer_performance" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid" NOT NULL,
    "current_score" integer DEFAULT 100,
    "lifetime_score" integer DEFAULT 100,
    "cases_handled" integer DEFAULT 0,
    "successful_resolutions" integer DEFAULT 0,
    "escalated_cases" integer DEFAULT 0,
    "average_resolution_time_minutes" integer,
    "owc_points_earned" integer DEFAULT 0,
    "performance_rating" character varying(20) DEFAULT 'standard'::character varying,
    "specialization_areas" "text"[],
    "last_case_date" timestamp with time zone,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."officer_performance" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_quiz_attempts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "score_percent" integer NOT NULL,
    "passed" boolean NOT NULL,
    "attempt_number" integer DEFAULT 1 NOT NULL,
    "taken_at" timestamp with time zone DEFAULT "now"(),
    "orientation_id" "uuid",
    "answers" "jsonb",
    "score" integer,
    "questions_answered" integer,
    "correct_answers" integer,
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "time_taken_seconds" integer,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."officer_quiz_attempts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_quiz_attempts" OWNER TO "postgres";


COMMENT ON TABLE "public"."officer_quiz_attempts" IS 'Records quiz attempts and scores';



CREATE TABLE IF NOT EXISTS "public"."officer_quiz_questions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "question_text" "text" NOT NULL,
    "question" "text",
    "correct_option" "text",
    "correct_answer" "text",
    "option_a" "text",
    "option_b" "text",
    "option_c" "text",
    "option_d" "text",
    "explanation" "text",
    "category" "text" DEFAULT 'general'::"text",
    "order_index" integer DEFAULT 0,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."officer_quiz_questions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_quiz_questions" OWNER TO "postgres";


COMMENT ON TABLE "public"."officer_quiz_questions" IS 'Stores quiz questions for officer orientation';



CREATE TABLE IF NOT EXISTS "public"."officer_quiz_results" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid" NOT NULL,
    "question_id" "uuid" NOT NULL,
    "submitted_answer" "text",
    "is_correct" boolean DEFAULT false NOT NULL,
    "time_taken_seconds" integer,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."officer_quiz_results" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_quiz_results" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."officer_quiz_results_view" WITH ("security_invoker"='true') AS
 SELECT "r"."id",
    "r"."officer_id",
    "p"."username" AS "officer_name",
    "q"."question_text",
    "r"."submitted_answer",
    "r"."is_correct",
    "r"."time_taken_seconds",
    "r"."created_at"
   FROM (("public"."officer_quiz_results" "r"
     JOIN "public"."officer_quiz_questions" "q" ON (("q"."id" = "r"."question_id")))
     JOIN "public"."user_profiles" "p" ON (("p"."id" = "r"."officer_id")));


ALTER VIEW "public"."officer_quiz_results_view" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_shift_slots" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "coin_rate_per_hour" integer DEFAULT 500,
    "required_level" integer DEFAULT 1,
    "slot_status" "text" DEFAULT 'open'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "officer_id" "uuid",
    "shift_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "shift_start_time" time without time zone DEFAULT '00:00:00'::time without time zone NOT NULL,
    "shift_end_time" time without time zone DEFAULT '00:00:00'::time without time zone NOT NULL,
    "is_taken" boolean DEFAULT false NOT NULL,
    "status" "text" DEFAULT 'open'::"text" NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "officer_shift_slots_slot_status_check" CHECK (("slot_status" = ANY (ARRAY['open'::"text", 'taken'::"text", 'closed'::"text"])))
);

ALTER TABLE ONLY "public"."officer_shift_slots" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_shift_slots" OWNER TO "postgres";


COMMENT ON TABLE "public"."officer_shift_slots" IS 'Officers schedule their work shifts in advance. Each slot must be filled by the assigned officer.';



CREATE TABLE IF NOT EXISTS "public"."officer_shifts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid",
    "started_at" timestamp with time zone DEFAULT "now"(),
    "ended_at" timestamp with time zone,
    "auto_clockout" boolean DEFAULT false
);

ALTER TABLE ONLY "public"."officer_shifts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_shifts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_stream_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid" NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "joined_at" timestamp with time zone DEFAULT "now"(),
    "left_at" timestamp with time zone,
    "actions_taken" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."officer_stream_logs" OWNER TO "postgres";


COMMENT ON TABLE "public"."officer_stream_logs" IS 'Tracks when troll officers join and leave streams, and actions taken';



CREATE TABLE IF NOT EXISTS "public"."officer_strikes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid",
    "issued_by" "uuid",
    "reason" "text",
    "points" integer DEFAULT 1,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."officer_strikes" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_strikes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_training_sessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid" NOT NULL,
    "scenario_id" "uuid" NOT NULL,
    "action_taken" "text",
    "is_correct" boolean,
    "response_time_seconds" integer,
    "points_earned" integer DEFAULT 0,
    "attempted_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."officer_training_sessions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_training_sessions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."officer_work_sessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid" NOT NULL,
    "stream_id" "uuid",
    "clock_in" timestamp with time zone DEFAULT "now"() NOT NULL,
    "clock_out" timestamp with time zone,
    "hours_worked" numeric(6,2),
    "coins_earned" bigint DEFAULT 0,
    "payout_status" "text" DEFAULT 'unpaid'::"text",
    "auto_clocked_out" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "ghost_inactivity_minutes" integer DEFAULT 0,
    "owc_earned" bigint DEFAULT 0,
    "paid_coins_converted" bigint DEFAULT 0,
    "troll_coins_converted" bigint DEFAULT 0
);

ALTER TABLE ONLY "public"."officer_work_sessions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_work_sessions" OWNER TO "postgres";


COMMENT ON TABLE "public"."officer_work_sessions" IS 'Tracks officer work shifts for payroll calculation';



CREATE TABLE IF NOT EXISTS "public"."onboarding_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "event_type" "text" NOT NULL,
    "step_number" integer,
    "event_data" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."onboarding_events" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."onboarding_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."onboarding_progress" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "current_step" integer DEFAULT 1,
    "completed_steps" "jsonb" DEFAULT '[]'::"jsonb",
    "personal_info" "jsonb",
    "tax_info" "jsonb",
    "payout_method" "jsonb",
    "rules_acknowledged" boolean DEFAULT false,
    "digital_signature" "text",
    "simulation_score" integer,
    "hr_approved" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."onboarding_progress" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."onboarding_progress" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."owc_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "amount" bigint NOT NULL,
    "transaction_type" "text" NOT NULL,
    "source" "text",
    "session_id" "uuid",
    "conversion_rate" numeric(5,4),
    "paid_coins_received" bigint,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "owc_transactions_transaction_type_check" CHECK (("transaction_type" = ANY (ARRAY['earned'::"text", 'converted'::"text", 'bonus'::"text", 'deducted'::"text"])))
);

ALTER TABLE ONLY "public"."owc_transactions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."owc_transactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."payment_fees" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "revenue_id" "uuid",
    "provider" "text" NOT NULL,
    "external_id" "text" NOT NULL,
    "fee_type" "text" DEFAULT 'provider_fee'::"text" NOT NULL,
    "amount_usd" numeric(12,2) NOT NULL,
    "currency" "text" DEFAULT 'USD'::"text" NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "payment_fees_amount_usd_check" CHECK (("amount_usd" >= (0)::numeric)),
    CONSTRAINT "payment_fees_provider_check" CHECK (("provider" = 'paypal'::"text"))
);

ALTER TABLE ONLY "public"."payment_fees" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."payment_fees" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."payment_holds" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "hold_type" "text" NOT NULL,
    "reason" "text" NOT NULL,
    "placed_by" "uuid" NOT NULL,
    "is_active" boolean DEFAULT true,
    "released_by" "uuid",
    "released_reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "released_at" timestamp with time zone,
    CONSTRAINT "payment_holds_hold_type_check" CHECK (("hold_type" = ANY (ARRAY['cashout'::"text", 'payout'::"text", 'withdrawal'::"text", 'all'::"text"])))
);


ALTER TABLE "public"."payment_holds" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."payment_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "paypal_order_id" "text" NOT NULL,
    "paypal_capture_id" "text",
    "user_id" "uuid",
    "package_id" "uuid",
    "status" "text" DEFAULT 'PENDING'::"text" NOT NULL,
    "amount_usd" numeric(10,2) NOT NULL,
    "coins_granted" integer DEFAULT 0,
    "error_code" "text",
    "error_message" "text",
    "raw_response" "jsonb",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    CONSTRAINT "payment_logs_status_check" CHECK (("status" = ANY (ARRAY['PENDING'::"text", 'COMPLETED'::"text", 'FAILED'::"text", 'REFUNDED'::"text"])))
);


ALTER TABLE "public"."payment_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."payment_methods" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "user_id" "uuid",
    "brand" "text",
    "last4" "text",
    "card_token" "text",
    "created_at" timestamp without time zone DEFAULT "now"(),
    "paypal_account_id" "text",
    "paypal_email" "text"
);

ALTER TABLE ONLY "public"."payment_methods" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."payment_methods" OWNER TO "postgres";


COMMENT ON TABLE "public"."payment_methods" IS 'Stored payment methods (Square cards)';



CREATE TABLE IF NOT EXISTS "public"."payment_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "coins_purchased" bigint,
    "amount_paid" numeric(12,2),
    "square_transaction_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "amount_usd" numeric(10,2)
);

ALTER TABLE ONLY "public"."payment_transactions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."payment_transactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."payout_audit_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "payout_request_id" "uuid",
    "action" "text" NOT NULL,
    "processed_by" "uuid",
    "paypal_batch_id" "text",
    "amount" numeric(10,2),
    "recipient_email" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."payout_audit_log" OWNER TO "postgres";


COMMENT ON TABLE "public"."payout_audit_log" IS 'Audit trail for all payout processing actions';



COMMENT ON COLUMN "public"."payout_audit_log"."action" IS 'Type of action: processed, approved, rejected, etc.';



COMMENT ON COLUMN "public"."payout_audit_log"."recipient_email" IS 'Partially masked PayPal email for security';



CREATE OR REPLACE VIEW "public"."payout_history_view" WITH ("security_invoker"='true') AS
 SELECT "pr"."id",
    "pr"."user_id",
    "p"."username",
    COALESCE("pr"."cash_amount", (0)::numeric) AS "cash_amount",
    COALESCE("pr"."coins_redeemed", "pr"."requested_coins", "pr"."coin_amount", (0)::bigint) AS "coins_redeemed",
    "pr"."status",
    "pr"."created_at",
    "pr"."processed_at",
    "pr"."admin_id",
    "admin_p"."username" AS "admin_username",
    "pr"."notes",
        CASE
            WHEN (COALESCE("pr"."cash_amount", (0)::numeric) > (0)::numeric) THEN "pr"."cash_amount"
            ELSE ((COALESCE("pr"."coins_redeemed", "pr"."requested_coins", "pr"."coin_amount", (0)::bigint))::numeric / 100.0)
        END AS "usd_equivalent"
   FROM (("public"."payout_requests" "pr"
     JOIN "public"."user_profiles" "p" ON (("p"."id" = "pr"."user_id")))
     LEFT JOIN "public"."user_profiles" "admin_p" ON (("admin_p"."id" = "pr"."admin_id")))
  ORDER BY "pr"."created_at" DESC;


ALTER VIEW "public"."payout_history_view" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."payout_reviews" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "reviewer_id" "uuid" NOT NULL,
    "decision" "text",
    "notes" "text",
    "risk_score" numeric(6,2),
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."payout_reviews" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."payout_reviews" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."payout_settings" (
    "user_id" "uuid" NOT NULL,
    "paypal_email" "text",
    "payout_threshold" bigint DEFAULT 7000,
    "payouts_enabled" boolean DEFAULT false,
    "min_request_coins" bigint DEFAULT 7000,
    "max_request_coins" bigint DEFAULT 250000,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."payout_settings" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."payout_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."payouts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "user_name" "text",
    "amount_coins" bigint NOT NULL,
    "amount_usd" numeric(10,2) NOT NULL,
    "status" "text" DEFAULT 'pending'::"text",
    "paypal_email" "text",
    "risk_score" numeric,
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "denied_by" "uuid",
    "denied_at" timestamp with time zone,
    "deny_reason" "text",
    "completed_at" timestamp with time zone,
    "batch_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "amount" numeric(12,2) DEFAULT 0 NOT NULL,
    "coins" integer DEFAULT 0 NOT NULL,
    "coins_used" integer DEFAULT 0 NOT NULL,
    "p_payout_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    CONSTRAINT "payouts_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'processing'::"text", 'completed'::"text", 'denied'::"text", 'needs_review'::"text"])))
);

ALTER TABLE ONLY "public"."payouts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."payouts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."perk_catalog" (
    "id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text" NOT NULL,
    "cost_coins" integer NOT NULL,
    "duration_minutes" integer NOT NULL,
    "perk_type" "text" NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "is_enabled" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."perk_catalog" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."perks" (
    "id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "cost" integer NOT NULL,
    "description" "text" NOT NULL,
    "duration_minutes" integer NOT NULL,
    "icon" "text",
    "perk_type" "text" NOT NULL,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "perks_cost_check" CHECK (("cost" >= 0)),
    CONSTRAINT "perks_perk_type_check" CHECK (("perk_type" = ANY (ARRAY['visibility'::"text", 'chat'::"text", 'protection'::"text", 'boost'::"text", 'cosmetic'::"text"])))
);


ALTER TABLE "public"."perks" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."platform_fees" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "fee_amount" integer NOT NULL,
    "balance_before" integer NOT NULL,
    "balance_after" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."platform_fees" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."platform_fees" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."platform_profit" (
    "date" "date" NOT NULL,
    "total_profit" numeric(12,2) DEFAULT 0,
    "payment_count" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."platform_profit" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."platform_revenue" (
    "date" "date" NOT NULL,
    "total_revenue" numeric(12,2) DEFAULT 0,
    "transaction_count" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."platform_revenue" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."platform_wallet" (
    "id" integer NOT NULL,
    "total_revenue_usd" numeric(12,2) DEFAULT 0 NOT NULL,
    "total_payouts_usd" numeric(12,2) DEFAULT 0 NOT NULL,
    "net_profit_usd" numeric(12,2) GENERATED ALWAYS AS (("total_revenue_usd" - "total_payouts_usd")) STORED,
    "last_updated" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "platform_wallet_id_check" CHECK (("id" = 1))
);

ALTER TABLE ONLY "public"."platform_wallet" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."platform_wallet" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."post_gifts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "post_id" "uuid",
    "sender_id" "uuid",
    "gift_type" "text",
    "coin_value" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."post_gifts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."post_gifts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."posts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "content" "text",
    "image_url" "text",
    "video_url" "text",
    "category" "text",
    "coins_earned" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "is_featured" boolean DEFAULT false
);

ALTER TABLE ONLY "public"."posts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."posts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
    "role" "text" DEFAULT 'user'::"text" NOT NULL,
    "broadcasting_disabled" boolean DEFAULT false NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "troll_coins" bigint DEFAULT 0 NOT NULL,
    "hired_by" "uuid",
    "hired_at" timestamp with time zone,
    "probation_ends_at" timestamp with time zone,
    "officer_status" "text" DEFAULT 'active'::"text" NOT NULL,
    "tax_status" "text",
    "tax_last_updated" timestamp with time zone,
    "recruiter_id" "uuid",
    "auth_user_id" "uuid",
    "username" "text",
    "user_id" "uuid",
    CONSTRAINT "profiles_officer_status_check" CHECK (("officer_status" = ANY (ARRAY['active'::"text", 'probation'::"text", 'suspended'::"text"]))),
    CONSTRAINT "profiles_troll_coins_nonnegative" CHECK (("troll_coins" >= 0)),
    CONSTRAINT "role_check" CHECK (("role" = ANY (ARRAY['admin'::"text", 'secretary'::"text", 'lead_troll_officer'::"text", 'troll_officer'::"text", 'user'::"text"])))
);

ALTER TABLE ONLY "public"."profiles" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."profiles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."promo_code_uses" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "promo_code_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "transaction_id" "uuid",
    "discount_applied" numeric(10,2),
    "original_price" numeric(10,2),
    "final_price" numeric(10,2),
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."promo_code_uses" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."promo_code_uses" OWNER TO "postgres";


COMMENT ON TABLE "public"."promo_code_uses" IS 'Tracks promo code usage by users';



CREATE TABLE IF NOT EXISTS "public"."promo_codes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" "text" NOT NULL,
    "discount_percent" integer NOT NULL,
    "discount_amount" numeric(10,2),
    "is_active" boolean DEFAULT true,
    "is_empire_partner_only" boolean DEFAULT false,
    "max_uses" integer,
    "current_uses" integer DEFAULT 0,
    "valid_from" timestamp with time zone DEFAULT "now"(),
    "valid_until" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "promo_codes_discount_percent_check" CHECK ((("discount_percent" >= 0) AND ("discount_percent" <= 100)))
);

ALTER TABLE ONLY "public"."promo_codes" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."promo_codes" OWNER TO "postgres";


COMMENT ON TABLE "public"."promo_codes" IS 'Promo codes for coin store discounts. Empire Partner codes are test codes.';



CREATE TABLE IF NOT EXISTS "public"."properties" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "name" "text",
    "address" "text",
    "city" "text",
    "state" "text",
    "zip" "text",
    "owner_id" "uuid",
    "ask_price" numeric,
    "base_price" numeric,
    "base_value" numeric,
    "condition_factor" numeric,
    "is_listed" boolean DEFAULT true NOT NULL,
    "is_starter" boolean DEFAULT false NOT NULL,
    "owner_user_id" "uuid",
    "upgrade_spend_total" numeric(12,2) DEFAULT 0 NOT NULL,
    CONSTRAINT "properties_upgrade_spend_total_nonnegative" CHECK (("upgrade_spend_total" >= (0)::numeric))
);


ALTER TABLE "public"."properties" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."property_upgrades" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "property_id" "uuid" NOT NULL,
    "owner_user_id" "uuid",
    "upgrade_key" "text",
    "upgrade_name" "text",
    "level" integer DEFAULT 1 NOT NULL,
    "cost" numeric(12,2) DEFAULT 0 NOT NULL,
    "applied_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "notes" "text",
    "status" "text" DEFAULT 'applied'::"text" NOT NULL,
    "tasks_completed" integer DEFAULT 0 NOT NULL,
    "tasks_required_total" integer DEFAULT 0 NOT NULL,
    "upgrade_type" "text" DEFAULT 'standard'::"text" NOT NULL,
    CONSTRAINT "property_upgrades_tasks_completed_nonnegative" CHECK (("tasks_completed" >= 0)),
    CONSTRAINT "property_upgrades_tasks_required_total_nonnegative" CHECK (("tasks_required_total" >= 0))
);


ALTER TABLE "public"."property_upgrades" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."provider_costs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "provider" "public"."provider_enum" NOT NULL,
    "current_cost" numeric(12,2) DEFAULT 0 NOT NULL,
    "projected_monthly_cost" numeric(10,2) DEFAULT 0 NOT NULL,
    "billing_period_start" timestamp with time zone,
    "billing_period_end" timestamp with time zone,
    "next_payment_due" timestamp with time zone,
    "status" "public"."provider_status_enum" DEFAULT 'ok'::"public"."provider_status_enum" NOT NULL,
    "last_synced_at" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."provider_costs" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."provider_costs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."punishment_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "coins_deducted" bigint NOT NULL,
    "reason" "text" NOT NULL,
    "appeal_id" "uuid",
    "verdict" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."punishment_transactions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."punishment_transactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."punishments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "user_name" "text",
    "stream_id" "uuid",
    "stream_title" "text",
    "streamer_id" "uuid",
    "streamer_name" "text",
    "type" "text",
    "reason" "text",
    "report_type" "text",
    "issued_by" "uuid",
    "issued_by_name" "text",
    "status" "text" DEFAULT 'active'::"text",
    "court_date" timestamp with time zone,
    "court_fee" bigint DEFAULT 0,
    "times_paid" integer DEFAULT 0,
    "fee_paid" boolean DEFAULT false,
    "expires_at" timestamp with time zone,
    "reported_by" "uuid",
    "reported_by_name" "text",
    "punishment_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."punishments" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."punishments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."referral_claims" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "referred_user_id" "uuid",
    "referral_code" "text",
    "reward_type" "text" DEFAULT 'coins'::"text",
    "reward_amount" integer DEFAULT 0,
    "status" "text" DEFAULT 'pending'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "claimed_at" timestamp with time zone
);


ALTER TABLE "public"."referral_claims" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."referral_monthly_bonus" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "recruiter_id" "uuid" NOT NULL,
    "referred_user_id" "uuid" NOT NULL,
    "month" "text" NOT NULL,
    "coins_earned" bigint NOT NULL,
    "bonus_paid_coins" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."referral_monthly_bonus" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."referral_monthly_bonus" OWNER TO "postgres";


COMMENT ON TABLE "public"."referral_monthly_bonus" IS 'Tracks monthly bonus payouts to recruiters, prevents double payouts';



CREATE TABLE IF NOT EXISTS "public"."referrals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "recruiter_id" "uuid" NOT NULL,
    "referred_user_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "status" "text" DEFAULT 'pending'::"text",
    "referrer_id" "uuid",
    "referred_id" "uuid",
    "referrer_name" "text",
    "referred_name" "text",
    "reward_amount" bigint DEFAULT 0,
    "milestone_reached" boolean DEFAULT false,
    "completed_at" timestamp with time zone,
    "referred_at" timestamp with time zone DEFAULT "now"(),
    "reward_status" "public"."reward_status_enum" DEFAULT 'pending'::"public"."reward_status_enum" NOT NULL,
    "deadline" timestamp with time zone DEFAULT ("now"() + '21 days'::interval),
    "user_id" "uuid",
    CONSTRAINT "referrals_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'completed'::"text", 'rewarded'::"text"])))
);

ALTER TABLE ONLY "public"."referrals" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."referrals" OWNER TO "postgres";


COMMENT ON TABLE "public"."referrals" IS 'Tracks recruiter-referred user relationships for Troll Empire Partner Program';



CREATE TABLE IF NOT EXISTS "public"."report_cases" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "stream_id" "uuid",
    "reason" "text",
    "severity" "text" DEFAULT 'low'::"text",
    "status" "text" DEFAULT 'open'::"text",
    "meta" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "report_cases_severity_check" CHECK (("severity" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text"])))
);

ALTER TABLE ONLY "public"."report_cases" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."report_cases" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."reputation_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "target_id" "uuid" NOT NULL,
    "reputation_type" character varying(20) NOT NULL,
    "event_type" character varying(50) NOT NULL,
    "score_change" integer NOT NULL,
    "previous_score" integer,
    "new_score" integer,
    "reason" "text",
    "triggered_by" "uuid",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."reputation_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."revenue_ledger" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "related_user_id" "uuid",
    "entry_type" "text" NOT NULL,
    "coins" integer DEFAULT 0 NOT NULL,
    "usd_amount" numeric(10,2) DEFAULT 0,
    "transaction_ref" "text",
    "source" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    CONSTRAINT "revenue_ledger_entry_type_check" CHECK (("entry_type" = ANY (ARRAY['coin_purchase'::"text", 'gift_sent'::"text", 'gift_received'::"text", 'cashout'::"text", 'adjustment'::"text"]))),
    CONSTRAINT "revenue_ledger_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'completed'::"text", 'failed'::"text", 'reversed'::"text"])))
);

ALTER TABLE ONLY "public"."revenue_ledger" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."revenue_ledger" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."revenue_settings" (
    "id" integer DEFAULT 1 NOT NULL,
    "platform_cut_pct" integer DEFAULT 40,
    "broadcaster_cut_pct" integer DEFAULT 60,
    "officer_cut_pct" integer DEFAULT 30,
    "min_cashout_usd" numeric(10,2) DEFAULT 21,
    "min_stream_hours_for_cashout" numeric(10,2) DEFAULT 5,
    "cashout_hold_days" integer DEFAULT 0,
    "tax_form_required" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."revenue_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."risk_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "event_type" "text" NOT NULL,
    "severity" integer NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."risk_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."role_change_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "changed_by" "uuid" NOT NULL,
    "target_user" "uuid" NOT NULL,
    "old_role" "text",
    "new_role" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."role_change_log" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."role_change_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."role_privileges" (
    "role" "text" NOT NULL,
    "can_moderate_chat" boolean DEFAULT false NOT NULL,
    "can_hold_court" boolean DEFAULT false NOT NULL,
    "can_ban_users" boolean DEFAULT false NOT NULL,
    "can_demote_officers" boolean DEFAULT false NOT NULL,
    "can_promote_officers" boolean DEFAULT false NOT NULL
);

ALTER TABLE ONLY "public"."role_privileges" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."role_privileges" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."roles" (
    "id" integer NOT NULL,
    "name" "text" NOT NULL
);

ALTER TABLE ONLY "public"."roles" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."roles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."rooms" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."rooms" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."royal_family_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "admin_id" "uuid" NOT NULL,
    "event_type" character varying(50) NOT NULL,
    "title_type" character varying(20),
    "details" "jsonb" DEFAULT '{}'::"jsonb",
    "event_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."royal_family_history" OWNER TO "postgres";


COMMENT ON TABLE "public"."royal_family_history" IS 'Audit log of royal family title changes and events';



CREATE OR REPLACE VIEW "public"."royal_family_leaderboard" AS
 SELECT "user_id",
    "count"(*) AS "total_events",
    "max"("created_at") AS "last_event_at"
   FROM "public"."royal_family_history"
  GROUP BY "user_id"
  ORDER BY ("count"(*)) DESC, ("max"("created_at")) DESC;


ALTER VIEW "public"."royal_family_leaderboard" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."royal_family_perks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title_id" "uuid" NOT NULL,
    "perk_type" character varying(50) NOT NULL,
    "perk_level" integer NOT NULL,
    "unlocked_at" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."royal_family_perks" OWNER TO "postgres";


COMMENT ON TABLE "public"."royal_family_perks" IS 'Duration-based cosmetic perks for royal family members';



CREATE TABLE IF NOT EXISTS "public"."royal_family_titles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "admin_id" "uuid" NOT NULL,
    "title_type" character varying(20) NOT NULL,
    "is_active" boolean DEFAULT true,
    "assigned_at" timestamp with time zone DEFAULT "now"(),
    "unassigned_at" timestamp with time zone,
    "total_coins_at_assignment" bigint NOT NULL,
    "duration_days" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "royal_family_titles_title_type_check" CHECK ((("title_type")::"text" = ANY ((ARRAY['wife'::character varying, 'husband'::character varying, 'former_wife'::character varying, 'former_husband'::character varying])::"text"[])))
);


ALTER TABLE "public"."royal_family_titles" OWNER TO "postgres";


COMMENT ON TABLE "public"."royal_family_titles" IS 'Current and historical royal family titles (Wife/Husband)';



CREATE TABLE IF NOT EXISTS "public"."scheduled_announcements" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "message" "text" NOT NULL,
    "start_time" timestamp with time zone NOT NULL,
    "end_time" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "scheduled_time" timestamp with time zone NOT NULL
);

ALTER TABLE ONLY "public"."scheduled_announcements" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."scheduled_announcements" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."secretary_assignments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "secretary_id" "uuid" NOT NULL,
    "assigned_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."secretary_assignments" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."secretary_assignments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."security_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "url" "text" NOT NULL,
    "user_agent" "text",
    "ip_address" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."security_events" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."security_events" OWNER TO "postgres";


COMMENT ON TABLE "public"."security_events" IS 'Log of all security events and detected threats';



CREATE OR REPLACE VIEW "public"."seller_appeals_queue" AS
 SELECT "a"."id",
    "a"."user_id",
    "a"."type",
    "a"."status",
    "a"."reason",
    "a"."goals",
    "a"."data",
    "a"."created_at",
    "a"."updated_at",
    "a"."reviewed_at",
    "a"."reviewed_by",
    "a"."role_applied",
    "a"."application_data",
    "a"."lead_officer_approved",
    "a"."lead_officer_approved_at",
    "a"."application_id",
    "a"."lead_officer_reviewed_at",
    "a"."lead_officer_reviewed_by",
    "a"."appeal_requested",
    "a"."appeal_message",
    "a"."appeal_submitted_at",
    "a"."appeal_status",
    "a"."appeal_reviewed_at",
    "a"."appeal_reviewed_by",
    "a"."training_score",
    "a"."training_completed",
    "a"."training_completed_at",
    "a"."training_required",
    "a"."training_attempts",
    "a"."training_last_attempt_at",
    "a"."experience",
    "a"."experience_years",
    "a"."experience_level",
    "a"."portfolio_url",
    "a"."bio",
    "a"."training_passed",
    "a"."appeal_reason",
    "a"."appeal_requested_at",
    "a"."appeal_notes",
    "up"."username",
    "up"."email",
    (EXTRACT(epoch FROM ("now"() - "a"."appeal_requested_at")) / (86400)::numeric) AS "days_since_appeal"
   FROM ("public"."applications" "a"
     LEFT JOIN "public"."user_profiles" "up" ON (("a"."user_id" = "up"."id")))
  WHERE (("a"."type" = 'seller'::"text") AND ("a"."appeal_requested" = true) AND ("a"."appeal_status" = 'pending'::"text"))
  ORDER BY "a"."appeal_requested_at";


ALTER VIEW "public"."seller_appeals_queue" OWNER TO "postgres";


COMMENT ON VIEW "public"."seller_appeals_queue" IS 'Shows pending seller appeals for admin review';



CREATE TABLE IF NOT EXISTS "public"."seller_reliability" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "seller_id" "uuid" NOT NULL,
    "current_score" integer DEFAULT 100,
    "lifetime_score" integer DEFAULT 100,
    "orders_fulfilled" integer DEFAULT 0,
    "orders_cancelled" integer DEFAULT 0,
    "disputes_raised" integer DEFAULT 0,
    "disputes_won" integer DEFAULT 0,
    "refunds_processed" integer DEFAULT 0,
    "average_fulfillment_time_hours" integer,
    "reliability_tier" character varying(20) DEFAULT 'standard'::character varying,
    "is_high_risk" boolean DEFAULT false,
    "last_order_date" timestamp with time zone,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."seller_reliability" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."shadow_bans" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "officer_id" "uuid" NOT NULL,
    "target_user_id" "uuid" NOT NULL,
    "stream_id" "uuid",
    "banned_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone,
    "reason" "text",
    "is_active" boolean DEFAULT true
);

ALTER TABLE ONLY "public"."shadow_bans" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."shadow_bans" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."shifts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "user_name" "text",
    "role" "text",
    "title" "text",
    "date" "date",
    "type" "text",
    "message" "text",
    "failed" boolean DEFAULT false,
    "body" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "status" "text" DEFAULT 'scheduled'::"text",
    CONSTRAINT "shifts_status_check" CHECK (("status" = ANY (ARRAY['scheduled'::"text", 'active'::"text", 'completed'::"text", 'cancelled'::"text"])))
);

ALTER TABLE ONLY "public"."shifts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."shifts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."shop_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "price_coins" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "shop_id" "uuid"
);

ALTER TABLE ONLY "public"."shop_items" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."shop_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."shop_partners" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "partner_code" "text",
    "commission_rate" numeric DEFAULT 0.05,
    "total_earnings" bigint DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."shop_partners" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."shop_partners" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."shop_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "item_id" "uuid" NOT NULL,
    "quantity" integer NOT NULL,
    "coins_spent" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "shop_id" "uuid",
    CONSTRAINT "shop_transactions_coins_spent_check" CHECK (("coins_spent" > 0)),
    CONSTRAINT "shop_transactions_quantity_check" CHECK (("quantity" > 0))
);

ALTER TABLE ONLY "public"."shop_transactions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."shop_transactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."shops" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "owner_id" "uuid",
    "name" "text" NOT NULL,
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."shops" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."shops" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."special_gift_earnings" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "receiver_username" "text" NOT NULL,
    "gift_type" "text" NOT NULL,
    "total_earned_coins" integer DEFAULT 0,
    "cap_limit" integer NOT NULL,
    "capped" boolean DEFAULT false,
    "updated_at" timestamp without time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."special_gift_earnings" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."special_gift_earnings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."square_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "event_id" "text" NOT NULL,
    "type" "text" NOT NULL,
    "data" "jsonb" NOT NULL,
    "processed" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."square_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."staff_applications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "applied_role" "text" NOT NULL,
    "full_name" "text" NOT NULL,
    "username" "text",
    "email" "text" NOT NULL,
    "phone" "text",
    "location_city" "text",
    "location_state" "text",
    "location_country" "text",
    "time_zone" "text",
    "preferred_contact_method" "text",
    "discord" "text",
    "telegram" "text",
    "experience" "text",
    "availability" "text",
    "status" "text" DEFAULT 'pending'::"text",
    "reviewer_id" "uuid",
    "internal_notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "staff_applications_applied_role_check" CHECK (("applied_role" = ANY (ARRAY['troller'::"text", 'troll_officer'::"text", 'lead_troll_officer'::"text"]))),
    CONSTRAINT "staff_applications_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'interview'::"text", 'approved'::"text", 'hired'::"text", 'rejected'::"text"])))
);

ALTER TABLE ONLY "public"."staff_applications" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."staff_applications" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."staff_profiles" (
    "staff_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "role" "text" NOT NULL,
    "status" "text" DEFAULT 'active'::"text",
    "hired_at" timestamp with time zone DEFAULT "now"(),
    "full_name" "text" NOT NULL,
    "username" "text",
    "email" "text" NOT NULL,
    "phone" "text",
    "location_city" "text",
    "location_state" "text",
    "location_country" "text",
    "time_zone" "text",
    "preferred_contact_method" "text",
    "discord" "text",
    "telegram" "text",
    "paypal_email" "text",
    "emergency_contact_name" "text",
    "emergency_contact_phone" "text",
    "performance_score" integer DEFAULT 0,
    "warnings_count" integer DEFAULT 0,
    "last_active" timestamp with time zone,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "staff_profiles_role_check" CHECK (("role" = ANY (ARRAY['troller'::"text", 'troll_officer'::"text", 'lead_troll_officer'::"text"]))),
    CONSTRAINT "staff_profiles_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'probation'::"text", 'suspended'::"text", 'terminated'::"text"])))
);

ALTER TABLE ONLY "public"."staff_profiles" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."staff_profiles" OWNER TO "postgres";


COMMENT ON TABLE "public"."staff_profiles" IS 'Comprehensive staff profiles with contact information, employment status, and performance metrics';



CREATE TABLE IF NOT EXISTS "public"."store_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "type" "text" NOT NULL,
    "price_coins" bigint NOT NULL,
    "is_active" boolean DEFAULT true,
    "sort_order" integer DEFAULT 0,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "store_items_type_check" CHECK (("type" = ANY (ARRAY['badge'::"text", 'effect'::"text", 'emote'::"text", 'theme'::"text", 'entrance'::"text"])))
);

ALTER TABLE ONLY "public"."store_items" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."store_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stores" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "owner_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "status" "text" DEFAULT 'active'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "stores_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'suspended'::"text", 'closed'::"text"])))
);


ALTER TABLE "public"."stores" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_discovery_prefs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "preferred_categories" "text"[] DEFAULT '{}'::"text"[],
    "preferred_languages" "text"[] DEFAULT '{}'::"text"[],
    "content_rating_min" integer DEFAULT 0,
    "avoid_categories" "text"[] DEFAULT '{}'::"text"[],
    "discovery_algorithm" character varying(20) DEFAULT 'balanced'::character varying,
    "last_updated" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."stream_discovery_prefs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_entrances" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "stream_id" "uuid",
    "user_id" "uuid",
    "role" "text",
    "created_at" timestamp without time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."stream_entrances" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_entrances" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_entries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid",
    "user_id" "uuid",
    "coins_charged" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."stream_entries" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_entries" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid",
    "user_id" "uuid",
    "event_type" "text" NOT NULL,
    "payload" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."stream_events" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_gifts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid",
    "sender_id" "uuid",
    "sender_name" "text",
    "gift_type" "text",
    "coins_spent" integer NOT NULL,
    "message" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "coins_amount" bigint DEFAULT 0 NOT NULL
);

ALTER TABLE ONLY "public"."stream_gifts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_gifts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_join_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "stream_join_requests_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text"])))
);

ALTER TABLE ONLY "public"."stream_join_requests" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_join_requests" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_likes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."stream_likes" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_likes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_messages" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "username" "text",
    "message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "message_type" "text" DEFAULT 'chat'::"text",
    "content" "text",
    "role" "text"
);

ALTER TABLE ONLY "public"."stream_messages" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_messages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_momentum" (
    "stream_id" "uuid" NOT NULL,
    "momentum" integer DEFAULT 100 NOT NULL,
    "last_gift_at" timestamp with time zone,
    "last_decay_at" timestamp with time zone,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "stream_momentum_momentum_check" CHECK ((("momentum" >= 0) AND ("momentum" <= 100)))
);

ALTER TABLE ONLY "public"."stream_momentum" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_momentum" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_mute_counts" (
    "stream_id" "uuid" NOT NULL,
    "target_user_id" "uuid" NOT NULL,
    "mute_count" integer DEFAULT 0 NOT NULL,
    "last_muted_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."stream_mute_counts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_mute_counts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_passwords" (
    "stream_id" "uuid" NOT NULL,
    "password_hash" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."stream_passwords" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_presets" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "preset_data" "jsonb" NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."stream_presets" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_presets" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_ranking" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "viewer_count" integer DEFAULT 0,
    "gift_velocity" numeric(10,2) DEFAULT 0,
    "viewer_velocity" numeric(10,2) DEFAULT 0,
    "engagement_score" numeric(5,2) DEFAULT 0,
    "trending_score" numeric(5,2) DEFAULT 0,
    "freshness_bonus" numeric(5,2) DEFAULT 0,
    "creator_reputation" numeric(5,2) DEFAULT 0,
    "final_score" numeric(8,2) DEFAULT 0,
    "rank_position" integer,
    "last_updated" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."stream_ranking" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_reactions" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "stream_id" "uuid",
    "user_id" "uuid",
    "reaction_type" "text",
    "created_at" timestamp without time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."stream_reactions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_reactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_reports" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "reporter_id" "uuid",
    "reason" "text",
    "severity" "text" DEFAULT 'minor'::"text",
    "status" "text" DEFAULT 'pending'::"text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."stream_reports" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_reports" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_sessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "streamer_id" "uuid" NOT NULL,
    "title" "text",
    "viewer_count" integer DEFAULT 0 NOT NULL,
    "status" "text" DEFAULT 'active'::"text" NOT NULL,
    "started_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "ended_at" timestamp with time zone,
    CONSTRAINT "stream_sessions_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'ended'::"text"])))
);

ALTER TABLE ONLY "public"."stream_sessions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_sessions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_snack_purchases" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "snack_key" "text" NOT NULL,
    "coins_spent" bigint NOT NULL,
    "momentum_delta" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    CONSTRAINT "stream_snack_purchases_coins_spent_check" CHECK (("coins_spent" > 0))
);

ALTER TABLE ONLY "public"."stream_snack_purchases" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_snack_purchases" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_viewers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "joined_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "last_seen" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."stream_viewers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stream_vods" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid",
    "recording_url" "text",
    "duration_seconds" integer,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."stream_vods" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_vods" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."streams_participants" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "text" DEFAULT 'guest'::"text" NOT NULL,
    "livekit_identity" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_moderator" boolean DEFAULT false,
    "can_chat" boolean DEFAULT true,
    "chat_mute_until" timestamp with time zone,
    CONSTRAINT "streams_participants_role_check" CHECK (("role" = ANY (ARRAY['host'::"text", 'opponent'::"text", 'guest'::"text"])))
);

ALTER TABLE ONLY "public"."streams_participants" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."streams_participants" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."support_tickets" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "username" "text",
    "email" "text",
    "subject" "text",
    "category" "text" DEFAULT 'general'::"text",
    "message" "text",
    "body" "text",
    "status" "text" DEFAULT 'open'::"text" NOT NULL,
    "admin_response" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."support_tickets" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."support_tickets" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."system_alerts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "alert_type" "text" NOT NULL,
    "title" "text" NOT NULL,
    "message" "text" NOT NULL,
    "severity" "text" DEFAULT 'info'::"text",
    "status" "text" DEFAULT 'open'::"text",
    "user_id" "uuid",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "acknowledged_at" timestamp with time zone,
    "resolved_at" timestamp with time zone
);


ALTER TABLE "public"."system_alerts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."system_errors" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "location" "text",
    "message" "text" NOT NULL,
    "stack" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "severity" "text" DEFAULT 'error'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "component" "text",
    "context" "jsonb",
    "status" "text" DEFAULT 'open'::"text",
    "acknowledged_at" timestamp with time zone,
    "resolved_at" timestamp with time zone,
    "url" "text",
    "route" "text",
    "function_name" "text",
    "file_name" "text",
    "line_number" integer,
    "user_agent" "text",
    CONSTRAINT "system_errors_status_check" CHECK (("status" = ANY (ARRAY['open'::"text", 'acknowledged'::"text", 'resolved'::"text"])))
);


ALTER TABLE "public"."system_errors" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."task_completions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "task_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "family_id" "uuid" NOT NULL,
    "completion_proof" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."task_completions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."task_completions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."task_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "task_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "status" "text" NOT NULL,
    "proof_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "task_history_status_check" CHECK (("status" = ANY (ARRAY['completed'::"text", 'failed'::"text"])))
);

ALTER TABLE ONLY "public"."task_history" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."task_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."task_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "task_type" "text" NOT NULL,
    "category" "text",
    "title" "text" NOT NULL,
    "description" "text",
    "reward_coins" bigint DEFAULT 0,
    "reward_xp" integer DEFAULT 0,
    "completion_rules" "text" DEFAULT 'individual'::"text",
    "max_participants" integer DEFAULT 1,
    "duration_hours" integer DEFAULT 24,
    "difficulty" "text" DEFAULT 'medium'::"text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."task_templates" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."task_templates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tax_report_status" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "year" integer NOT NULL,
    "total_earnings_cents" integer DEFAULT 0 NOT NULL,
    "reached_threshold" boolean DEFAULT false,
    "form_1099_generated" boolean DEFAULT false,
    "form_1099_url" "text",
    "last_updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."tax_report_status" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."tax_report_status" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ticket_messages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ticket_id" "uuid" NOT NULL,
    "sender_id" "uuid",
    "message" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."ticket_messages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."training_scenarios" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "scenario_name" "text" NOT NULL,
    "event_type" "text" NOT NULL,
    "script" "text" DEFAULT ''::"text",
    "correct_action" "text" NOT NULL,
    "severity" integer NOT NULL,
    "points_awarded" integer DEFAULT 10 NOT NULL,
    "scenario_type" "text" DEFAULT 'general'::"text" NOT NULL,
    "description" "text" DEFAULT ''::"text" NOT NULL,
    "chat_messages" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "difficulty_level" integer DEFAULT 1
);

ALTER TABLE ONLY "public"."training_scenarios" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."training_scenarios" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "type" "text",
    "transaction_type" "text",
    "coins_used" bigint,
    "amount" numeric(12,2),
    "description" "text",
    "status" "text",
    "payment_method" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "paypal_order_id" "text",
    "paypal_transaction_id" "text",
    "paypal_payer_id" "text",
    "stream_id" "uuid",
    "gift_beneficiary" "uuid",
    "is_app_sponsored" boolean DEFAULT false,
    "amount_usd" numeric(10,2),
    "paypal_capture_id" "text"
);

ALTER TABLE ONLY "public"."transactions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."transactions" OWNER TO "postgres";


COMMENT ON COLUMN "public"."transactions"."paypal_order_id" IS 'PayPal order ID from checkout';



COMMENT ON COLUMN "public"."transactions"."paypal_transaction_id" IS 'PayPal transaction ID after capture';



CREATE TABLE IF NOT EXISTS "public"."troll_ai_avatars" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text",
    "role" "text",
    "is_active" boolean DEFAULT true
);

ALTER TABLE ONLY "public"."troll_ai_avatars" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_ai_avatars" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_battle_gifts" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "battle_id" "uuid" NOT NULL,
    "sender_id" "uuid" NOT NULL,
    "receiver_role" "text" NOT NULL,
    "is_paid" boolean DEFAULT true NOT NULL,
    "amount" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "troll_battle_gifts_receiver_role_check" CHECK (("receiver_role" = ANY (ARRAY['host'::"text", 'challenger'::"text"])))
);

ALTER TABLE ONLY "public"."troll_battle_gifts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_battle_gifts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_court_cases" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "defendant_id" "uuid",
    "prosecutor_id" "uuid",
    "judge_id" "uuid",
    "stream_id" "text",
    "accusation" "text",
    "status" "text" DEFAULT 'pending'::"text",
    "fine_coins" integer DEFAULT 0,
    "scheduled_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "plaintiff_id" "uuid" NOT NULL,
    "assigned_judge_id" "uuid",
    CONSTRAINT "troll_court_cases_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'scheduled'::"text", 'complete'::"text"])))
);

ALTER TABLE ONLY "public"."troll_court_cases" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_court_cases" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_dna_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "event_type" "text" NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."troll_dna_events" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_dna_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_dna_profiles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "avatar_type" "text" DEFAULT 'default_troll'::"text",
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."troll_dna_profiles" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_dna_profiles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_dna_traits" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "key" "text" NOT NULL,
    "name" "text" NOT NULL,
    "rarity" "text" NOT NULL,
    "icon" "text",
    "effect_class" "text",
    "config" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."troll_dna_traits" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_dna_traits" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_drops" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "stream_id" "uuid",
    "drop_type" "text",
    "coin_delta" bigint,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone,
    "claimed" boolean DEFAULT false NOT NULL
);

ALTER TABLE ONLY "public"."troll_drops" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_drops" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_drops_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "cycle_start" timestamp with time zone NOT NULL,
    "cycle_end" timestamp with time zone NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "broadcaster_id" "uuid" NOT NULL,
    "amount_paid_coins" bigint NOT NULL,
    "pool_key" "text" NOT NULL,
    "pool_balance_before" bigint NOT NULL,
    "pool_balance_after" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "troll_drops_log_amount_paid_coins_check" CHECK (("amount_paid_coins" > 0)),
    CONSTRAINT "troll_drops_log_pool_balance_after_check" CHECK (("pool_balance_after" >= 0)),
    CONSTRAINT "troll_drops_log_pool_balance_before_check" CHECK (("pool_balance_before" >= 0))
);

ALTER TABLE ONLY "public"."troll_drops_log" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_drops_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_event_claims" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "event_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "clicked_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."troll_event_claims" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "troll_type" "text" NOT NULL,
    "reward_amount" integer DEFAULT 10 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone NOT NULL,
    "active" boolean DEFAULT true,
    CONSTRAINT "troll_events_troll_type_check" CHECK (("troll_type" = ANY (ARRAY['red'::"text", 'green'::"text"])))
);


ALTER TABLE "public"."troll_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_families" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_name" "text" NOT NULL,
    "family_tag" "text",
    "leader_id" "uuid" NOT NULL,
    "family_logo_url" "text",
    "description" "text" DEFAULT 'Welcome to our Troll Family!'::"text",
    "level" integer DEFAULT 1,
    "xp" bigint DEFAULT 0,
    "total_members" integer DEFAULT 1,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "name" "text",
    "banner_url" "text",
    "icon_url" "text",
    "created_by" "uuid",
    "is_verified" boolean DEFAULT false,
    "emblem_url" "text"
);

ALTER TABLE ONLY "public"."troll_families" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_families" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_family_members" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "text" DEFAULT 'member'::"text",
    "is_royal_troll" boolean DEFAULT false,
    "rank_name" "text",
    "joined_by" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."troll_family_members" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_family_members" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_family_memberships" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "text" DEFAULT 'member'::"text",
    "joined_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."troll_family_memberships" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_family_messages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "family_id" "uuid" NOT NULL,
    "sender_id" "uuid" NOT NULL,
    "message" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."troll_family_messages" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_family_messages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_family_wars" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "challenger_family_id" "uuid" NOT NULL,
    "defender_family_id" "uuid" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text",
    "challenger_score" integer DEFAULT 0,
    "defender_score" integer DEFAULT 0,
    "start_time" timestamp with time zone,
    "end_time" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."troll_family_wars" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_family_wars" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_gift_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "icon_url" "text",
    "coin_cost" integer NOT NULL,
    "is_active" boolean DEFAULT true
);

ALTER TABLE ONLY "public"."troll_gift_items" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_gift_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_officer_applications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."troll_officer_applications" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_officer_applications" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_officers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "rank" "text" NOT NULL,
    "active" boolean DEFAULT true NOT NULL,
    "appointed_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "troll_officers_rank_check" CHECK (("rank" = ANY (ARRAY['junior'::"text", 'officer'::"text", 'lead_officer'::"text", 'admin'::"text"])))
);

ALTER TABLE ONLY "public"."troll_officers" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_officers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_post_comments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "post_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "content" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."troll_post_comments" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_post_comments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_post_gifts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "post_id" "uuid" NOT NULL,
    "sender_id" "uuid" NOT NULL,
    "receiver_id" "uuid" NOT NULL,
    "gift_name" "text" NOT NULL,
    "coin_cost" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."troll_post_gifts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_post_gifts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_post_reactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "post_id" "uuid",
    "user_id" "uuid",
    "reaction_type" "text" NOT NULL,
    "coin_cost" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."troll_post_reactions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_post_reactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_post_views" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "post_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "ip_hash" "text",
    "user_agent" "text"
);

ALTER TABLE ONLY "public"."troll_post_views" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_post_views" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_posts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "content" "text",
    "image_url" "text",
    "coins_earned" integer DEFAULT 0 NOT NULL,
    "comment_count" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "media_type" "text" DEFAULT 'image'::"text",
    "video_url" "text",
    "thumbnail_url" "text",
    "free_coins_earned" integer DEFAULT 0,
    "comments_count" integer DEFAULT 0,
    "gifts_count" integer DEFAULT 0,
    CONSTRAINT "troll_posts_media_type_check" CHECK (("media_type" = ANY (ARRAY['image'::"text", 'video'::"text"])))
);

ALTER TABLE ONLY "public"."troll_posts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_posts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_stream_messages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "content" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."troll_stream_messages" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_stream_messages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_streams" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "title" "text",
    "category" "text",
    "is_live" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "viewer_count" integer DEFAULT 0
);

ALTER TABLE ONLY "public"."troll_streams" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_streams" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_wall_gifts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "post_id" "uuid" NOT NULL,
    "sender_id" "uuid" NOT NULL,
    "gift_type" "text" NOT NULL,
    "quantity" integer DEFAULT 1 NOT NULL,
    "coin_cost" bigint DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "troll_wall_gifts_gift_type_check" CHECK (("gift_type" = ANY (ARRAY['rose'::"text", 'heart'::"text", 'star'::"text", 'crown'::"text", 'diamond'::"text", 'trophy'::"text", 'coffee'::"text", 'pizza'::"text", 'rocket'::"text", 'dragon'::"text"]))),
    CONSTRAINT "troll_wall_gifts_quantity_check" CHECK (("quantity" > 0))
);


ALTER TABLE "public"."troll_wall_gifts" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."troll_wall_gifts_summary" AS
 SELECT "post_id",
    "gift_type",
    "sum"("quantity") AS "total_quantity",
    "sum"("coin_cost") AS "total_coins"
   FROM "public"."troll_wall_gifts"
  GROUP BY "post_id", "gift_type";


ALTER VIEW "public"."troll_wall_gifts_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_wall_likes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "post_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."troll_wall_likes" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_wall_likes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_wall_posts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "post_type" "text" NOT NULL,
    "content" "text" NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "likes" bigint DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "reply_to_post_id" "uuid",
    "is_pinned" boolean DEFAULT false NOT NULL,
    CONSTRAINT "troll_wall_posts_post_type_check" CHECK (("post_type" = ANY (ARRAY['text'::"text", 'stream_announce'::"text", 'battle_result'::"text", 'family_announce'::"text", 'badge_earned'::"text", 'system'::"text"])))
);

ALTER TABLE ONLY "public"."troll_wall_posts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_wall_posts" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."troll_wall_posts_view" WITH ("security_invoker"='true') AS
 SELECT "p"."id",
    "p"."user_id",
    "up"."username",
    "up"."avatar_url",
    "up"."is_admin",
    "up"."is_troll_officer",
    "up"."is_og_user",
    "p"."post_type",
    "p"."content",
    "p"."metadata",
    "p"."likes",
    "p"."created_at"
   FROM ("public"."troll_wall_posts" "p"
     LEFT JOIN "public"."user_profiles" "up" ON (("up"."id" = "p"."user_id")))
  ORDER BY "p"."created_at" DESC;


ALTER VIEW "public"."troll_wall_posts_view" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."troll_wall_reactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "post_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "reaction_type" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "troll_wall_reactions_reaction_type_check" CHECK (("reaction_type" = ANY (ARRAY['love'::"text", 'haha'::"text", 'wow'::"text", 'sad'::"text", 'angry'::"text", 'fire'::"text", 'lol'::"text", 'clap'::"text", 'mindblown'::"text"])))
);


ALTER TABLE "public"."troll_wall_reactions" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."troll_wall_reactions_summary" AS
 SELECT "post_id",
    "reaction_type",
    "count"(*) AS "reaction_count"
   FROM "public"."troll_wall_reactions"
  GROUP BY "post_id", "reaction_type";


ALTER VIEW "public"."troll_wall_reactions_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trollcity_orders" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "shop_id" "uuid" NOT NULL,
    "buyer_id" "uuid" NOT NULL,
    "product_id" "uuid" NOT NULL,
    "coins_paid" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."trollcity_orders" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollcity_orders" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trollcity_products" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "shop_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "price_paid_coins" bigint NOT NULL,
    "active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."trollcity_products" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollcity_products" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trollcity_shops" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "owner_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL
);

ALTER TABLE ONLY "public"."trollcity_shops" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollcity_shops" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trollmond_gifts" (
    "id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "icon" "text" NOT NULL,
    "cost_trollmonds" bigint NOT NULL,
    "animation_key" "text",
    "rarity" "text" DEFAULT 'Common'::"text",
    "is_enabled" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL
);


ALTER TABLE "public"."trollmond_gifts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trollmond_ledger" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "delta" bigint NOT NULL,
    "reason" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."trollmond_ledger" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollmond_ledger" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trollmond_store_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "trollmond_amount" bigint NOT NULL,
    "usd_price" numeric(10,2) NOT NULL,
    "paypal_enabled" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL
);


ALTER TABLE "public"."trollmond_store_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trollmond_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "type" "text" NOT NULL,
    "amount" bigint NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL
);


ALTER TABLE "public"."trollmond_transactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trollmonds_pools" (
    "stream_id" "uuid" NOT NULL,
    "balance" bigint DEFAULT 0 NOT NULL,
    "last_contribution_at" timestamp with time zone,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "trollmonds_pools_balance_check" CHECK (("balance" >= 0))
);

ALTER TABLE ONLY "public"."trollmonds_pools" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollmonds_pools" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trolls_night_applications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "legal_name" "text",
    "dob" "date",
    "address" "text",
    "id_document_url" "text",
    "reviewed_by" "uuid",
    "reviewed_at" timestamp with time zone,
    "review_notes" "text",
    "rejection_reason" "text",
    "rejection_count" integer DEFAULT 0 NOT NULL,
    "category_preference" "text",
    "appeal_requested" boolean DEFAULT false NOT NULL
);

ALTER TABLE ONLY "public"."trolls_night_applications" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."trolls_night_applications" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trollstown_properties" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "property_type" "text" DEFAULT 'residential'::"text",
    "label" "text",
    "zone" "text" DEFAULT 'residential'::"text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "troll_coins" bigint DEFAULT 0 NOT NULL,
    "insurance_active" boolean DEFAULT false NOT NULL,
    "insurance_policy_id" "uuid",
    "insured_at" timestamp with time zone,
    CONSTRAINT "trollstown_insurance_consistency" CHECK (((("insurance_active" = false) AND ("insurance_policy_id" IS NULL)) OR (("insurance_active" = true) AND ("insurance_policy_id" IS NOT NULL))))
);

ALTER TABLE ONLY "public"."trollstown_properties" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollstown_properties" OWNER TO "postgres";


COMMENT ON TABLE "public"."trollstown_properties" IS 'Tracks properties owned by users in Trolls Town';



CREATE TABLE IF NOT EXISTS "public"."trollstown_property_upgrades" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "property_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "materials_level" integer DEFAULT 0,
    "furniture_level" integer DEFAULT 0,
    "appliances_level" integer DEFAULT 0,
    "security_level" integer DEFAULT 0,
    "base_value" integer DEFAULT 1000,
    "current_value" integer DEFAULT 1000,
    "base_rent" integer DEFAULT 100,
    "current_rent" integer DEFAULT 100,
    "eviction_risk" integer DEFAULT 50,
    "last_upgraded_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "trollstown_property_upgrades_appliances_level_check" CHECK ((("appliances_level" >= 0) AND ("appliances_level" <= 5))),
    CONSTRAINT "trollstown_property_upgrades_eviction_risk_check" CHECK ((("eviction_risk" >= 0) AND ("eviction_risk" <= 100))),
    CONSTRAINT "trollstown_property_upgrades_furniture_level_check" CHECK ((("furniture_level" >= 0) AND ("furniture_level" <= 5))),
    CONSTRAINT "trollstown_property_upgrades_materials_level_check" CHECK ((("materials_level" >= 0) AND ("materials_level" <= 5))),
    CONSTRAINT "trollstown_property_upgrades_security_level_check" CHECK ((("security_level" >= 0) AND ("security_level" <= 5)))
);

ALTER TABLE ONLY "public"."trollstown_property_upgrades" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollstown_property_upgrades" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trollstown_upgrade_config" (
    "upgrade_type" "text" NOT NULL,
    "level" integer NOT NULL,
    "cost_troll_coins" integer NOT NULL,
    "value_multiplier" numeric NOT NULL,
    "rent_multiplier" numeric NOT NULL,
    "risk_reduction" integer NOT NULL,
    "description" "text" NOT NULL,
    CONSTRAINT "trollstown_upgrade_config_level_check" CHECK ((("level" >= 1) AND ("level" <= 5))),
    CONSTRAINT "trollstown_upgrade_config_upgrade_type_check" CHECK (("upgrade_type" = ANY (ARRAY['materials'::"text", 'furniture'::"text", 'appliances'::"text", 'security'::"text"])))
);

ALTER TABLE ONLY "public"."trollstown_upgrade_config" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollstown_upgrade_config" OWNER TO "postgres";


COMMENT ON TABLE "public"."trollstown_upgrade_config" IS 'Configuration for property upgrade costs and benefits';



CREATE TABLE IF NOT EXISTS "public"."trolltract_contracts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "coins_spent" bigint NOT NULL,
    "earnings_multiplier" numeric(5,2) DEFAULT 1.00,
    "goal_monthly_coins" bigint DEFAULT 50000,
    "signed_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."trolltract_contracts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."trolltract_contracts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trolltract_weekly_rewards" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "contract_id" "uuid" NOT NULL,
    "week_start" timestamp with time zone NOT NULL,
    "week_end" timestamp with time zone NOT NULL,
    "threshold_coins" bigint NOT NULL,
    "reward_coins" bigint NOT NULL,
    "member_earned_coins" bigint NOT NULL,
    "paid" boolean DEFAULT false NOT NULL,
    "paid_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."trolltract_weekly_rewards" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."trolltract_weekly_rewards" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tromody_battles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "battle_id" "text" NOT NULL,
    "left_user_id" "uuid",
    "right_user_id" "uuid",
    "winner_user_id" "uuid",
    "left_gifts_received" bigint DEFAULT 0,
    "right_gifts_received" bigint DEFAULT 0,
    "battle_duration_seconds" integer DEFAULT 180,
    "battle_started_at" timestamp with time zone DEFAULT "now"(),
    "battle_ended_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."tromody_battles" OWNER TO "postgres";


COMMENT ON TABLE "public"."tromody_battles" IS 'Records of completed Tromody comedy battles';



COMMENT ON COLUMN "public"."tromody_battles"."battle_id" IS 'Unique identifier for each battle session';



COMMENT ON COLUMN "public"."tromody_battles"."left_gifts_received" IS 'Total gifts received by left side participant';



COMMENT ON COLUMN "public"."tromody_battles"."right_gifts_received" IS 'Total gifts received by right side participant';



CREATE TABLE IF NOT EXISTS "public"."tromody_gifts" (
    "id" bigint NOT NULL,
    "session_id" "uuid" NOT NULL,
    "from_user_id" "uuid" NOT NULL,
    "side" "text" NOT NULL,
    "coin_amount" bigint DEFAULT 0 NOT NULL,
    "usd_amount" numeric(10,2) DEFAULT 0 NOT NULL,
    "coin_type" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "tromody_gifts_coin_type_check" CHECK (("coin_type" = ANY (ARRAY['paid'::"text", 'free'::"text"]))),
    CONSTRAINT "tromody_gifts_side_check" CHECK (("side" = ANY (ARRAY['left'::"text", 'right'::"text"])))
);

ALTER TABLE ONLY "public"."tromody_gifts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."tromody_gifts" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."tromody_gifts_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."tromody_gifts_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."tromody_gifts_id_seq" OWNED BY "public"."tromody_gifts"."id";



CREATE TABLE IF NOT EXISTS "public"."tromody_matches" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "player1_id" "uuid",
    "player2_id" "uuid",
    "status" "text" DEFAULT 'active'::"text",
    "winner_id" "uuid",
    "room_name" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "tromody_matches_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'completed'::"text", 'rematch_pending'::"text"])))
);

ALTER TABLE ONLY "public"."tromody_matches" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."tromody_matches" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tromody_queue" (
    "user_id" "uuid" NOT NULL,
    "status" "text" DEFAULT 'waiting'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."tromody_queue" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."tromody_queue" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tromody_sessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_by" "uuid",
    "left_user_id" "uuid",
    "right_user_id" "uuid",
    "status" "text" DEFAULT 'waiting'::"text" NOT NULL,
    "started_at" timestamp with time zone,
    "ended_at" timestamp with time zone,
    "left_gifts_paid" bigint DEFAULT 0 NOT NULL,
    "left_gifts_free" bigint DEFAULT 0 NOT NULL,
    "right_gifts_paid" bigint DEFAULT 0 NOT NULL,
    "right_gifts_free" bigint DEFAULT 0 NOT NULL,
    "winner_side" "text",
    "winner_user_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "tromody_sessions_winner_side_check" CHECK (("winner_side" = ANY (ARRAY['left'::"text", 'right'::"text", 'tie'::"text"])))
);

ALTER TABLE ONLY "public"."tromody_sessions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."tromody_sessions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trophies" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "icon" "text",
    "trophy_type" "text",
    "earned_date" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."trophies" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."trophies" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."typing_statuses" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "stream_id" "uuid",
    "is_typing" boolean DEFAULT true,
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."typing_statuses" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."typing_statuses" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_active_entrance_effect" (
    "user_id" "uuid" NOT NULL,
    "effect_id" "text" NOT NULL,
    "activated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."user_active_entrance_effect" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_active_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "item_id" "uuid" NOT NULL,
    "item_type" "text" NOT NULL,
    "activated_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean DEFAULT true NOT NULL,
    "expires_at" timestamp with time zone
);

ALTER TABLE ONLY "public"."user_active_items" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_active_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_badges_earned" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "badge_id" "uuid" NOT NULL,
    "earned_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."user_badges_earned" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_badges_earned" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_balances" (
    "user_id" "uuid" NOT NULL,
    "troll_coins" bigint DEFAULT 0 NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."user_balances" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_balances" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_bans" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "banned_by" "uuid" NOT NULL,
    "reason" "text" NOT NULL,
    "ban_type" "text" NOT NULL,
    "expires_at" timestamp with time zone,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "user_bans_ban_type_check" CHECK (("ban_type" = ANY (ARRAY['temporary'::"text", 'permanent'::"text"])))
);

ALTER TABLE ONLY "public"."user_bans" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_bans" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_boosts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "boost_type" "text" NOT NULL,
    "boost_value" integer DEFAULT 10,
    "starts_at" timestamp with time zone DEFAULT "now"(),
    "ends_at" timestamp with time zone NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."user_boosts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_boosts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_broadcast_theme_purchases" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "theme_id" "uuid" NOT NULL,
    "purchased_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."user_broadcast_theme_purchases" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_broadcast_theme_state" (
    "user_id" "uuid" NOT NULL,
    "active_theme_id" "uuid",
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."user_broadcast_theme_state" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_call_sounds" (
    "user_id" "uuid" NOT NULL,
    "sound_id" "uuid" NOT NULL,
    "is_active" boolean DEFAULT false NOT NULL,
    "purchased_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."user_call_sounds" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_devices" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "platform" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."user_devices" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_devices" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_district_progress" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "district_id" "uuid" NOT NULL,
    "onboarding_completed" boolean DEFAULT false,
    "features_explored" "text"[],
    "last_visited_at" timestamp with time zone DEFAULT "now"(),
    "visit_count" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_district_progress" OWNER TO "postgres";


COMMENT ON TABLE "public"."user_district_progress" IS 'User progress and onboarding status for each district';



CREATE TABLE IF NOT EXISTS "public"."user_entrance_effects" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "effect_id" "text" NOT NULL,
    "purchased_at" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean DEFAULT false,
    "activation_count" integer DEFAULT 0,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."user_entrance_effects" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_entrances" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "entrance_id" "text" NOT NULL,
    "acquired_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."user_entrances" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_entrances" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_follows" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "follower_id" "uuid" NOT NULL,
    "following_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."user_follows" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_follows" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_insurance" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "plan_id" "uuid" NOT NULL,
    "start_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "end_date" timestamp with time zone,
    "active" boolean DEFAULT true NOT NULL
);

ALTER TABLE ONLY "public"."user_insurance" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_insurance" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_insurances" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "insurance_id" "text" NOT NULL,
    "purchased_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone NOT NULL,
    "is_active" boolean DEFAULT true,
    "protection_type" "text" NOT NULL,
    "times_triggered" integer DEFAULT 0,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_insurances" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_inventory" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
    "item_id" "uuid" NOT NULL,
    "quantity" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "acquired_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "user_inventory_quantity_check" CHECK (("quantity" >= 0))
);

ALTER TABLE ONLY "public"."user_inventory" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_inventory" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_ip_tracking" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "ip_address" "inet" NOT NULL,
    "user_agent" "text",
    "first_seen_at" timestamp with time zone DEFAULT "now"(),
    "last_seen_at" timestamp with time zone DEFAULT "now"(),
    "login_count" integer DEFAULT 1,
    "is_flagged" boolean DEFAULT false,
    "action" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."user_ip_tracking" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_ip_tracking" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_levels" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "xp" bigint DEFAULT 0 NOT NULL,
    "level" integer DEFAULT 1 NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."user_levels" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_levels" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_notifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "body" "text" NOT NULL,
    "type" "text" DEFAULT 'system'::"text" NOT NULL,
    "is_read" boolean DEFAULT false NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_notifications" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_payment_methods" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "provider" "text" NOT NULL,
    "token_id" "text",
    "display_name" "text",
    "brand" "text",
    "last4" "text",
    "exp_month" integer,
    "exp_year" integer,
    "square_customer_id" "text",
    "square_card_id" "text",
    "is_default" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."user_payment_methods" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_payment_methods" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_payout_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "payout_method" "text",
    "payout_details" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "user_payout_settings_payout_method_check" CHECK (("payout_method" = ANY (ARRAY['PayPal'::"text", 'CashApp'::"text", 'Venmo'::"text"])))
);

ALTER TABLE ONLY "public"."user_payout_settings" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_payout_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_perks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "perk_id" "text" NOT NULL,
    "purchased_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone NOT NULL,
    "is_active" boolean DEFAULT true,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_perks" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_reputation" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "current_score" integer DEFAULT 100,
    "lifetime_score" integer DEFAULT 100,
    "violations_count" integer DEFAULT 0,
    "court_appearances" integer DEFAULT 0,
    "missed_court_sessions" integer DEFAULT 0,
    "successful_appeals" integer DEFAULT 0,
    "last_violation_date" timestamp with time zone,
    "reputation_tier" character varying(20) DEFAULT 'good'::character varying,
    "is_escalation_priority" boolean DEFAULT false,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_reputation" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_risk_profile" (
    "user_id" "uuid" NOT NULL,
    "risk_score" integer DEFAULT 0,
    "is_frozen" boolean DEFAULT false,
    "freeze_reason" "text",
    "last_event_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_risk_profile" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_roles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."user_roles" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_roles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_streamer_entitlements" (
    "user_id" "uuid" NOT NULL,
    "streamer_level" integer DEFAULT 0 NOT NULL,
    "followers_count" integer DEFAULT 0 NOT NULL,
    "total_hours_streamed" integer DEFAULT 0 NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."user_streamer_entitlements" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_tax_info" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "legal_name" "text",
    "business_name" "text",
    "country" "text",
    "state" "text",
    "address_line1" "text",
    "address_line2" "text",
    "city" "text",
    "zip" "text",
    "tax_id_last4" "text",
    "tax_type" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "address" "text",
    "ein" "text",
    "ssn_last4" "text",
    "tax_classification" "text",
    "email" "text",
    "phone" "text",
    "tax_entity_type" "text" DEFAULT 'individual'::"text",
    "postal_code" "text",
    "tax_verification_status" "text" DEFAULT 'not_submitted'::"text",
    "submitted_at" timestamp with time zone,
    "reviewed_at" timestamp with time zone,
    "full_name" "text",
    "ssn" "text",
    "w9_completed" boolean DEFAULT false,
    "w9_completed_at" timestamp with time zone,
    "w9_document_url" "text",
    "w9_status" "text" DEFAULT 'not_started'::"text",
    "zip_code" "text",
    "status" "text" DEFAULT 'not_submitted'::"text",
    "legal_full_name" "text",
    "date_of_birth" "date",
    "state_region" "text",
    "w9_verified_at" timestamp with time zone,
    CONSTRAINT "user_tax_info_status_check" CHECK (("status" = ANY (ARRAY['not_submitted'::"text", 'pending'::"text", 'approved'::"text", 'rejected'::"text"])))
);


ALTER TABLE "public"."user_tax_info" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_wallets" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "wallet" "text",
    "free_coins" bigint DEFAULT 0,
    "paid_coins" bigint DEFAULT 0,
    "total_earned" bigint DEFAULT 0,
    "total_gifted" bigint DEFAULT 0,
    "total_spent" bigint DEFAULT 0,
    "welcome_bonus_received" boolean DEFAULT false,
    "call_minutes" integer DEFAULT 0,
    "video_minutes" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "troll_coins" bigint DEFAULT 0,
    "trollmods" bigint DEFAULT 0
);

ALTER TABLE ONLY "public"."user_wallets" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_wallets" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."users" (
    "id" "uuid" NOT NULL,
    "email" character varying(255) NOT NULL,
    "role" character varying(50) DEFAULT 'user'::character varying,
    "full_name" character varying(255) NOT NULL,
    "display_name" character varying(255) NOT NULL,
    "bio" "text",
    "profile_pic" "text",
    "troll_role" character varying(50) DEFAULT 'troller'::character varying,
    "is_broadcaster" boolean DEFAULT false,
    "level" integer DEFAULT 1,
    "xp" integer DEFAULT 0,
    "page_price" numeric(10,2) DEFAULT 0,
    "message_price" numeric(10,2) DEFAULT 0,
    "call_price" numeric(10,2) DEFAULT 0,
    "video_call_price" numeric(10,2) DEFAULT 0,
    "insurance_plan" character varying(50) DEFAULT 'none'::character varying,
    "referral_code" character varying(255),
    "paypal_email" character varying(255),
    "bank_account" character varying(255),
    "tax_id_type" character varying(50),
    "tax_id_number" character varying(255),
    "tax_status" character varying(50) DEFAULT 'pending'::character varying,
    "language" character varying(10) DEFAULT 'en'::character varying,
    "show_online_status" boolean DEFAULT true,
    "allow_messages" boolean DEFAULT true,
    "entrance_id" "uuid",
    "birthday" "date",
    "is_clocked_in" boolean DEFAULT false,
    "clocked_in_at" timestamp with time zone,
    "current_stream_id" "uuid",
    "agreed_to_terms" boolean DEFAULT false,
    "terms_agreed_at" timestamp with time zone,
    "is_banned" boolean DEFAULT false,
    "banned_ip" character varying(255),
    "ban_reason" "text",
    "id_verified" boolean DEFAULT false,
    "onboarding_complete" boolean DEFAULT false,
    "agreed_to_policies" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    "updated_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);

ALTER TABLE ONLY "public"."users" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."users" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_broadcast_themes_for_user" AS
 SELECT "t"."id",
    "t"."slug",
    "t"."name",
    "t"."description",
    "t"."preview_url",
    "t"."background_type",
    "t"."background_asset_url",
    "t"."background_css",
    "t"."price_coins",
    "t"."is_active",
    "t"."rarity",
    "t"."sort_order",
    "t"."created_at",
    ("p"."theme_id" IS NOT NULL) AS "owned",
    ("s"."active_theme_id" = "t"."id") AS "is_active_for_user"
   FROM (("public"."broadcast_background_themes" "t"
     LEFT JOIN "public"."user_broadcast_theme_purchases" "p" ON ((("p"."theme_id" = "t"."id") AND ("p"."user_id" = "auth"."uid"()))))
     LEFT JOIN "public"."user_broadcast_theme_state" "s" ON (("s"."user_id" = "auth"."uid"())))
  WHERE ("t"."is_active" = true);


ALTER VIEW "public"."v_broadcast_themes_for_user" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_kick_ban_revenue" WITH ("security_invoker"='true') AS
 SELECT COALESCE("sum"("platform_profit"), (0)::numeric) AS "kick_ban_profit"
   FROM "public"."coin_transactions"
  WHERE ("type" = ANY (ARRAY['kick_fee'::"text", 'ban_fee'::"text"]));


ALTER VIEW "public"."v_kick_ban_revenue" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_payout" WITH ("security_invoker"='true') AS
 SELECT "id",
    "p_payout_id",
    "user_id",
    "coins_used",
    "amount",
    "status",
    "created_at"
   FROM "public"."payouts" "p";


ALTER VIEW "public"."v_payout" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_total_liability" WITH ("security_invoker"='true') AS
 SELECT COALESCE("sum"("liability"), (0)::numeric) AS "total_liability_coins"
   FROM "public"."coin_transactions";


ALTER VIEW "public"."v_total_liability" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."vendor_invoices" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "vendor" "text" NOT NULL,
    "invoice_date" "date" NOT NULL,
    "due_date" "date",
    "amount_usd" numeric(12,2) DEFAULT 0 NOT NULL,
    "status" "text" DEFAULT 'unpaid'::"text" NOT NULL,
    "notes" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "vendor_invoices_amount_usd_check" CHECK (("amount_usd" >= (0)::numeric)),
    CONSTRAINT "vendor_invoices_status_check" CHECK (("status" = ANY (ARRAY['unpaid'::"text", 'paid'::"text", 'void'::"text"]))),
    CONSTRAINT "vendor_invoices_vendor_check" CHECK (("vendor" = ANY (ARRAY['fastly'::"text", 'vercel'::"text", 'livekit'::"text", 'supabase'::"text", 'ionos'::"text"])))
);

ALTER TABLE ONLY "public"."vendor_invoices" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."vendor_invoices" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."verification_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "id_photo_url" "text" NOT NULL,
    "selfie_url" "text",
    "ai_match_score" numeric(5,2),
    "ai_behavior_score" numeric(5,2),
    "status" "text" DEFAULT 'pending'::"text",
    "influencer_tier" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "reviewed_at" timestamp with time zone,
    "admin_reviewer" "uuid",
    "admin_note" "text",
    "id_photo_hash" "text",
    "source" "text" DEFAULT 'ai_verification'::"text",
    "duplicate_of_id" "uuid",
    CONSTRAINT "verification_requests_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'denied'::"text", 'in_review'::"text"])))
);

ALTER TABLE ONLY "public"."verification_requests" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."verification_requests" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."verification_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "payment_method" "text" NOT NULL,
    "amount" numeric(10,2) NOT NULL,
    "payment_reference" "text",
    "status" "text" DEFAULT 'completed'::"text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."verification_transactions" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."verification_transactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."videos" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "creatorid" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "thumbnailurl" "text",
    "videourl" "text" NOT NULL,
    "categorytype" "text" NOT NULL,
    "published" boolean DEFAULT false,
    "createdat" timestamp without time zone DEFAULT "now"(),
    "totalcoinsearned" integer DEFAULT 0,
    "totalgiftsreceived" integer DEFAULT 0,
    "isfeatured" boolean DEFAULT false,
    "featuredat" timestamp without time zone,
    "istrendingeligible" boolean DEFAULT true,
    CONSTRAINT "videos_categorytype_check" CHECK (("categorytype" = ANY (ARRAY['short'::"text", 'movie'::"text"])))
);

ALTER TABLE ONLY "public"."videos" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."videos" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."visa_redemptions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "coins_reserved" integer NOT NULL,
    "usd_amount" numeric NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "giftcard_code" "text",
    "note" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "approved_at" timestamp with time zone,
    "fulfilled_at" timestamp with time zone,
    "rejected_at" timestamp with time zone,
    "fulfilled_by" "uuid",
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."visa_redemptions" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."visa_redemptions_user_view" AS
 SELECT "id",
    "user_id",
    "coins_reserved",
    "usd_amount",
    "status",
        CASE
            WHEN ("status" = 'fulfilled'::"text") THEN "giftcard_code"
            ELSE NULL::"text"
        END AS "giftcard_code",
    "created_at",
    "approved_at",
    "fulfilled_at",
    "rejected_at"
   FROM "public"."visa_redemptions" "r";


ALTER VIEW "public"."visa_redemptions_user_view" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wall_posts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "author_id" "uuid",
    "author_name" "text",
    "content" "text" NOT NULL,
    "post_type" "text" DEFAULT 'status'::"text",
    "likes_count" integer DEFAULT 0,
    "comments_count" integer DEFAULT 0,
    "image_url" "text",
    "replies" "jsonb" DEFAULT '[]'::"jsonb",
    "gifts_received" integer DEFAULT 0,
    "coins_earned" bigint DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "wall_posts_post_type_check" CHECK (("post_type" = ANY (ARRAY['status'::"text", 'photo'::"text", 'link'::"text", 'stream_announcement'::"text"])))
);

ALTER TABLE ONLY "public"."wall_posts" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."wall_posts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."war_results" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "war_id" "uuid" NOT NULL,
    "family_id" "uuid" NOT NULL,
    "points" integer DEFAULT 0 NOT NULL,
    "rank" integer,
    "rewards" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."war_results" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."war_results" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wars" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "type" "text" NOT NULL,
    "start_at" timestamp with time zone NOT NULL,
    "end_at" timestamp with time zone NOT NULL,
    "rules" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "wars_type_check" CHECK (("type" = ANY (ARRAY['emoji_war_royale'::"text", 'gifty_clash_hour'::"text", 'troll_invasion_raid'::"text", 'troll_anthem_night'::"text"])))
);

ALTER TABLE ONLY "public"."wars" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."wars" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."web_push_subscriptions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "endpoint" "text" NOT NULL,
    "keys" "jsonb" NOT NULL,
    "expiration_time" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."web_push_subscriptions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."weekly_officer_reports" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "lead_officer_id" "uuid" NOT NULL,
    "week_start" "date" NOT NULL,
    "week_end" "date" NOT NULL,
    "title" "text" NOT NULL,
    "body" "text" NOT NULL,
    "incidents" "jsonb" DEFAULT '[]'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."weekly_officer_reports" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."weekly_officer_reports" OWNER TO "postgres";


COMMENT ON TABLE "public"."weekly_officer_reports" IS 'Weekly reports submitted by lead officers to owners/admins';



CREATE TABLE IF NOT EXISTS "public"."weekly_reports" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "reporter_id" "uuid" NOT NULL,
    "reporter_name" "text",
    "status" "text",
    "summary" "text",
    "highlights" "text",
    "issues" "text",
    "recommendations" "text",
    "officer_performance_notes" "text",
    "week_start" "date",
    "week_end" "date",
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."weekly_reports" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."weekly_reports" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wheel_spins" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "cost_coins" integer NOT NULL,
    "outcome" "text" NOT NULL,
    "prize_coins" integer DEFAULT 0,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."wheel_spins" OWNER TO "postgres";


ALTER TABLE ONLY "public"."tromody_gifts" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."tromody_gifts_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."abuse_reports"
    ADD CONSTRAINT "abuse_reports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."action_logs"
    ADD CONSTRAINT "action_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."active_sessions"
    ADD CONSTRAINT "active_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."active_sessions"
    ADD CONSTRAINT "active_sessions_session_id_key" UNIQUE ("session_id");



ALTER TABLE ONLY "public"."activity_log"
    ADD CONSTRAINT "activity_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."activity_logs"
    ADD CONSTRAINT "activity_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."admin_adjustments"
    ADD CONSTRAINT "admin_adjustments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."admin_broadcasts"
    ADD CONSTRAINT "admin_broadcasts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."admin_coin_pool"
    ADD CONSTRAINT "admin_coin_pool_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."admin_coin_revenue"
    ADD CONSTRAINT "admin_coin_revenue_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."admin_coin_revenue"
    ADD CONSTRAINT "admin_coin_revenue_transaction_id_key" UNIQUE ("transaction_id");



ALTER TABLE ONLY "public"."admin_flags"
    ADD CONSTRAINT "admin_flags_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."admin_gift_totals"
    ADD CONSTRAINT "admin_gift_totals_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."admin_gift_totals"
    ADD CONSTRAINT "admin_gift_totals_user_id_admin_id_key" UNIQUE ("user_id", "admin_id");



ALTER TABLE ONLY "public"."admin_pool"
    ADD CONSTRAINT "admin_pool_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."admin_tax_reviews"
    ADD CONSTRAINT "admin_tax_reviews_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."admin_top_buyers"
    ADD CONSTRAINT "admin_top_buyers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_action_logs"
    ADD CONSTRAINT "ai_action_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."app_settings"
    ADD CONSTRAINT "app_settings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."app_settings"
    ADD CONSTRAINT "app_settings_setting_key_key" UNIQUE ("setting_key");



ALTER TABLE ONLY "public"."app_updates"
    ADD CONSTRAINT "app_updates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."applications"
    ADD CONSTRAINT "applications_application_id_unique" UNIQUE ("application_id");



ALTER TABLE ONLY "public"."applications"
    ADD CONSTRAINT "applications_pkey" PRIMARY KEY ("application_id");



ALTER TABLE ONLY "public"."badge_definitions"
    ADD CONSTRAINT "badge_definitions_badge_type_level_key" UNIQUE ("badge_type", "level");



ALTER TABLE ONLY "public"."badge_definitions"
    ADD CONSTRAINT "badge_definitions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."balance_ledger"
    ADD CONSTRAINT "balance_ledger_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."battle_gifts"
    ADD CONSTRAINT "battle_gifts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."battle_history"
    ADD CONSTRAINT "battle_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."battle_rewards"
    ADD CONSTRAINT "battle_rewards_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."battle_sessions"
    ADD CONSTRAINT "battle_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."blocked_users"
    ADD CONSTRAINT "blocked_users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."broadcast_background_themes"
    ADD CONSTRAINT "broadcast_background_themes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."broadcast_background_themes"
    ADD CONSTRAINT "broadcast_background_themes_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."broadcast_cycle_stats"
    ADD CONSTRAINT "broadcast_cycle_stats_pkey" PRIMARY KEY ("cycle_start", "stream_id");



ALTER TABLE ONLY "public"."broadcast_seats"
    ADD CONSTRAINT "broadcast_seats_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."broadcast_seats"
    ADD CONSTRAINT "broadcast_seats_stream_id_seat_index_key" UNIQUE ("stream_id", "seat_index");



ALTER TABLE ONLY "public"."broadcast_theme_events"
    ADD CONSTRAINT "broadcast_theme_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."broadcast_tokens"
    ADD CONSTRAINT "broadcast_tokens_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."broadcaster_applications"
    ADD CONSTRAINT "broadcaster_applications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."broadcaster_earnings"
    ADD CONSTRAINT "broadcaster_earnings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."broadcaster_metrics"
    ADD CONSTRAINT "broadcaster_metrics_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."broadcaster_metrics"
    ADD CONSTRAINT "broadcaster_metrics_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."call_history"
    ADD CONSTRAINT "call_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."call_minutes"
    ADD CONSTRAINT "call_minutes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."call_minutes"
    ADD CONSTRAINT "call_minutes_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."call_sessions"
    ADD CONSTRAINT "call_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."call_sound_catalog"
    ADD CONSTRAINT "call_sound_catalog_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."call_sound_catalog"
    ADD CONSTRAINT "call_sound_catalog_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."call_transactions"
    ADD CONSTRAINT "call_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."case_audit_logs"
    ADD CONSTRAINT "case_audit_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."case_evidence"
    ADD CONSTRAINT "case_evidence_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."case_participants"
    ADD CONSTRAINT "case_participants_case_id_user_id_key" UNIQUE ("case_id", "user_id");



ALTER TABLE ONLY "public"."case_participants"
    ADD CONSTRAINT "case_participants_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."case_templates"
    ADD CONSTRAINT "case_templates_case_type_key" UNIQUE ("case_type");



ALTER TABLE ONLY "public"."case_templates"
    ADD CONSTRAINT "case_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cashout_requests"
    ADD CONSTRAINT "cashout_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cashout_tiers"
    ADD CONSTRAINT "cashout_tiers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."city_districts"
    ADD CONSTRAINT "city_districts_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."city_districts"
    ADD CONSTRAINT "city_districts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."city_events"
    ADD CONSTRAINT "city_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."clan_rewards"
    ADD CONSTRAINT "clan_rewards_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."clan_vault"
    ADD CONSTRAINT "clan_vault_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."coin_audit_log"
    ADD CONSTRAINT "coin_audit_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."coin_ledger"
    ADD CONSTRAINT "coin_ledger_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."coin_packages"
    ADD CONSTRAINT "coin_packages_paypal_sku_key" UNIQUE ("paypal_sku");



ALTER TABLE ONLY "public"."coin_packages"
    ADD CONSTRAINT "coin_packages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."coin_purchases"
    ADD CONSTRAINT "coin_purchases_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."coin_reward_pool"
    ADD CONSTRAINT "coin_reward_pool_pkey" PRIMARY KEY ("pool_key");



ALTER TABLE ONLY "public"."coin_transactions"
    ADD CONSTRAINT "coin_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."coinback_log"
    ADD CONSTRAINT "coinback_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."config"
    ADD CONSTRAINT "config_key_key" UNIQUE ("key");



ALTER TABLE ONLY "public"."config"
    ADD CONSTRAINT "config_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."content"
    ADD CONSTRAINT "content_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."conversation_members"
    ADD CONSTRAINT "conversation_members_pkey" PRIMARY KEY ("conversation_id", "user_id");



ALTER TABLE ONLY "public"."conversation_messages"
    ADD CONSTRAINT "conversation_messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."conversations"
    ADD CONSTRAINT "conversations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."court_ai_messages"
    ADD CONSTRAINT "court_ai_messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."court_box_members"
    ADD CONSTRAINT "court_box_members_pkey" PRIMARY KEY ("session_id", "user_id");



ALTER TABLE ONLY "public"."court_cases"
    ADD CONSTRAINT "court_cases_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."court_docket"
    ADD CONSTRAINT "court_docket_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."court_rulings_archive"
    ADD CONSTRAINT "court_rulings_archive_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."court_schedules"
    ADD CONSTRAINT "court_schedules_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."court_sessions"
    ADD CONSTRAINT "court_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."court_sessions"
    ADD CONSTRAINT "court_sessions_room_name_key" UNIQUE ("room_name");



ALTER TABLE ONLY "public"."court_sessions"
    ADD CONSTRAINT "court_sessions_session_id_key" UNIQUE ("session_id");



ALTER TABLE ONLY "public"."court_summons"
    ADD CONSTRAINT "court_summons_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."creator_applications"
    ADD CONSTRAINT "creator_applications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."creator_migration_claims"
    ADD CONSTRAINT "creator_migration_claims_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."creators_over_600"
    ADD CONSTRAINT "creators_over_600_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."critical_alerts"
    ADD CONSTRAINT "critical_alerts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."daily_giveaways"
    ADD CONSTRAINT "daily_giveaways_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."daily_giveaways"
    ADD CONSTRAINT "daily_giveaways_user_id_giveaway_date_key" UNIQUE ("user_id", "giveaway_date");



ALTER TABLE ONLY "public"."daily_logins"
    ADD CONSTRAINT "daily_logins_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."daily_rewards"
    ADD CONSTRAINT "daily_rewards_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."declined_transactions"
    ADD CONSTRAINT "declined_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."deed_transfers"
    ADD CONSTRAINT "deed_transfers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."deeds"
    ADD CONSTRAINT "deeds_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."district_announcements"
    ADD CONSTRAINT "district_announcements_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."district_features"
    ADD CONSTRAINT "district_features_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."earnings"
    ADD CONSTRAINT "earnings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."economy_abuse_flags"
    ADD CONSTRAINT "economy_abuse_flags_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."empire_applications"
    ADD CONSTRAINT "empire_applications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."empire_partner_rewards"
    ADD CONSTRAINT "empire_partner_rewards_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."empire_partner_rewards"
    ADD CONSTRAINT "empire_partner_rewards_referrer_id_referred_user_id_key" UNIQUE ("referrer_id", "referred_user_id");



ALTER TABLE ONLY "public"."empire_partners"
    ADD CONSTRAINT "empire_partners_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."empire_partners"
    ADD CONSTRAINT "empire_partners_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."empire_referrals"
    ADD CONSTRAINT "empire_referrals_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."empire_rewards"
    ADD CONSTRAINT "empire_rewards_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."entrance_effect_catalog"
    ADD CONSTRAINT "entrance_effect_catalog_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."entrance_effects"
    ADD CONSTRAINT "entrance_effects_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."error_logs"
    ADD CONSTRAINT "error_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."escalation_matrix"
    ADD CONSTRAINT "escalation_matrix_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."escalation_matrix"
    ADD CONSTRAINT "escalation_matrix_violation_type_severity_level_violation_c_key" UNIQUE ("violation_type", "severity_level", "violation_count_threshold");



ALTER TABLE ONLY "public"."escalation_reports"
    ADD CONSTRAINT "escalation_reports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."event_participants"
    ADD CONSTRAINT "event_participants_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."executive_intake"
    ADD CONSTRAINT "executive_intake_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."executive_reports"
    ADD CONSTRAINT "executive_reports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."families"
    ADD CONSTRAINT "families_family_code_key" UNIQUE ("family_code");



ALTER TABLE ONLY "public"."families"
    ADD CONSTRAINT "families_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."family_activity_log"
    ADD CONSTRAINT "family_activity_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."family_badges_earned"
    ADD CONSTRAINT "family_badges_earned_family_id_badge_id_key" UNIQUE ("family_id", "badge_id");



ALTER TABLE ONLY "public"."family_badges_earned"
    ADD CONSTRAINT "family_badges_earned_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."family_boosts"
    ADD CONSTRAINT "family_boosts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."family_invites"
    ADD CONSTRAINT "family_invites_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."family_lounge_messages"
    ADD CONSTRAINT "family_lounge_messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."family_members"
    ADD CONSTRAINT "family_members_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."family_seasons"
    ADD CONSTRAINT "family_seasons_family_id_season_number_key" UNIQUE ("family_id", "season_number");



ALTER TABLE ONLY "public"."family_seasons"
    ADD CONSTRAINT "family_seasons_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."family_shop_items"
    ADD CONSTRAINT "family_shop_items_item_code_key" UNIQUE ("item_code");



ALTER TABLE ONLY "public"."family_shop_items"
    ADD CONSTRAINT "family_shop_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."family_shop_purchases"
    ADD CONSTRAINT "family_shop_purchases_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."family_stats"
    ADD CONSTRAINT "family_stats_family_id_key" UNIQUE ("family_id");



ALTER TABLE ONLY "public"."family_stats"
    ADD CONSTRAINT "family_stats_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."family_tasks_new"
    ADD CONSTRAINT "family_tasks_new_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."family_tasks"
    ADD CONSTRAINT "family_tasks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."family_war_stats"
    ADD CONSTRAINT "family_war_stats_pkey" PRIMARY KEY ("family_id");



ALTER TABLE ONLY "public"."family_wars"
    ADD CONSTRAINT "family_wars_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."follows"
    ADD CONSTRAINT "follows_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."follows"
    ADD CONSTRAINT "follows_unique_pair" UNIQUE ("follower_id", "following_id");



ALTER TABLE ONLY "public"."ghost_presence_logs"
    ADD CONSTRAINT "ghost_presence_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gift_bonus_tracker"
    ADD CONSTRAINT "gift_bonus_tracker_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gift_card_redemptions"
    ADD CONSTRAINT "gift_card_redemptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gift_cards"
    ADD CONSTRAINT "gift_cards_code_key" UNIQUE ("code");



ALTER TABLE ONLY "public"."gift_cards"
    ADD CONSTRAINT "gift_cards_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gift_catalog"
    ADD CONSTRAINT "gift_catalog_pkey" PRIMARY KEY ("gift_slug");



ALTER TABLE ONLY "public"."gift_items"
    ADD CONSTRAINT "gift_items_gift_slug_key" UNIQUE ("gift_slug");



ALTER TABLE ONLY "public"."gift_items"
    ADD CONSTRAINT "gift_items_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."gift_items"
    ADD CONSTRAINT "gift_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gift_leaderboard_entries"
    ADD CONSTRAINT "gift_leaderboard_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gift_leaderboards"
    ADD CONSTRAINT "gift_leaderboards_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gift_transactions"
    ADD CONSTRAINT "gift_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gift_xp_stats"
    ADD CONSTRAINT "gift_xp_stats_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."giftcard_fulfillments"
    ADD CONSTRAINT "giftcard_fulfillments_cashout_id_key" UNIQUE ("cashout_id");



ALTER TABLE ONLY "public"."giftcard_fulfillments"
    ADD CONSTRAINT "giftcard_fulfillments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gifts_owned"
    ADD CONSTRAINT "gifts_owned_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gifts_owned"
    ADD CONSTRAINT "gifts_owned_user_id_gift_slug_key" UNIQUE ("user_id", "gift_slug");



ALTER TABLE ONLY "public"."gifts"
    ADD CONSTRAINT "gifts_pkey" PRIMARY KEY ("gift_id");



ALTER TABLE ONLY "public"."group_chats"
    ADD CONSTRAINT "group_chats_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."hire_fire_actions"
    ADD CONSTRAINT "hire_fire_actions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."hire_limits"
    ADD CONSTRAINT "hire_limits_pkey" PRIMARY KEY ("role");



ALTER TABLE ONLY "public"."home_feature_cycles"
    ADD CONSTRAINT "home_feature_cycles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."home_feature_spend"
    ADD CONSTRAINT "home_feature_spend_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."honorary_family_members"
    ADD CONSTRAINT "honorary_family_members_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."honorary_family_members"
    ADD CONSTRAINT "honorary_family_members_user_id_admin_id_key" UNIQUE ("user_id", "admin_id");



ALTER TABLE ONLY "public"."hr_employees"
    ADD CONSTRAINT "hr_employees_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."hr_events"
    ADD CONSTRAINT "hr_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."hr_notes"
    ADD CONSTRAINT "hr_notes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."identity_reward_logs"
    ADD CONSTRAINT "identity_reward_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."incidents"
    ADD CONSTRAINT "incidents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."insurance_logs"
    ADD CONSTRAINT "insurance_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."insurance_options"
    ADD CONSTRAINT "insurance_options_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."insurance_packages"
    ADD CONSTRAINT "insurance_packages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."insurance"
    ADD CONSTRAINT "insurance_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."insurance_plans"
    ADD CONSTRAINT "insurance_plans_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."interview_sessions"
    ADD CONSTRAINT "interview_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."inventory_items"
    ADD CONSTRAINT "inventory_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ip_bans"
    ADD CONSTRAINT "ip_bans_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."job_applications"
    ADD CONSTRAINT "job_applications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."kick_logs"
    ADD CONSTRAINT "kick_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."lucky_coin_events"
    ADD CONSTRAINT "lucky_trollmond_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mai_appeals"
    ADD CONSTRAINT "mai_appeals_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mai_incidents"
    ADD CONSTRAINT "mai_incidents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mai_overrides"
    ADD CONSTRAINT "mai_overrides_pkey" PRIMARY KEY ("key");



ALTER TABLE ONLY "public"."mai_timeline_events"
    ADD CONSTRAINT "mai_timeline_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mai_user_memory"
    ADD CONSTRAINT "mai_user_memory_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."marketplace_items"
    ADD CONSTRAINT "marketplace_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."message_receipts"
    ADD CONSTRAINT "message_receipts_message_id_user_id_key" UNIQUE ("message_id", "user_id");



ALTER TABLE ONLY "public"."message_receipts"
    ADD CONSTRAINT "message_receipts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."message_requests"
    ADD CONSTRAINT "message_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."millionaire_hall_of_fame"
    ADD CONSTRAINT "millionaire_hall_of_fame_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."moderation_actions"
    ADD CONSTRAINT "moderation_actions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."moderation_events"
    ADD CONSTRAINT "moderation_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."moderation_fee_settings"
    ADD CONSTRAINT "moderation_fee_settings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."moderation_notes"
    ADD CONSTRAINT "moderation_notes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."moderation_reports"
    ADD CONSTRAINT "moderation_reports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."observer_ratings"
    ADD CONSTRAINT "observer_ratings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_actions"
    ADD CONSTRAINT "officer_actions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_activity"
    ADD CONSTRAINT "officer_activity_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_applications"
    ADD CONSTRAINT "officer_applications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_availability"
    ADD CONSTRAINT "officer_availability_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_badges"
    ADD CONSTRAINT "officer_badges_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."officer_chat_messages"
    ADD CONSTRAINT "officer_chat_messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_chat"
    ADD CONSTRAINT "officer_chat_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_earnings"
    ADD CONSTRAINT "officer_earnings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_hours"
    ADD CONSTRAINT "officer_hours_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_live_assignments"
    ADD CONSTRAINT "officer_live_assignments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_logs"
    ADD CONSTRAINT "officer_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_mission_logs"
    ADD CONSTRAINT "officer_mission_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_orientation_results"
    ADD CONSTRAINT "officer_orientation_results_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_orientations"
    ADD CONSTRAINT "officer_orientations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_orientations"
    ADD CONSTRAINT "officer_orientations_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."officer_payouts"
    ADD CONSTRAINT "officer_payouts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_performance"
    ADD CONSTRAINT "officer_performance_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_quiz_attempts"
    ADD CONSTRAINT "officer_quiz_attempts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_quiz_questions"
    ADD CONSTRAINT "officer_quiz_questions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_quiz_results"
    ADD CONSTRAINT "officer_quiz_results_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_shift_logs"
    ADD CONSTRAINT "officer_shift_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_shift_slots"
    ADD CONSTRAINT "officer_shift_slots_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_shifts"
    ADD CONSTRAINT "officer_shifts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_stream_logs"
    ADD CONSTRAINT "officer_stream_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_strikes"
    ADD CONSTRAINT "officer_strikes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_training_sessions"
    ADD CONSTRAINT "officer_training_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_weekly_reports"
    ADD CONSTRAINT "officer_weekly_reports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."officer_work_sessions"
    ADD CONSTRAINT "officer_work_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."onboarding_events"
    ADD CONSTRAINT "onboarding_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."onboarding_progress"
    ADD CONSTRAINT "onboarding_progress_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."onboarding_progress"
    ADD CONSTRAINT "onboarding_progress_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."owc_transactions"
    ADD CONSTRAINT "owc_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payment_fees"
    ADD CONSTRAINT "payment_fees_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payment_holds"
    ADD CONSTRAINT "payment_holds_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payment_logs"
    ADD CONSTRAINT "payment_logs_paypal_order_id_key" UNIQUE ("paypal_order_id");



ALTER TABLE ONLY "public"."payment_logs"
    ADD CONSTRAINT "payment_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payment_methods"
    ADD CONSTRAINT "payment_methods_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "payment_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payout_audit_log"
    ADD CONSTRAINT "payout_audit_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payout_requests"
    ADD CONSTRAINT "payout_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payout_reviews"
    ADD CONSTRAINT "payout_reviews_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payout_settings"
    ADD CONSTRAINT "payout_settings_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."payouts"
    ADD CONSTRAINT "payouts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."perk_catalog"
    ADD CONSTRAINT "perk_catalog_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."perks"
    ADD CONSTRAINT "perks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."platform_fees"
    ADD CONSTRAINT "platform_fees_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."platform_profit"
    ADD CONSTRAINT "platform_profit_pkey" PRIMARY KEY ("date");



ALTER TABLE ONLY "public"."platform_revenue"
    ADD CONSTRAINT "platform_revenue_pkey" PRIMARY KEY ("date");



ALTER TABLE ONLY "public"."platform_wallet"
    ADD CONSTRAINT "platform_wallet_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."post_gifts"
    ADD CONSTRAINT "post_gifts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."posts"
    ADD CONSTRAINT "posts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."promo_code_uses"
    ADD CONSTRAINT "promo_code_uses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."promo_code_uses"
    ADD CONSTRAINT "promo_code_uses_promo_code_id_user_id_key" UNIQUE ("promo_code_id", "user_id");



ALTER TABLE ONLY "public"."promo_codes"
    ADD CONSTRAINT "promo_codes_code_key" UNIQUE ("code");



ALTER TABLE ONLY "public"."promo_codes"
    ADD CONSTRAINT "promo_codes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."properties"
    ADD CONSTRAINT "properties_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."property_upgrades"
    ADD CONSTRAINT "property_upgrades_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."provider_costs"
    ADD CONSTRAINT "provider_costs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."provider_costs"
    ADD CONSTRAINT "provider_costs_provider_key" UNIQUE ("provider");



ALTER TABLE ONLY "public"."punishment_transactions"
    ADD CONSTRAINT "punishment_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."punishments"
    ADD CONSTRAINT "punishments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."referral_claims"
    ADD CONSTRAINT "referral_claims_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."referral_monthly_bonus"
    ADD CONSTRAINT "referral_monthly_bonus_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."referral_monthly_bonus"
    ADD CONSTRAINT "referral_monthly_bonus_referred_user_id_month_key" UNIQUE ("referred_user_id", "month");



ALTER TABLE ONLY "public"."referrals"
    ADD CONSTRAINT "referrals_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."referrals"
    ADD CONSTRAINT "referrals_recruiter_id_referred_user_id_key" UNIQUE ("recruiter_id", "referred_user_id");



ALTER TABLE ONLY "public"."report_cases"
    ADD CONSTRAINT "report_cases_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."reputation_events"
    ADD CONSTRAINT "reputation_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."revenue_ledger"
    ADD CONSTRAINT "revenue_ledger_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."revenue_settings"
    ADD CONSTRAINT "revenue_settings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."risk_events"
    ADD CONSTRAINT "risk_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."role_change_log"
    ADD CONSTRAINT "role_change_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."role_privileges"
    ADD CONSTRAINT "role_privileges_pkey" PRIMARY KEY ("role");



ALTER TABLE ONLY "public"."roles"
    ADD CONSTRAINT "roles_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."roles"
    ADD CONSTRAINT "roles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."rooms"
    ADD CONSTRAINT "rooms_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."rooms"
    ADD CONSTRAINT "rooms_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."royal_family_history"
    ADD CONSTRAINT "royal_family_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."royal_family_perks"
    ADD CONSTRAINT "royal_family_perks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."royal_family_titles"
    ADD CONSTRAINT "royal_family_titles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."scheduled_announcements"
    ADD CONSTRAINT "scheduled_announcements_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."secretary_assignments"
    ADD CONSTRAINT "secretary_assignments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."secretary_assignments"
    ADD CONSTRAINT "secretary_assignments_secretary_id_key" UNIQUE ("secretary_id");



ALTER TABLE ONLY "public"."security_events"
    ADD CONSTRAINT "security_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."seller_reliability"
    ADD CONSTRAINT "seller_reliability_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."shadow_bans"
    ADD CONSTRAINT "shadow_bans_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."shifts"
    ADD CONSTRAINT "shifts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."shop_items"
    ADD CONSTRAINT "shop_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."shop_partners"
    ADD CONSTRAINT "shop_partners_partner_code_key" UNIQUE ("partner_code");



ALTER TABLE ONLY "public"."shop_partners"
    ADD CONSTRAINT "shop_partners_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."shop_transactions"
    ADD CONSTRAINT "shop_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."shops"
    ADD CONSTRAINT "shops_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."special_gift_earnings"
    ADD CONSTRAINT "special_gift_earnings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."square_events"
    ADD CONSTRAINT "square_events_event_id_key" UNIQUE ("event_id");



ALTER TABLE ONLY "public"."square_events"
    ADD CONSTRAINT "square_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."staff_applications"
    ADD CONSTRAINT "staff_applications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."staff_profiles"
    ADD CONSTRAINT "staff_profiles_pkey" PRIMARY KEY ("staff_id");



ALTER TABLE ONLY "public"."store_items"
    ADD CONSTRAINT "store_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stores"
    ADD CONSTRAINT "stores_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_discovery_prefs"
    ADD CONSTRAINT "stream_discovery_prefs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_entrances"
    ADD CONSTRAINT "stream_entrances_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_entries"
    ADD CONSTRAINT "stream_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_entries"
    ADD CONSTRAINT "stream_entries_stream_id_user_id_key" UNIQUE ("stream_id", "user_id");



ALTER TABLE ONLY "public"."stream_events"
    ADD CONSTRAINT "stream_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_gifts"
    ADD CONSTRAINT "stream_gifts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_join_requests"
    ADD CONSTRAINT "stream_join_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_join_requests"
    ADD CONSTRAINT "stream_join_requests_stream_id_user_id_key" UNIQUE ("stream_id", "user_id");



ALTER TABLE ONLY "public"."stream_likes"
    ADD CONSTRAINT "stream_likes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_likes"
    ADD CONSTRAINT "stream_likes_stream_id_user_id_key" UNIQUE ("stream_id", "user_id");



ALTER TABLE ONLY "public"."stream_messages"
    ADD CONSTRAINT "stream_messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_momentum"
    ADD CONSTRAINT "stream_momentum_pkey" PRIMARY KEY ("stream_id");



ALTER TABLE ONLY "public"."stream_mute_counts"
    ADD CONSTRAINT "stream_mute_counts_pkey" PRIMARY KEY ("stream_id", "target_user_id");



ALTER TABLE ONLY "public"."stream_participants"
    ADD CONSTRAINT "stream_participants_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_passwords"
    ADD CONSTRAINT "stream_passwords_pkey" PRIMARY KEY ("stream_id");



ALTER TABLE ONLY "public"."stream_presets"
    ADD CONSTRAINT "stream_presets_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_ranking"
    ADD CONSTRAINT "stream_ranking_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_reactions"
    ADD CONSTRAINT "stream_reactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_reports"
    ADD CONSTRAINT "stream_reports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_sessions"
    ADD CONSTRAINT "stream_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_snack_purchases"
    ADD CONSTRAINT "stream_snack_purchases_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_viewers"
    ADD CONSTRAINT "stream_viewers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_viewers"
    ADD CONSTRAINT "stream_viewers_stream_id_user_id_key" UNIQUE ("stream_id", "user_id");



ALTER TABLE ONLY "public"."stream_vods"
    ADD CONSTRAINT "stream_vods_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."streams_participants"
    ADD CONSTRAINT "streams_participants_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."streams"
    ADD CONSTRAINT "streams_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."support_tickets"
    ADD CONSTRAINT "support_tickets_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."system_alerts"
    ADD CONSTRAINT "system_alerts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."system_errors"
    ADD CONSTRAINT "system_errors_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."system_settings"
    ADD CONSTRAINT "system_settings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."task_completions"
    ADD CONSTRAINT "task_completions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."task_history"
    ADD CONSTRAINT "task_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."task_templates"
    ADD CONSTRAINT "task_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tax_report_status"
    ADD CONSTRAINT "tax_report_status_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tax_report_status"
    ADD CONSTRAINT "tax_report_status_user_id_year_key" UNIQUE ("user_id", "year");



ALTER TABLE ONLY "public"."ticket_messages"
    ADD CONSTRAINT "ticket_messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."training_scenarios"
    ADD CONSTRAINT "training_scenarios_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."transactions"
    ADD CONSTRAINT "transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_ai_avatars"
    ADD CONSTRAINT "troll_ai_avatars_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_battle_gifts"
    ADD CONSTRAINT "troll_battle_gifts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_battles"
    ADD CONSTRAINT "troll_battles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_court_cases"
    ADD CONSTRAINT "troll_court_cases_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_dna_events"
    ADD CONSTRAINT "troll_dna_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_dna_profiles"
    ADD CONSTRAINT "troll_dna_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_dna_traits"
    ADD CONSTRAINT "troll_dna_traits_key_key" UNIQUE ("key");



ALTER TABLE ONLY "public"."troll_dna_traits"
    ADD CONSTRAINT "troll_dna_traits_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_drops_log"
    ADD CONSTRAINT "troll_drops_log_cycle_start_broadcaster_id_key" UNIQUE ("cycle_start", "broadcaster_id");



ALTER TABLE ONLY "public"."troll_drops_log"
    ADD CONSTRAINT "troll_drops_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_drops"
    ADD CONSTRAINT "troll_drops_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_event_claims"
    ADD CONSTRAINT "troll_event_claims_event_id_user_id_key" UNIQUE ("event_id", "user_id");



ALTER TABLE ONLY "public"."troll_event_claims"
    ADD CONSTRAINT "troll_event_claims_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_events"
    ADD CONSTRAINT "troll_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_families"
    ADD CONSTRAINT "troll_families_family_name_key" UNIQUE ("family_name");



ALTER TABLE ONLY "public"."troll_families"
    ADD CONSTRAINT "troll_families_family_tag_key" UNIQUE ("family_tag");



ALTER TABLE ONLY "public"."troll_families"
    ADD CONSTRAINT "troll_families_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_family_members"
    ADD CONSTRAINT "troll_family_members_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_family_memberships"
    ADD CONSTRAINT "troll_family_memberships_family_id_user_id_key" UNIQUE ("family_id", "user_id");



ALTER TABLE ONLY "public"."troll_family_memberships"
    ADD CONSTRAINT "troll_family_memberships_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_family_messages"
    ADD CONSTRAINT "troll_family_messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_family_wars"
    ADD CONSTRAINT "troll_family_wars_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_gift_items"
    ADD CONSTRAINT "troll_gift_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_officer_applications"
    ADD CONSTRAINT "troll_officer_applications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_officers"
    ADD CONSTRAINT "troll_officers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_post_comments"
    ADD CONSTRAINT "troll_post_comments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_post_gifts"
    ADD CONSTRAINT "troll_post_gifts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_post_reactions"
    ADD CONSTRAINT "troll_post_reactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_post_views"
    ADD CONSTRAINT "troll_post_views_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_posts"
    ADD CONSTRAINT "troll_posts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_stream_messages"
    ADD CONSTRAINT "troll_stream_messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_streams"
    ADD CONSTRAINT "troll_streams_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_wall_gifts"
    ADD CONSTRAINT "troll_wall_gifts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_wall_likes"
    ADD CONSTRAINT "troll_wall_likes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_wall_likes"
    ADD CONSTRAINT "troll_wall_likes_post_id_user_id_key" UNIQUE ("post_id", "user_id");



ALTER TABLE ONLY "public"."troll_wall_posts"
    ADD CONSTRAINT "troll_wall_posts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_wall_reactions"
    ADD CONSTRAINT "troll_wall_reactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."troll_wall_reactions"
    ADD CONSTRAINT "troll_wall_reactions_post_id_user_id_reaction_type_key" UNIQUE ("post_id", "user_id", "reaction_type");



ALTER TABLE ONLY "public"."trollcity_orders"
    ADD CONSTRAINT "trollcity_orders_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."trollcity_products"
    ADD CONSTRAINT "trollcity_products_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."trollcity_shops"
    ADD CONSTRAINT "trollcity_shops_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."trollmond_gifts"
    ADD CONSTRAINT "trollmond_gifts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."trollmond_ledger"
    ADD CONSTRAINT "trollmond_ledger_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."trollmond_store_items"
    ADD CONSTRAINT "trollmond_store_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."trollmond_transactions"
    ADD CONSTRAINT "trollmond_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."coin_pool_contributions"
    ADD CONSTRAINT "trollmonds_pool_contributions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."trollmonds_pools"
    ADD CONSTRAINT "trollmonds_pools_pkey" PRIMARY KEY ("stream_id");



ALTER TABLE ONLY "public"."trolls_night_applications"
    ADD CONSTRAINT "trolls_night_applications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."trollstown_properties"
    ADD CONSTRAINT "trollstown_properties_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."trollstown_property_upgrades"
    ADD CONSTRAINT "trollstown_property_upgrades_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."trollstown_property_upgrades"
    ADD CONSTRAINT "trollstown_property_upgrades_property_id_key" UNIQUE ("property_id");



ALTER TABLE ONLY "public"."trollstown_upgrade_config"
    ADD CONSTRAINT "trollstown_upgrade_config_pkey" PRIMARY KEY ("upgrade_type", "level");



ALTER TABLE ONLY "public"."trolltract_contracts"
    ADD CONSTRAINT "trolltract_contracts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."trolltract_weekly_rewards"
    ADD CONSTRAINT "trolltract_weekly_rewards_contract_id_week_start_key" UNIQUE ("contract_id", "week_start");



ALTER TABLE ONLY "public"."trolltract_weekly_rewards"
    ADD CONSTRAINT "trolltract_weekly_rewards_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tromody_battles"
    ADD CONSTRAINT "tromody_battles_battle_id_key" UNIQUE ("battle_id");



ALTER TABLE ONLY "public"."tromody_battles"
    ADD CONSTRAINT "tromody_battles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tromody_gifts"
    ADD CONSTRAINT "tromody_gifts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tromody_matches"
    ADD CONSTRAINT "tromody_matches_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tromody_matches"
    ADD CONSTRAINT "tromody_matches_room_name_key" UNIQUE ("room_name");



ALTER TABLE ONLY "public"."tromody_queue"
    ADD CONSTRAINT "tromody_queue_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."tromody_sessions"
    ADD CONSTRAINT "tromody_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."trophies"
    ADD CONSTRAINT "trophies_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."typing_statuses"
    ADD CONSTRAINT "typing_statuses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."event_participants"
    ADD CONSTRAINT "unique_event_participant" UNIQUE ("event_id", "user_id");



ALTER TABLE ONLY "public"."officer_performance"
    ADD CONSTRAINT "unique_officer_performance" UNIQUE ("officer_id");



ALTER TABLE ONLY "public"."seller_reliability"
    ADD CONSTRAINT "unique_seller_reliability" UNIQUE ("seller_id");



ALTER TABLE ONLY "public"."stream_ranking"
    ADD CONSTRAINT "unique_stream_ranking" UNIQUE ("stream_id");



ALTER TABLE ONLY "public"."stream_discovery_prefs"
    ADD CONSTRAINT "unique_user_discovery_prefs" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."user_reputation"
    ADD CONSTRAINT "unique_user_reputation" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."user_active_entrance_effect"
    ADD CONSTRAINT "user_active_entrance_effect_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."user_active_items"
    ADD CONSTRAINT "user_active_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_active_items"
    ADD CONSTRAINT "user_active_items_user_id_item_id_key" UNIQUE ("user_id", "item_id");



ALTER TABLE ONLY "public"."user_agreements"
    ADD CONSTRAINT "user_agreements_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_agreements"
    ADD CONSTRAINT "user_agreements_user_version_uniq" UNIQUE ("user_id", "agreement_version");



ALTER TABLE ONLY "public"."user_badges_earned"
    ADD CONSTRAINT "user_badges_earned_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_badges_earned"
    ADD CONSTRAINT "user_badges_earned_user_id_badge_id_key" UNIQUE ("user_id", "badge_id");



ALTER TABLE ONLY "public"."user_balances"
    ADD CONSTRAINT "user_balances_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."user_bans"
    ADD CONSTRAINT "user_bans_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_boosts"
    ADD CONSTRAINT "user_boosts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_broadcast_theme_purchases"
    ADD CONSTRAINT "user_broadcast_theme_purchases_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_broadcast_theme_purchases"
    ADD CONSTRAINT "user_broadcast_theme_purchases_user_id_theme_id_key" UNIQUE ("user_id", "theme_id");



ALTER TABLE ONLY "public"."user_broadcast_theme_state"
    ADD CONSTRAINT "user_broadcast_theme_state_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."user_call_sounds"
    ADD CONSTRAINT "user_call_sounds_pkey" PRIMARY KEY ("user_id", "sound_id");



ALTER TABLE ONLY "public"."user_devices"
    ADD CONSTRAINT "user_devices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_district_progress"
    ADD CONSTRAINT "user_district_progress_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_district_progress"
    ADD CONSTRAINT "user_district_progress_user_id_district_id_key" UNIQUE ("user_id", "district_id");



ALTER TABLE ONLY "public"."user_entrance_effects"
    ADD CONSTRAINT "user_entrance_effects_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_entrance_effects"
    ADD CONSTRAINT "user_entrance_effects_user_id_effect_id_key" UNIQUE ("user_id", "effect_id");



ALTER TABLE ONLY "public"."user_entrances"
    ADD CONSTRAINT "user_entrances_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_follows"
    ADD CONSTRAINT "user_follows_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_insurance"
    ADD CONSTRAINT "user_insurance_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_insurances"
    ADD CONSTRAINT "user_insurances_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_insurances"
    ADD CONSTRAINT "user_insurances_user_id_insurance_id_purchased_at_key" UNIQUE ("user_id", "insurance_id", "purchased_at");



ALTER TABLE ONLY "public"."user_inventory"
    ADD CONSTRAINT "user_inventory_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_inventory"
    ADD CONSTRAINT "user_inventory_user_id_item_id_key" UNIQUE ("user_id", "item_id");



ALTER TABLE ONLY "public"."user_ip_tracking"
    ADD CONSTRAINT "user_ip_tracking_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_levels"
    ADD CONSTRAINT "user_levels_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_levels"
    ADD CONSTRAINT "user_levels_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."user_notifications"
    ADD CONSTRAINT "user_notifications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_payment_methods"
    ADD CONSTRAINT "user_payment_methods_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_payout_settings"
    ADD CONSTRAINT "user_payout_settings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_payout_settings"
    ADD CONSTRAINT "user_payout_settings_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."user_perks"
    ADD CONSTRAINT "user_perks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_perks"
    ADD CONSTRAINT "user_perks_user_id_perk_id_purchased_at_key" UNIQUE ("user_id", "perk_id", "purchased_at");



ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_reputation"
    ADD CONSTRAINT "user_reputation_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_risk_profile"
    ADD CONSTRAINT "user_risk_profile_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_user_id_role_key" UNIQUE ("user_id", "role");



ALTER TABLE ONLY "public"."user_streamer_entitlements"
    ADD CONSTRAINT "user_streamer_entitlements_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."user_tax_info"
    ADD CONSTRAINT "user_tax_info_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_wallets"
    ADD CONSTRAINT "user_wallets_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_wallets"
    ADD CONSTRAINT "user_wallets_user_id_unique" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_display_name_key" UNIQUE ("display_name");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_referral_code_key" UNIQUE ("referral_code");



ALTER TABLE ONLY "public"."vendor_invoices"
    ADD CONSTRAINT "vendor_invoices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."verification_requests"
    ADD CONSTRAINT "verification_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."verification_transactions"
    ADD CONSTRAINT "verification_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."videos"
    ADD CONSTRAINT "videos_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."visa_redemptions"
    ADD CONSTRAINT "visa_redemptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."wall_posts"
    ADD CONSTRAINT "wall_posts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."war_results"
    ADD CONSTRAINT "war_results_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."wars"
    ADD CONSTRAINT "wars_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."web_push_subscriptions"
    ADD CONSTRAINT "web_push_subscriptions_endpoint_key" UNIQUE ("endpoint");



ALTER TABLE ONLY "public"."web_push_subscriptions"
    ADD CONSTRAINT "web_push_subscriptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."weekly_officer_reports"
    ADD CONSTRAINT "weekly_officer_reports_lead_officer_id_week_start_week_end_key" UNIQUE ("lead_officer_id", "week_start", "week_end");



ALTER TABLE ONLY "public"."weekly_officer_reports"
    ADD CONSTRAINT "weekly_officer_reports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."weekly_reports"
    ADD CONSTRAINT "weekly_reports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."wheel_spins"
    ADD CONSTRAINT "wheel_spins_pkey" PRIMARY KEY ("id");



CREATE INDEX "action_logs_created_day_idx" ON "public"."action_logs" USING "btree" ("created_day");



CREATE INDEX "admin_pool_is_active_idx" ON "public"."admin_pool" USING "btree" ("is_active");



CREATE UNIQUE INDEX "admin_pool_user_id_unique" ON "public"."admin_pool" USING "btree" ("user_id");



CREATE INDEX "broadcast_seats_stream_id_idx" ON "public"."broadcast_seats" USING "btree" ("stream_id");



CREATE INDEX "broadcast_seats_user_id_idx" ON "public"."broadcast_seats" USING "btree" ("user_id");



CREATE INDEX "broadcast_seat_bans_room_user_id_idx" ON "public"."broadcast_seat_bans" USING "btree" ("room", "user_id");



CREATE INDEX "broadcast_theme_events_theme_id_idx" ON "public"."broadcast_theme_events" USING "btree" ("theme_id");



CREATE INDEX "broadcast_theme_events_user_id_idx" ON "public"."broadcast_theme_events" USING "btree" ("user_id");



CREATE INDEX "broadcast_tokens_stream_id_idx" ON "public"."broadcast_tokens" USING "btree" ("stream_id");



CREATE INDEX "broadcast_tokens_user_id_idx" ON "public"."broadcast_tokens" USING "btree" ("user_id");



CREATE INDEX "coin_audit_log_created_at_idx" ON "public"."coin_audit_log" USING "btree" ("created_at");



CREATE INDEX "coin_audit_log_user_id_idx" ON "public"."coin_audit_log" USING "btree" ("user_id");



CREATE INDEX "coin_tx_user_idx" ON "public"."coin_transactions" USING "btree" ("user_id");



CREATE INDEX "court_ai_messages_case_id_idx" ON "public"."court_ai_messages" USING "btree" ("case_id");



CREATE INDEX "court_ai_messages_created_at_idx" ON "public"."court_ai_messages" USING "btree" ("created_at" DESC);



CREATE INDEX "court_ai_messages_session_id_idx" ON "public"."court_ai_messages" USING "btree" ("session_id");



CREATE INDEX "court_ai_messages_user_id_idx" ON "public"."court_ai_messages" USING "btree" ("user_id");



CREATE UNIQUE INDEX "creator_migration_claims_platform_unique" ON "public"."creator_migration_claims" USING "btree" ("platform_name", "platform_user_id");



CREATE UNIQUE INDEX "creator_migration_claims_user_unique" ON "public"."creator_migration_claims" USING "btree" ("user_id");



CREATE INDEX "deed_transfers_deed_id_idx" ON "public"."deed_transfers" USING "btree" ("deed_id");



CREATE INDEX "deed_transfers_from_user_id_idx" ON "public"."deed_transfers" USING "btree" ("from_user_id");



CREATE INDEX "deed_transfers_to_user_id_idx" ON "public"."deed_transfers" USING "btree" ("to_user_id");



CREATE INDEX "deeds_current_owner_user_id_idx" ON "public"."deeds" USING "btree" ("current_owner_user_id");



CREATE INDEX "deeds_owner_user_id_idx" ON "public"."deeds" USING "btree" ("owner_user_id");



CREATE INDEX "deeds_property_id_idx" ON "public"."deeds" USING "btree" ("property_id");



CREATE INDEX "family_activity_log_created_at_idx" ON "public"."family_activity_log" USING "btree" ("created_at" DESC);



CREATE INDEX "family_activity_log_family_idx" ON "public"."family_activity_log" USING "btree" ("family_id");



CREATE INDEX "family_messages_idx" ON "public"."troll_family_messages" USING "btree" ("family_id", "created_at");



CREATE INDEX "family_shop_items_active_idx" ON "public"."family_shop_items" USING "btree" ("is_active");



CREATE UNIQUE INDEX "family_shop_items_item_code_unique" ON "public"."family_shop_items" USING "btree" ("item_code");



CREATE INDEX "family_shop_purchases_family_idx" ON "public"."family_shop_purchases" USING "btree" ("family_id");



CREATE INDEX "family_stats_level_idx" ON "public"."family_stats" USING "btree" ("family_level" DESC);



CREATE INDEX "family_stats_weekly_score_idx" ON "public"."family_stats" USING "btree" ("weekly_score" DESC);



CREATE INDEX "gift_lb_entries_rank_idx" ON "public"."gift_leaderboard_entries" USING "btree" ("rank");



CREATE INDEX "gift_tx_created_at_idx" ON "public"."gift_transactions" USING "btree" ("created_at" DESC);



CREATE INDEX "gift_tx_receiver_idx" ON "public"."gift_transactions" USING "btree" ("receiver_id");



CREATE INDEX "gift_tx_sender_idx" ON "public"."gift_transactions" USING "btree" ("sender_id");



CREATE UNIQUE INDEX "gifts_gift_slug_key" ON "public"."gifts" USING "btree" ("gift_slug");



CREATE UNIQUE INDEX "gifts_slug_key" ON "public"."gifts" USING "btree" ("slug");



CREATE UNIQUE INDEX "gifts_slug_unique" ON "public"."gifts" USING "btree" ("slug");



CREATE INDEX "idx_abuse_reports_created_at" ON "public"."abuse_reports" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_abuse_reports_offender_user_id" ON "public"."abuse_reports" USING "btree" ("offender_user_id");



CREATE INDEX "idx_abuse_reports_reported_by" ON "public"."abuse_reports" USING "btree" ("reported_by");



CREATE INDEX "idx_abuse_reports_reviewed" ON "public"."abuse_reports" USING "btree" ("reviewed");



CREATE INDEX "idx_abuse_reports_stream" ON "public"."abuse_reports" USING "btree" ("stream_id", "severity", "created_at");



CREATE INDEX "idx_abuse_reports_stream_id" ON "public"."abuse_reports" USING "btree" ("stream_id");



CREATE INDEX "idx_action_logs_actor_id" ON "public"."action_logs" USING "btree" ("actor_id");



CREATE INDEX "idx_active_entrance_effect_effect_id" ON "public"."user_active_entrance_effect" USING "btree" ("effect_id");



CREATE INDEX "idx_active_items_active" ON "public"."user_active_items" USING "btree" ("user_id", "is_active");



CREATE INDEX "idx_active_items_user" ON "public"."user_active_items" USING "btree" ("user_id");



CREATE INDEX "idx_active_sessions_is_active" ON "public"."active_sessions" USING "btree" ("is_active");



CREATE INDEX "idx_active_sessions_session_id" ON "public"."active_sessions" USING "btree" ("session_id");



CREATE INDEX "idx_active_sessions_user_id" ON "public"."active_sessions" USING "btree" ("user_id");



CREATE INDEX "idx_activity_logs_gifter_id" ON "public"."activity_logs" USING "btree" ("gifter_id");



CREATE INDEX "idx_activity_logs_receiver_id" ON "public"."activity_logs" USING "btree" ("receiver_id");



CREATE INDEX "idx_activity_logs_target_user_id" ON "public"."activity_logs" USING "btree" ("target_user_id");



CREATE INDEX "idx_activity_logs_user_id" ON "public"."activity_logs" USING "btree" ("user_id");



CREATE INDEX "idx_admin_adjustments_admin_id" ON "public"."admin_adjustments" USING "btree" ("admin_id");



CREATE INDEX "idx_admin_adjustments_target_user_id" ON "public"."admin_adjustments" USING "btree" ("target_user_id");



CREATE INDEX "idx_admin_broadcasts_created_at" ON "public"."admin_broadcasts" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_admin_coin_revenue_user_id" ON "public"."admin_coin_revenue" USING "btree" ("user_id");



CREATE INDEX "idx_admin_flags_user_id" ON "public"."admin_flags" USING "btree" ("user_id");



CREATE INDEX "idx_admin_gift_totals_admin_id" ON "public"."admin_gift_totals" USING "btree" ("admin_id");



CREATE INDEX "idx_admin_gift_totals_total_coins" ON "public"."admin_gift_totals" USING "btree" ("total_troll_coins" DESC);



CREATE INDEX "idx_admin_gift_totals_user_admin" ON "public"."admin_gift_totals" USING "btree" ("user_id", "admin_id");



CREATE INDEX "idx_admin_gift_totals_user_id" ON "public"."admin_gift_totals" USING "btree" ("user_id");



CREATE INDEX "idx_admin_tax_reviews_reviewer_id" ON "public"."admin_tax_reviews" USING "btree" ("reviewer_id");



CREATE INDEX "idx_admin_tax_reviews_user_id" ON "public"."admin_tax_reviews" USING "btree" ("user_id");



CREATE INDEX "idx_admin_top_buyers_user_id" ON "public"."admin_top_buyers" USING "btree" ("user_id");



CREATE INDEX "idx_ai_action_logs_applied_by" ON "public"."ai_action_logs" USING "btree" ("applied_by");



CREATE INDEX "idx_ai_action_logs_context_type" ON "public"."ai_action_logs" USING "btree" ("context_type");



CREATE INDEX "idx_ai_action_logs_created_at" ON "public"."ai_action_logs" USING "btree" ("created_at");



CREATE INDEX "idx_ai_action_logs_user_id" ON "public"."ai_action_logs" USING "btree" ("user_id");



CREATE INDEX "idx_applications_appeal_reviewed_by" ON "public"."applications" USING "btree" ("appeal_reviewed_by");



CREATE INDEX "idx_applications_contact_email" ON "public"."applications" USING "btree" ("contact_email");



CREATE INDEX "idx_applications_lead_officer_reviewed_by" ON "public"."applications" USING "btree" ("lead_officer_reviewed_by");



CREATE INDEX "idx_applications_product_types" ON "public"."applications" USING "gin" ("product_types");



CREATE INDEX "idx_applications_reviewed_by" ON "public"."applications" USING "btree" ("reviewed_by");



CREATE INDEX "idx_applications_role_applied" ON "public"."applications" USING "btree" ("role_applied");



CREATE INDEX "idx_applications_status" ON "public"."applications" USING "btree" ("status");



CREATE INDEX "idx_applications_type" ON "public"."applications" USING "btree" ("type");



CREATE INDEX "idx_applications_type_status" ON "public"."applications" USING "btree" ("type", "status");



CREATE INDEX "idx_applications_user_id" ON "public"."applications" USING "btree" ("user_id");



CREATE INDEX "idx_balance_ledger_user_id" ON "public"."balance_ledger" USING "btree" ("user_id");



CREATE INDEX "idx_battle_gifts_battle_id" ON "public"."battle_gifts" USING "btree" ("battle_id");



CREATE INDEX "idx_battle_gifts_receiver_id" ON "public"."battle_gifts" USING "btree" ("receiver_id");



CREATE INDEX "idx_battle_gifts_sender_id" ON "public"."battle_gifts" USING "btree" ("sender_id");



CREATE INDEX "idx_battle_history_battle_id" ON "public"."battle_history" USING "btree" ("battle_id");



CREATE INDEX "idx_battle_history_opponent_id" ON "public"."battle_history" USING "btree" ("opponent_id");



CREATE INDEX "idx_battle_history_user_id" ON "public"."battle_history" USING "btree" ("user_id");



CREATE INDEX "idx_battle_rewards_battle_id" ON "public"."battle_rewards" USING "btree" ("battle_id");



CREATE INDEX "idx_battle_rewards_user_id" ON "public"."battle_rewards" USING "btree" ("user_id");



CREATE INDEX "idx_battle_sessions_opponent_stream_id" ON "public"."battle_sessions" USING "btree" ("opponent_stream_id");



CREATE INDEX "idx_battle_sessions_stream_id" ON "public"."battle_sessions" USING "btree" ("stream_id");



CREATE INDEX "idx_broadcast_cycle_stats_broadcaster_id" ON "public"."broadcast_cycle_stats" USING "btree" ("broadcaster_id");



CREATE INDEX "idx_broadcast_cycle_stats_cycle_paid" ON "public"."broadcast_cycle_stats" USING "btree" ("cycle_start", "paid_coins_received" DESC);



CREATE INDEX "idx_broadcast_cycle_stats_cycle_score" ON "public"."broadcast_cycle_stats" USING "btree" ("cycle_start", "popularity_score" DESC);



CREATE INDEX "idx_broadcast_cycle_stats_stream_id" ON "public"."broadcast_cycle_stats" USING "btree" ("stream_id");



CREATE INDEX "idx_broadcast_seats_stream_id" ON "public"."broadcast_seats" USING "btree" ("stream_id");



CREATE INDEX "idx_broadcast_seats_user_id" ON "public"."broadcast_seats" USING "btree" ("user_id");



CREATE INDEX "idx_broadcast_theme_active" ON "public"."broadcast_background_themes" USING "btree" ("is_active", "sort_order");



CREATE INDEX "idx_broadcast_theme_purchases_user" ON "public"."user_broadcast_theme_purchases" USING "btree" ("user_id");



CREATE INDEX "idx_broadcast_tokens_stream_id" ON "public"."broadcast_tokens" USING "btree" ("stream_id");



CREATE INDEX "idx_broadcast_tokens_user_id" ON "public"."broadcast_tokens" USING "btree" ("user_id");



CREATE INDEX "idx_broadcaster_applications_created_at" ON "public"."broadcaster_applications" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_broadcaster_applications_reviewed_by" ON "public"."broadcaster_applications" USING "btree" ("reviewed_by");



CREATE INDEX "idx_broadcaster_applications_status" ON "public"."broadcaster_applications" USING "btree" ("application_status");



CREATE INDEX "idx_broadcaster_applications_user_id" ON "public"."broadcaster_applications" USING "btree" ("user_id");



CREATE INDEX "idx_broadcaster_apps_user" ON "public"."broadcaster_applications" USING "btree" ("user_id");



CREATE INDEX "idx_broadcaster_earnings_broadcaster_id" ON "public"."broadcaster_earnings" USING "btree" ("broadcaster_id");



CREATE INDEX "idx_broadcaster_earnings_created" ON "public"."broadcaster_earnings" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_broadcaster_earnings_created_at" ON "public"."broadcaster_earnings" USING "btree" ("created_at");



CREATE INDEX "idx_broadcaster_earnings_gift_id" ON "public"."broadcaster_earnings" USING "btree" ("gift_id");



CREATE INDEX "idx_broadcaster_earnings_user" ON "public"."broadcaster_earnings" USING "btree" ("broadcaster_id");



CREATE INDEX "idx_call_history_caller" ON "public"."call_history" USING "btree" ("caller_id");



CREATE INDEX "idx_call_history_caller_id" ON "public"."call_history" USING "btree" ("caller_id");



CREATE INDEX "idx_call_history_receiver" ON "public"."call_history" USING "btree" ("receiver_id");



CREATE INDEX "idx_call_history_receiver_id" ON "public"."call_history" USING "btree" ("receiver_id");



CREATE INDEX "idx_call_history_room" ON "public"."call_history" USING "btree" ("room_id");



CREATE INDEX "idx_call_minutes_user_id" ON "public"."call_minutes" USING "btree" ("user_id");



CREATE INDEX "idx_call_sound_catalog_active" ON "public"."call_sound_catalog" USING "btree" ("is_active", "sound_type");



CREATE INDEX "idx_case_audit_logs_actor_id" ON "public"."case_audit_logs" USING "btree" ("actor_id");



CREATE INDEX "idx_case_audit_logs_case_id" ON "public"."case_audit_logs" USING "btree" ("case_id");



CREATE INDEX "idx_case_evidence_case_id" ON "public"."case_evidence" USING "btree" ("case_id");



CREATE INDEX "idx_case_evidence_uploader_id" ON "public"."case_evidence" USING "btree" ("uploader_id");



CREATE INDEX "idx_case_evidence_verified_by" ON "public"."case_evidence" USING "btree" ("verified_by");



CREATE INDEX "idx_case_participants_case_id" ON "public"."case_participants" USING "btree" ("case_id");



CREATE INDEX "idx_case_participants_user_id" ON "public"."case_participants" USING "btree" ("user_id");



CREATE INDEX "idx_cashout_requests_user_id" ON "public"."cashout_requests" USING "btree" ("user_id");



CREATE INDEX "idx_cashout_requests_user_status" ON "public"."cashout_requests" USING "btree" ("user_id", "status");



CREATE INDEX "idx_city_districts_active" ON "public"."city_districts" USING "btree" ("is_active", "sort_order");



CREATE INDEX "idx_city_districts_role" ON "public"."city_districts" USING "btree" ("required_role");



CREATE INDEX "idx_city_events_active" ON "public"."city_events" USING "btree" ("is_active");



CREATE INDEX "idx_city_events_created_by" ON "public"."city_events" USING "btree" ("created_by");



CREATE INDEX "idx_city_events_time" ON "public"."city_events" USING "btree" ("start_time", "end_time");



CREATE INDEX "idx_clan_rewards_family_id" ON "public"."clan_rewards" USING "btree" ("family_id");



CREATE INDEX "idx_clan_vault_family_id" ON "public"."clan_vault" USING "btree" ("family_id");



CREATE INDEX "idx_coin_ledger_type" ON "public"."coin_ledger" USING "btree" ("type");



CREATE INDEX "idx_coin_ledger_user" ON "public"."coin_ledger" USING "btree" ("user_id", "created_at" DESC);



CREATE INDEX "idx_coin_packages_active" ON "public"."coin_packages" USING "btree" ("is_active");



CREATE INDEX "idx_coin_pool_contributions_sender_id" ON "public"."coin_pool_contributions" USING "btree" ("sender_id");



CREATE INDEX "idx_coin_pool_contributions_stream_id" ON "public"."coin_pool_contributions" USING "btree" ("stream_id");



CREATE INDEX "idx_coin_transactions_admin_grant" ON "public"."coin_transactions" USING "btree" ("type", "created_at") WHERE ("type" = 'admin_grant'::"text");



COMMENT ON INDEX "public"."idx_coin_transactions_admin_grant" IS 'Index for tracking admin coin grants';



CREATE INDEX "idx_coin_transactions_coin_type" ON "public"."coin_transactions" USING "btree" ("coin_type");



CREATE INDEX "idx_coin_transactions_created_at" ON "public"."coin_transactions" USING "btree" ("created_at");



CREATE INDEX "idx_coin_transactions_external_id" ON "public"."coin_transactions" USING "btree" ("external_id");



CREATE INDEX "idx_coin_transactions_from_user" ON "public"."coin_transactions" USING "btree" ("from_user_id");



CREATE INDEX "idx_coin_transactions_paypal_capture_id" ON "public"."coin_transactions" USING "btree" ("paypal_capture_id");



CREATE UNIQUE INDEX "idx_coin_transactions_paypal_order_id" ON "public"."coin_transactions" USING "btree" ("paypal_order_id") WHERE ("paypal_order_id" IS NOT NULL);



CREATE INDEX "idx_coin_transactions_to_user" ON "public"."coin_transactions" USING "btree" ("to_user_id");



CREATE INDEX "idx_coin_transactions_type" ON "public"."coin_transactions" USING "btree" ("type");



CREATE INDEX "idx_coin_transactions_user_id" ON "public"."coin_transactions" USING "btree" ("user_id");



CREATE INDEX "idx_coin_tx_user_id" ON "public"."coin_transactions" USING "btree" ("user_id");



CREATE INDEX "idx_coinback_log_source_created" ON "public"."coinback_log" USING "btree" ("source", "created_at" DESC);



CREATE INDEX "idx_coinback_log_user_created" ON "public"."coinback_log" USING "btree" ("user_id", "created_at" DESC);



CREATE INDEX "idx_coinback_log_user_id" ON "public"."coinback_log" USING "btree" ("user_id");



CREATE INDEX "idx_conversation_members_user" ON "public"."conversation_members" USING "btree" ("user_id");



CREATE INDEX "idx_conversation_messages_conversation_created" ON "public"."conversation_messages" USING "btree" ("conversation_id", "created_at");



CREATE INDEX "idx_conversation_messages_sender" ON "public"."conversation_messages" USING "btree" ("sender_id");



CREATE INDEX "idx_court_box_members_session_id" ON "public"."court_box_members" USING "btree" ("session_id");



CREATE INDEX "idx_court_box_members_user_id" ON "public"."court_box_members" USING "btree" ("user_id");



CREATE INDEX "idx_court_cases_accuser" ON "public"."court_cases" USING "btree" ("accuser");



CREATE INDEX "idx_court_cases_defendant_id" ON "public"."court_cases" USING "btree" ("defendant_id");



CREATE INDEX "idx_court_cases_judge_id" ON "public"."court_cases" USING "btree" ("judge_id");



CREATE INDEX "idx_court_cases_plaintiff_id" ON "public"."court_cases" USING "btree" ("plaintiff_id");



CREATE INDEX "idx_court_docket_assigned_officer" ON "public"."court_docket" USING "btree" ("assigned_officer");



CREATE INDEX "idx_court_docket_court_session_id" ON "public"."court_docket" USING "btree" ("court_session_id");



CREATE INDEX "idx_court_docket_officer" ON "public"."court_docket" USING "btree" ("assigned_officer");



CREATE INDEX "idx_court_docket_scheduled" ON "public"."court_docket" USING "btree" ("scheduled_at");



CREATE INDEX "idx_court_docket_session" ON "public"."court_docket" USING "btree" ("court_session_id");



CREATE INDEX "idx_court_docket_status" ON "public"."court_docket" USING "btree" ("status");



CREATE INDEX "idx_court_docket_user" ON "public"."court_docket" USING "btree" ("user_id");



CREATE INDEX "idx_court_docket_user_id" ON "public"."court_docket" USING "btree" ("user_id");



CREATE INDEX "idx_court_rulings_archive_appealed_ruling_id" ON "public"."court_rulings_archive" USING "btree" ("appealed_ruling_id");



CREATE INDEX "idx_court_rulings_archive_case_type" ON "public"."court_rulings_archive" USING "btree" ("case_type");



CREATE INDEX "idx_court_rulings_archive_court_session_id" ON "public"."court_rulings_archive" USING "btree" ("court_session_id");



CREATE INDEX "idx_court_rulings_archive_created_at" ON "public"."court_rulings_archive" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_court_rulings_archive_public" ON "public"."court_rulings_archive" USING "btree" ("is_public");



CREATE INDEX "idx_court_sessions_accuser_id" ON "public"."court_sessions" USING "btree" ("accuser_id");



CREATE INDEX "idx_court_sessions_created_by" ON "public"."court_sessions" USING "btree" ("created_by");



CREATE INDEX "idx_court_sessions_defendant_id" ON "public"."court_sessions" USING "btree" ("defendant_id");



CREATE INDEX "idx_court_sessions_judge_id" ON "public"."court_sessions" USING "btree" ("judge_id");



CREATE INDEX "idx_court_sessions_started_at" ON "public"."court_sessions" USING "btree" ("started_at");



CREATE INDEX "idx_court_sessions_started_by" ON "public"."court_sessions" USING "btree" ("started_by");



CREATE INDEX "idx_court_sessions_status" ON "public"."court_sessions" USING "btree" ("status");



CREATE INDEX "idx_court_sessions_summons_id" ON "public"."court_sessions" USING "btree" ("summons_id");



CREATE INDEX "idx_court_summons_accuser_id" ON "public"."court_summons" USING "btree" ("accuser_id");



CREATE INDEX "idx_court_summons_created_by" ON "public"."court_summons" USING "btree" ("created_by");



CREATE INDEX "idx_court_summons_defendant_id" ON "public"."court_summons" USING "btree" ("defendant_id");



CREATE INDEX "idx_court_summons_incident" ON "public"."court_summons" USING "btree" ("incident_id");



CREATE INDEX "idx_court_summons_incident_id" ON "public"."court_summons" USING "btree" ("incident_id");



CREATE INDEX "idx_court_summons_judge_id" ON "public"."court_summons" USING "btree" ("judge_id");



CREATE INDEX "idx_court_summons_scheduled_for" ON "public"."court_summons" USING "btree" ("scheduled_for");



CREATE INDEX "idx_court_summons_status" ON "public"."court_summons" USING "btree" ("status");



CREATE INDEX "idx_court_summons_summoned_user_id" ON "public"."court_summons" USING "btree" ("summoned_user_id");



CREATE INDEX "idx_court_summons_user" ON "public"."court_summons" USING "btree" ("summoned_user_id");



CREATE INDEX "idx_creator_applications_category" ON "public"."creator_applications" USING "btree" ("category");



CREATE INDEX "idx_creator_applications_reviewer_id" ON "public"."creator_applications" USING "btree" ("reviewer_id");



CREATE INDEX "idx_creator_applications_status" ON "public"."creator_applications" USING "btree" ("status");



CREATE INDEX "idx_creator_applications_user_id" ON "public"."creator_applications" USING "btree" ("user_id");



CREATE UNIQUE INDEX "idx_creator_migration_claims_user_id" ON "public"."creator_migration_claims" USING "btree" ("user_id");



CREATE INDEX "idx_creator_migration_claims_verified_by" ON "public"."creator_migration_claims" USING "btree" ("verified_by");



CREATE INDEX "idx_creators_over_600_creator_id" ON "public"."creators_over_600" USING "btree" ("creator_id");



CREATE INDEX "idx_critical_alerts_resolved_by" ON "public"."critical_alerts" USING "btree" ("resolved_by");



CREATE INDEX "idx_daily_giveaways_date" ON "public"."daily_giveaways" USING "btree" ("giveaway_date");



CREATE INDEX "idx_daily_giveaways_user_date" ON "public"."daily_giveaways" USING "btree" ("user_id", "giveaway_date");



CREATE INDEX "idx_daily_giveaways_user_id" ON "public"."daily_giveaways" USING "btree" ("user_id");



CREATE INDEX "idx_declined_created_at" ON "public"."declined_transactions" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_declined_transactions_package_id" ON "public"."declined_transactions" USING "btree" ("package_id");



CREATE INDEX "idx_declined_transactions_user_id" ON "public"."declined_transactions" USING "btree" ("user_id");



CREATE INDEX "idx_declined_user_id" ON "public"."declined_transactions" USING "btree" ("user_id");



CREATE INDEX "idx_district_announcements_created_by" ON "public"."district_announcements" USING "btree" ("created_by");



CREATE INDEX "idx_district_announcements_district" ON "public"."district_announcements" USING "btree" ("district_id", "is_active");



CREATE INDEX "idx_district_announcements_district_id" ON "public"."district_announcements" USING "btree" ("district_id");



CREATE INDEX "idx_district_features_district" ON "public"."district_features" USING "btree" ("district_id", "is_enabled");



CREATE INDEX "idx_district_features_district_id" ON "public"."district_features" USING "btree" ("district_id");



CREATE INDEX "idx_earnings_status" ON "public"."earnings" USING "btree" ("status");



CREATE INDEX "idx_earnings_user_id" ON "public"."earnings" USING "btree" ("user_id");



CREATE INDEX "idx_economy_abuse_flags_related_user_id" ON "public"."economy_abuse_flags" USING "btree" ("related_user_id");



CREATE INDEX "idx_economy_abuse_flags_stream" ON "public"."economy_abuse_flags" USING "btree" ("stream_id", "created_at" DESC);



CREATE INDEX "idx_economy_abuse_flags_stream_id" ON "public"."economy_abuse_flags" USING "btree" ("stream_id");



CREATE INDEX "idx_economy_abuse_flags_user" ON "public"."economy_abuse_flags" USING "btree" ("user_id", "created_at" DESC);



CREATE INDEX "idx_economy_abuse_flags_user_id" ON "public"."economy_abuse_flags" USING "btree" ("user_id");



CREATE INDEX "idx_empire_applications_applicant_id" ON "public"."empire_applications" USING "btree" ("applicant_id");



CREATE INDEX "idx_empire_applications_reviewed_by" ON "public"."empire_applications" USING "btree" ("reviewed_by");



CREATE INDEX "idx_empire_applications_status" ON "public"."empire_applications" USING "btree" ("status");



CREATE INDEX "idx_empire_applications_user_id" ON "public"."empire_applications" USING "btree" ("user_id");



CREATE INDEX "idx_empire_partner_rewards_referred_user_id" ON "public"."empire_partner_rewards" USING "btree" ("referred_user_id");



CREATE INDEX "idx_empire_partner_rewards_referrer_id" ON "public"."empire_partner_rewards" USING "btree" ("referrer_id");



CREATE INDEX "idx_empire_partners_status" ON "public"."empire_partners" USING "btree" ("status");



CREATE INDEX "idx_empire_partners_user_id" ON "public"."empire_partners" USING "btree" ("user_id");



CREATE INDEX "idx_empire_referrals_referred" ON "public"."empire_referrals" USING "btree" ("referred_id");



CREATE INDEX "idx_empire_referrals_referrer" ON "public"."empire_referrals" USING "btree" ("referrer_id");



CREATE INDEX "idx_error_logs_created_at" ON "public"."error_logs" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_error_logs_severity" ON "public"."error_logs" USING "btree" ("severity");



CREATE INDEX "idx_error_logs_user_id" ON "public"."error_logs" USING "btree" ("user_id");



CREATE INDEX "idx_escalation_matrix_active" ON "public"."escalation_matrix" USING "btree" ("is_active");



CREATE INDEX "idx_escalation_matrix_violation_type" ON "public"."escalation_matrix" USING "btree" ("violation_type");



CREATE INDEX "idx_escalation_reports_escalated_by" ON "public"."escalation_reports" USING "btree" ("escalated_by");



CREATE INDEX "idx_escalation_reports_escalated_to" ON "public"."escalation_reports" USING "btree" ("escalated_to");



CREATE INDEX "idx_escalation_reports_original" ON "public"."escalation_reports" USING "btree" ("original_report_id");



CREATE INDEX "idx_escalation_reports_original_report_id" ON "public"."escalation_reports" USING "btree" ("original_report_id");



CREATE INDEX "idx_escalation_reports_status" ON "public"."escalation_reports" USING "btree" ("status");



CREATE INDEX "idx_event_participants_event" ON "public"."event_participants" USING "btree" ("event_id");



CREATE INDEX "idx_event_participants_event_id" ON "public"."event_participants" USING "btree" ("event_id");



CREATE INDEX "idx_event_participants_user" ON "public"."event_participants" USING "btree" ("user_id");



CREATE INDEX "idx_event_participants_user_id" ON "public"."event_participants" USING "btree" ("user_id");



CREATE INDEX "idx_executive_intake_assigned_secretary" ON "public"."executive_intake" USING "btree" ("assigned_secretary");



CREATE INDEX "idx_executive_intake_submitted_by" ON "public"."executive_intake" USING "btree" ("submitted_by");



CREATE INDEX "idx_executive_reports_created_by" ON "public"."executive_reports" USING "btree" ("created_by");



CREATE INDEX "idx_families_founder_id" ON "public"."families" USING "btree" ("founder_id");



CREATE INDEX "idx_family_activity_log_actor_id" ON "public"."family_activity_log" USING "btree" ("actor_id");



CREATE INDEX "idx_family_activity_log_family_id" ON "public"."family_activity_log" USING "btree" ("family_id");



CREATE INDEX "idx_family_activity_log_user_id" ON "public"."family_activity_log" USING "btree" ("user_id");



CREATE INDEX "idx_family_badges_earned_badge_id" ON "public"."family_badges_earned" USING "btree" ("badge_id");



CREATE INDEX "idx_family_badges_earned_family_id" ON "public"."family_badges_earned" USING "btree" ("family_id");



CREATE INDEX "idx_family_boosts_family_id" ON "public"."family_boosts" USING "btree" ("family_id");



CREATE INDEX "idx_family_invites_family" ON "public"."family_invites" USING "btree" ("family_id");



CREATE INDEX "idx_family_invites_family_id" ON "public"."family_invites" USING "btree" ("family_id");



CREATE INDEX "idx_family_lounge_messages_family_id" ON "public"."family_lounge_messages" USING "btree" ("family_id");



CREATE INDEX "idx_family_lounge_messages_user_id" ON "public"."family_lounge_messages" USING "btree" ("user_id");



CREATE INDEX "idx_family_members_family_id" ON "public"."family_members" USING "btree" ("family_id");



CREATE INDEX "idx_family_members_user_id" ON "public"."family_members" USING "btree" ("user_id");



CREATE INDEX "idx_family_shop_purchases_family_id" ON "public"."family_shop_purchases" USING "btree" ("family_id");



CREATE INDEX "idx_family_shop_purchases_item_id" ON "public"."family_shop_purchases" USING "btree" ("item_id");



CREATE INDEX "idx_family_shop_purchases_purchased_by" ON "public"."family_shop_purchases" USING "btree" ("purchased_by");



CREATE INDEX "idx_family_stats_family_id" ON "public"."family_stats" USING "btree" ("family_id");



CREATE INDEX "idx_family_tasks_assigned_to" ON "public"."family_tasks" USING "btree" ("assigned_to");



CREATE INDEX "idx_family_tasks_created_by" ON "public"."family_tasks" USING "btree" ("created_by");



CREATE INDEX "idx_family_tasks_family_id" ON "public"."family_tasks_new" USING "btree" ("family_id");



CREATE INDEX "idx_family_tasks_new_family_id" ON "public"."family_tasks_new" USING "btree" ("family_id");



CREATE INDEX "idx_family_tasks_status" ON "public"."family_tasks_new" USING "btree" ("status");



CREATE INDEX "idx_family_war_stats_family_id" ON "public"."family_war_stats" USING "btree" ("family_id");



CREATE INDEX "idx_family_wars_attacking_family_id" ON "public"."family_wars" USING "btree" ("attacking_family_id");



CREATE INDEX "idx_family_wars_defending_family_id" ON "public"."family_wars" USING "btree" ("defending_family_id");



CREATE INDEX "idx_family_wars_family_a_id" ON "public"."family_wars" USING "btree" ("family_a_id");



CREATE INDEX "idx_family_wars_family_b_id" ON "public"."family_wars" USING "btree" ("family_b_id");



CREATE INDEX "idx_family_wars_status" ON "public"."family_wars" USING "btree" ("status");



CREATE INDEX "idx_family_wars_war_type" ON "public"."family_wars" USING "btree" ("war_type");



CREATE INDEX "idx_follows_follower" ON "public"."follows" USING "btree" ("follower_id");



CREATE INDEX "idx_follows_following" ON "public"."follows" USING "btree" ("following_id");



CREATE INDEX "idx_ghost_presence_logs_officer_id" ON "public"."ghost_presence_logs" USING "btree" ("officer_id");



CREATE INDEX "idx_ghost_presence_logs_stream_id" ON "public"."ghost_presence_logs" USING "btree" ("stream_id");



CREATE INDEX "idx_gift_bonus_tracker_sender_id" ON "public"."gift_bonus_tracker" USING "btree" ("sender_id");



CREATE INDEX "idx_gift_card_redemptions_card" ON "public"."gift_card_redemptions" USING "btree" ("gift_card_id");



CREATE INDEX "idx_gift_card_redemptions_gift_card_id" ON "public"."gift_card_redemptions" USING "btree" ("gift_card_id");



CREATE INDEX "idx_gift_card_redemptions_user" ON "public"."gift_card_redemptions" USING "btree" ("user_id");



CREATE INDEX "idx_gift_card_redemptions_user_id" ON "public"."gift_card_redemptions" USING "btree" ("user_id");



CREATE INDEX "idx_gift_cards_redeemed_by" ON "public"."gift_cards" USING "btree" ("redeemed_by");



CREATE INDEX "idx_gift_items_value" ON "public"."gift_items" USING "btree" ("value");



CREATE INDEX "idx_gift_leaderboard_entries_family_id" ON "public"."gift_leaderboard_entries" USING "btree" ("family_id");



CREATE INDEX "idx_gift_leaderboard_entries_leaderboard_id" ON "public"."gift_leaderboard_entries" USING "btree" ("leaderboard_id");



CREATE INDEX "idx_gift_leaderboard_entries_user_id" ON "public"."gift_leaderboard_entries" USING "btree" ("user_id");



CREATE INDEX "idx_gift_ledger_created_at" ON "public"."gifts" USING "btree" ("created_at") WHERE ("receiver_id" IS NOT NULL);



CREATE INDEX "idx_gift_ledger_sender_id" ON "public"."gifts" USING "btree" ("sender_id") WHERE ("receiver_id" IS NOT NULL);



CREATE INDEX "idx_gift_xp_stats_user_id" ON "public"."gift_xp_stats" USING "btree" ("user_id");



CREATE INDEX "idx_giftcard_fulfillments_cashout_id" ON "public"."giftcard_fulfillments" USING "btree" ("cashout_id");



CREATE INDEX "idx_giftcard_fulfillments_processed_by" ON "public"."giftcard_fulfillments" USING "btree" ("processed_by");



CREATE INDEX "idx_gifts_active" ON "public"."gifts" USING "btree" ("is_active");



CREATE INDEX "idx_gifts_battle_id" ON "public"."gifts" USING "btree" ("battle_id");



CREATE INDEX "idx_gifts_from" ON "public"."gift_transactions" USING "btree" ("from_user_id", "created_at" DESC);



CREATE INDEX "idx_gifts_owned_user_id" ON "public"."gifts_owned" USING "btree" ("user_id");



CREATE INDEX "idx_gifts_receiver_id" ON "public"."gifts" USING "btree" ("receiver_id");



CREATE INDEX "idx_gifts_sender_id" ON "public"."gifts" USING "btree" ("sender_id");



CREATE INDEX "idx_gifts_stream_id" ON "public"."gifts" USING "btree" ("stream_id");



CREATE INDEX "idx_gifts_to" ON "public"."gift_transactions" USING "btree" ("to_user_id", "created_at" DESC);



CREATE INDEX "idx_home_feature_cycles_winner_user_id" ON "public"."home_feature_cycles" USING "btree" ("winner_user_id");



CREATE INDEX "idx_home_feature_spend_cycle_id" ON "public"."home_feature_spend" USING "btree" ("cycle_id");



CREATE INDEX "idx_home_feature_spend_user_id" ON "public"."home_feature_spend" USING "btree" ("user_id");



CREATE INDEX "idx_honorary_family_members_active" ON "public"."honorary_family_members" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_honorary_family_members_admin_id" ON "public"."honorary_family_members" USING "btree" ("admin_id");



CREATE INDEX "idx_honorary_family_members_assigned_by" ON "public"."honorary_family_members" USING "btree" ("assigned_by");



CREATE INDEX "idx_honorary_family_members_user_id" ON "public"."honorary_family_members" USING "btree" ("user_id");



CREATE INDEX "idx_hr_employees_status" ON "public"."hr_employees" USING "btree" ("status");



CREATE UNIQUE INDEX "idx_hr_employees_user_id" ON "public"."hr_employees" USING "btree" ("user_id");



CREATE INDEX "idx_hr_events_action" ON "public"."hr_events" USING "btree" ("action");



CREATE INDEX "idx_hr_events_created_at" ON "public"."hr_events" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_hr_events_performed_by" ON "public"."hr_events" USING "btree" ("performed_by");



CREATE INDEX "idx_hr_events_target_staff" ON "public"."hr_events" USING "btree" ("target_staff_id");



CREATE INDEX "idx_hr_events_target_staff_id" ON "public"."hr_events" USING "btree" ("target_staff_id");



CREATE INDEX "idx_hr_events_target_user" ON "public"."hr_events" USING "btree" ("target_user_id");



CREATE INDEX "idx_hr_events_target_user_id" ON "public"."hr_events" USING "btree" ("target_user_id");



CREATE INDEX "idx_hr_notes_created_at" ON "public"."hr_notes" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_hr_notes_created_by" ON "public"."hr_notes" USING "btree" ("created_by");



CREATE INDEX "idx_hr_notes_target_staff" ON "public"."hr_notes" USING "btree" ("target_staff_id");



CREATE INDEX "idx_hr_notes_target_staff_id" ON "public"."hr_notes" USING "btree" ("target_staff_id");



CREATE INDEX "idx_hr_notes_target_user" ON "public"."hr_notes" USING "btree" ("target_user_id");



CREATE INDEX "idx_hr_notes_target_user_id" ON "public"."hr_notes" USING "btree" ("target_user_id");



CREATE INDEX "idx_identity_reward_logs_user_id" ON "public"."identity_reward_logs" USING "btree" ("user_id");



CREATE INDEX "idx_insurance_logs_blocked_at" ON "public"."insurance_logs" USING "btree" ("blocked_at");



CREATE INDEX "idx_insurance_logs_user" ON "public"."insurance_logs" USING "btree" ("user_id");



CREATE INDEX "idx_insurance_logs_user_id" ON "public"."insurance_logs" USING "btree" ("user_id");



CREATE INDEX "idx_interview_sessions_admin_id" ON "public"."interview_sessions" USING "btree" ("admin_id");



CREATE UNIQUE INDEX "idx_interview_sessions_room_name" ON "public"."interview_sessions" USING "btree" ("room_name");



CREATE INDEX "idx_interview_sessions_status" ON "public"."interview_sessions" USING "btree" ("status");



CREATE INDEX "idx_interview_sessions_user_id" ON "public"."interview_sessions" USING "btree" ("user_id");



CREATE INDEX "idx_inventory_items_category" ON "public"."inventory_items" USING "btree" ("category");



CREATE INDEX "idx_inventory_items_status" ON "public"."inventory_items" USING "btree" ("status");



CREATE INDEX "idx_inventory_items_type" ON "public"."inventory_items" USING "btree" ("type");



CREATE INDEX "idx_ip_bans_banned_by" ON "public"."ip_bans" USING "btree" ("banned_by");



CREATE INDEX "idx_ip_bans_ip_address" ON "public"."ip_bans" USING "btree" ("ip_address");



CREATE INDEX "idx_ip_bans_is_active" ON "public"."ip_bans" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_job_applications_interview_id" ON "public"."job_applications" USING "btree" ("interview_id");



CREATE INDEX "idx_job_applications_status" ON "public"."job_applications" USING "btree" ("status");



CREATE INDEX "idx_job_applications_user_id" ON "public"."job_applications" USING "btree" ("user_id");



CREATE INDEX "idx_kick_logs_kicked_by" ON "public"."kick_logs" USING "btree" ("kicked_by_user_id");



CREATE INDEX "idx_kick_logs_kicked_by_user_id" ON "public"."kick_logs" USING "btree" ("kicked_by_user_id");



CREATE INDEX "idx_kick_logs_kicked_user" ON "public"."kick_logs" USING "btree" ("kicked_user_id");



CREATE INDEX "idx_kick_logs_kicked_user_id" ON "public"."kick_logs" USING "btree" ("kicked_user_id");



CREATE INDEX "idx_kick_logs_stream_id" ON "public"."kick_logs" USING "btree" ("stream_id");



CREATE INDEX "idx_lucky_coin_events_user_id" ON "public"."lucky_coin_events" USING "btree" ("user_id");



CREATE INDEX "idx_lucky_trollmond_events_created_at" ON "public"."lucky_coin_events" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_lucky_trollmond_events_multiplier" ON "public"."lucky_coin_events" USING "btree" ("multiplier") WHERE ("multiplier" IS NOT NULL);



CREATE INDEX "idx_lucky_trollmond_events_user_id" ON "public"."lucky_coin_events" USING "btree" ("user_id");



CREATE INDEX "idx_mai_appeals_appellant_user_id" ON "public"."mai_appeals" USING "btree" ("appellant_user_id");



CREATE INDEX "idx_mai_appeals_decided_by" ON "public"."mai_appeals" USING "btree" ("decided_by");



CREATE INDEX "idx_mai_incidents_host_user_id" ON "public"."mai_incidents" USING "btree" ("host_user_id");



CREATE INDEX "idx_mai_incidents_status_created" ON "public"."mai_incidents" USING "btree" ("status", "created_at" DESC);



CREATE INDEX "idx_mai_incidents_stream" ON "public"."mai_incidents" USING "btree" ("stream_id");



CREATE INDEX "idx_mai_incidents_stream_id" ON "public"."mai_incidents" USING "btree" ("stream_id");



CREATE INDEX "idx_mai_overrides_created_by" ON "public"."mai_overrides" USING "btree" ("created_by");



CREATE INDEX "idx_mai_timeline_events_actor_user_id" ON "public"."mai_timeline_events" USING "btree" ("actor_user_id");



CREATE INDEX "idx_mai_timeline_events_created_at" ON "public"."mai_timeline_events" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_mai_timeline_events_stream" ON "public"."mai_timeline_events" USING "btree" ("stream_id", "created_at" DESC);



CREATE INDEX "idx_mai_timeline_events_stream_id" ON "public"."mai_timeline_events" USING "btree" ("stream_id");



CREATE INDEX "idx_mai_timeline_events_target" ON "public"."mai_timeline_events" USING "btree" ("target_user_id", "created_at" DESC);



CREATE INDEX "idx_mai_timeline_events_target_user_id" ON "public"."mai_timeline_events" USING "btree" ("target_user_id");



CREATE INDEX "idx_mai_user_memory_user_id" ON "public"."mai_user_memory" USING "btree" ("user_id");



CREATE INDEX "idx_message_requests_receiver_id" ON "public"."message_requests" USING "btree" ("receiver_id");



CREATE INDEX "idx_message_requests_receiver_status" ON "public"."message_requests" USING "btree" ("receiver_id", "status", "created_at" DESC);



CREATE INDEX "idx_message_requests_sender" ON "public"."message_requests" USING "btree" ("sender_id");



CREATE INDEX "idx_message_requests_sender_id" ON "public"."message_requests" USING "btree" ("sender_id");



CREATE INDEX "idx_messages_created_at" ON "public"."messages" USING "btree" ("created_at");



CREATE INDEX "idx_messages_read_at" ON "public"."messages" USING "btree" ("receiver_id", "read_at") WHERE (("read_at" IS NULL) AND ("message_type" = 'dm'::"text"));



CREATE INDEX "idx_messages_receiver_id" ON "public"."messages" USING "btree" ("receiver_id");



CREATE INDEX "idx_messages_receiver_unread" ON "public"."messages" USING "btree" ("receiver_id", "seen", "read_at") WHERE (("message_type" = 'dm'::"text") AND (("seen" = false) OR ("read_at" IS NULL)));



CREATE INDEX "idx_messages_seen" ON "public"."messages" USING "btree" ("seen") WHERE ("seen" = false);



CREATE INDEX "idx_messages_sender_id" ON "public"."messages" USING "btree" ("sender_id");



CREATE INDEX "idx_messages_sender_receiver" ON "public"."messages" USING "btree" ("sender_id", "receiver_id");



CREATE INDEX "idx_messages_stream_id" ON "public"."messages" USING "btree" ("stream_id");



CREATE INDEX "idx_messages_unread" ON "public"."messages" USING "btree" ("receiver_id", "seen") WHERE (("seen" = false) AND ("message_type" = 'dm'::"text"));



CREATE INDEX "idx_messages_user_id" ON "public"."messages" USING "btree" ("user_id");



CREATE INDEX "idx_millionaire_hall_of_fame_receiver_id" ON "public"."millionaire_hall_of_fame" USING "btree" ("receiver_id");



CREATE INDEX "idx_millionaire_hall_of_fame_sender_id" ON "public"."millionaire_hall_of_fame" USING "btree" ("sender_id");



CREATE INDEX "idx_mod_actions_actor" ON "public"."moderation_actions" USING "btree" ("actor_id");



CREATE INDEX "idx_mod_actions_target" ON "public"."moderation_actions" USING "btree" ("target_user_id");



CREATE INDEX "idx_moderation_actions_actor_id" ON "public"."moderation_actions" USING "btree" ("actor_id");



CREATE INDEX "idx_moderation_actions_report_id" ON "public"."moderation_actions" USING "btree" ("report_id");



CREATE INDEX "idx_moderation_actions_target_user_id" ON "public"."moderation_actions" USING "btree" ("target_user_id");



CREATE INDEX "idx_moderation_events_officer" ON "public"."moderation_events" USING "btree" ("officer_id", "created_at" DESC);



CREATE INDEX "idx_moderation_events_officer_id" ON "public"."moderation_events" USING "btree" ("officer_id");



CREATE INDEX "idx_moderation_events_stream" ON "public"."moderation_events" USING "btree" ("stream_id");



CREATE INDEX "idx_moderation_events_stream_id" ON "public"."moderation_events" USING "btree" ("stream_id");



CREATE INDEX "idx_moderation_events_target_user_id" ON "public"."moderation_events" USING "btree" ("target_user_id");



CREATE INDEX "idx_moderation_fee_settings_updated_by" ON "public"."moderation_fee_settings" USING "btree" ("updated_by");



CREATE INDEX "idx_moderation_reports_created_at" ON "public"."moderation_reports" USING "btree" ("created_at");



CREATE INDEX "idx_moderation_reports_reported_user" ON "public"."moderation_reports" USING "btree" ("reported_user_id");



CREATE INDEX "idx_moderation_reports_reported_user_id" ON "public"."moderation_reports" USING "btree" ("reported_user_id");



CREATE INDEX "idx_moderation_reports_reporter_id" ON "public"."moderation_reports" USING "btree" ("reporter_id");



CREATE INDEX "idx_moderation_reports_resolved_by" ON "public"."moderation_reports" USING "btree" ("resolved_by");



CREATE INDEX "idx_moderation_reports_status" ON "public"."moderation_reports" USING "btree" ("status");



CREATE INDEX "idx_moderation_reports_stream" ON "public"."moderation_reports" USING "btree" ("stream_id");



CREATE INDEX "idx_moderation_reports_stream_id" ON "public"."moderation_reports" USING "btree" ("stream_id");



CREATE INDEX "idx_notifications_read" ON "public"."notifications" USING "btree" ("read");



CREATE INDEX "idx_notifications_user" ON "public"."notifications" USING "btree" ("user_id");



CREATE INDEX "idx_notifications_user_id" ON "public"."notifications" USING "btree" ("user_id");



CREATE INDEX "idx_observer_ratings_event" ON "public"."observer_ratings" USING "btree" ("event_id");



CREATE INDEX "idx_observer_ratings_event_id" ON "public"."observer_ratings" USING "btree" ("event_id");



CREATE INDEX "idx_officer_actions_created" ON "public"."officer_actions" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_officer_actions_officer" ON "public"."officer_actions" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_actions_officer_id" ON "public"."officer_actions" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_actions_target" ON "public"."officer_actions" USING "btree" ("target_user_id");



CREATE INDEX "idx_officer_actions_target_user_id" ON "public"."officer_actions" USING "btree" ("target_user_id");



CREATE INDEX "idx_officer_active" ON "public"."officer_live_assignments" USING "btree" ("status", "officer_id", "stream_id");



CREATE INDEX "idx_officer_activity_time" ON "public"."officer_activity" USING "btree" ("time" DESC);



CREATE INDEX "idx_officer_badges_user_id" ON "public"."officer_badges" USING "btree" ("user_id");



CREATE INDEX "idx_officer_chat_messages_user_id" ON "public"."officer_chat_messages" USING "btree" ("user_id");



CREATE INDEX "idx_officer_earnings_action_id" ON "public"."officer_earnings" USING "btree" ("action_id");



CREATE INDEX "idx_officer_earnings_officer" ON "public"."officer_earnings" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_earnings_officer_id" ON "public"."officer_earnings" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_last_activity" ON "public"."officer_live_assignments" USING "btree" ("last_activity");



CREATE INDEX "idx_officer_live_assignments_officer_id" ON "public"."officer_live_assignments" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_live_assignments_officer_stream" ON "public"."officer_live_assignments" USING "btree" ("officer_id", "stream_id");



CREATE INDEX "idx_officer_live_assignments_status" ON "public"."officer_live_assignments" USING "btree" ("status");



CREATE INDEX "idx_officer_live_assignments_stream_id" ON "public"."officer_live_assignments" USING "btree" ("stream_id");



CREATE INDEX "idx_officer_mission_logs_officer_id" ON "public"."officer_mission_logs" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_orientation_results_completed_at" ON "public"."officer_orientation_results" USING "btree" ("completed_at" DESC);



CREATE INDEX "idx_officer_orientation_results_has_passed" ON "public"."officer_orientation_results" USING "btree" ("has_passed");



CREATE INDEX "idx_officer_orientation_results_user_id" ON "public"."officer_orientation_results" USING "btree" ("user_id");



CREATE INDEX "idx_officer_orientations_status" ON "public"."officer_orientations" USING "btree" ("status");



CREATE INDEX "idx_officer_orientations_user" ON "public"."officer_orientations" USING "btree" ("user_id");



CREATE INDEX "idx_officer_orientations_user_id" ON "public"."officer_orientations" USING "btree" ("user_id");



CREATE INDEX "idx_officer_payouts_admin_id" ON "public"."officer_payouts" USING "btree" ("admin_id");



CREATE INDEX "idx_officer_payouts_officer" ON "public"."officer_payouts" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_payouts_officer_id" ON "public"."officer_payouts" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_payouts_shift" ON "public"."officer_payouts" USING "btree" ("shift_log_id");



CREATE INDEX "idx_officer_payouts_shift_log_id" ON "public"."officer_payouts" USING "btree" ("shift_log_id");



CREATE INDEX "idx_officer_payouts_status" ON "public"."officer_payouts" USING "btree" ("status");



CREATE INDEX "idx_officer_performance_officer_id" ON "public"."officer_performance" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_performance_rating" ON "public"."officer_performance" USING "btree" ("performance_rating");



CREATE INDEX "idx_officer_quiz_attempts_orientation" ON "public"."officer_quiz_attempts" USING "btree" ("orientation_id");



CREATE INDEX "idx_officer_quiz_attempts_orientation_id" ON "public"."officer_quiz_attempts" USING "btree" ("orientation_id");



CREATE INDEX "idx_officer_quiz_attempts_user" ON "public"."officer_quiz_attempts" USING "btree" ("user_id");



CREATE INDEX "idx_officer_quiz_attempts_user_id" ON "public"."officer_quiz_attempts" USING "btree" ("user_id");



CREATE INDEX "idx_officer_quiz_questions_active" ON "public"."officer_quiz_questions" USING "btree" ("is_active", "order_index");



CREATE INDEX "idx_officer_quiz_results_officer" ON "public"."officer_quiz_results" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_quiz_results_officer_id" ON "public"."officer_quiz_results" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_quiz_results_question" ON "public"."officer_quiz_results" USING "btree" ("question_id");



CREATE INDEX "idx_officer_quiz_results_question_id" ON "public"."officer_quiz_results" USING "btree" ("question_id");



CREATE INDEX "idx_officer_shift_logs_active" ON "public"."officer_shift_logs" USING "btree" ("officer_id", "clock_out") WHERE ("clock_out" IS NULL);



CREATE INDEX "idx_officer_shift_logs_created" ON "public"."officer_shift_logs" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_officer_shift_logs_officer" ON "public"."officer_shift_logs" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_shift_logs_officer_id" ON "public"."officer_shift_logs" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_shift_logs_shift_slot_id" ON "public"."officer_shift_logs" USING "btree" ("shift_slot_id");



CREATE INDEX "idx_officer_shift_slots_date" ON "public"."officer_shift_slots" USING "btree" ("shift_date");



CREATE INDEX "idx_officer_shift_slots_officer" ON "public"."officer_shift_slots" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_shift_slots_officer_id" ON "public"."officer_shift_slots" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_shift_slots_status" ON "public"."officer_shift_slots" USING "btree" ("status");



CREATE INDEX "idx_officer_stream_logs_joined" ON "public"."officer_stream_logs" USING "btree" ("joined_at" DESC);



CREATE INDEX "idx_officer_stream_logs_officer" ON "public"."officer_stream_logs" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_stream_logs_officer_id" ON "public"."officer_stream_logs" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_stream_logs_stream" ON "public"."officer_stream_logs" USING "btree" ("stream_id");



CREATE INDEX "idx_officer_stream_logs_stream_id" ON "public"."officer_stream_logs" USING "btree" ("stream_id");



CREATE INDEX "idx_officer_training_sessions_officer_id" ON "public"."officer_training_sessions" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_training_sessions_scenario_id" ON "public"."officer_training_sessions" USING "btree" ("scenario_id");



CREATE INDEX "idx_officer_weekly_reports_lead_officer" ON "public"."officer_weekly_reports" USING "btree" ("lead_officer_id");



CREATE INDEX "idx_officer_weekly_reports_lead_officer_id" ON "public"."officer_weekly_reports" USING "btree" ("lead_officer_id");



CREATE INDEX "idx_officer_weekly_reports_week" ON "public"."officer_weekly_reports" USING "btree" ("week_start", "week_end");



CREATE INDEX "idx_officer_work_sessions_clock_in" ON "public"."officer_work_sessions" USING "btree" ("clock_in" DESC);



CREATE INDEX "idx_officer_work_sessions_officer" ON "public"."officer_work_sessions" USING "btree" ("officer_id", "clock_in");



CREATE INDEX "idx_officer_work_sessions_officer_id" ON "public"."officer_work_sessions" USING "btree" ("officer_id");



CREATE INDEX "idx_officer_work_sessions_payout_status" ON "public"."officer_work_sessions" USING "btree" ("payout_status");



CREATE INDEX "idx_officer_work_sessions_stream_id" ON "public"."officer_work_sessions" USING "btree" ("stream_id");



CREATE INDEX "idx_onboarding_events_event_type" ON "public"."onboarding_events" USING "btree" ("event_type");



CREATE INDEX "idx_onboarding_events_user_id" ON "public"."onboarding_events" USING "btree" ("user_id");



CREATE INDEX "idx_onboarding_progress_current_step" ON "public"."onboarding_progress" USING "btree" ("current_step");



CREATE INDEX "idx_onboarding_progress_user_id" ON "public"."onboarding_progress" USING "btree" ("user_id");



CREATE UNIQUE INDEX "idx_orientation_results_user" ON "public"."officer_orientation_results" USING "btree" ("user_id");



CREATE INDEX "idx_owc_transactions_created" ON "public"."owc_transactions" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_owc_transactions_session_id" ON "public"."owc_transactions" USING "btree" ("session_id");



CREATE INDEX "idx_owc_transactions_type" ON "public"."owc_transactions" USING "btree" ("transaction_type");



CREATE INDEX "idx_owc_transactions_user" ON "public"."owc_transactions" USING "btree" ("user_id");



CREATE INDEX "idx_owc_transactions_user_id" ON "public"."owc_transactions" USING "btree" ("user_id");



CREATE INDEX "idx_payment_fees_created_at" ON "public"."payment_fees" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_payment_fees_provider_external" ON "public"."payment_fees" USING "btree" ("provider", "external_id");



CREATE INDEX "idx_payment_fees_revenue_id" ON "public"."payment_fees" USING "btree" ("revenue_id");



CREATE INDEX "idx_payment_holds_active" ON "public"."payment_holds" USING "btree" ("is_active");



CREATE INDEX "idx_payment_holds_placed_by" ON "public"."payment_holds" USING "btree" ("placed_by");



CREATE INDEX "idx_payment_holds_user" ON "public"."payment_holds" USING "btree" ("user_id");



CREATE INDEX "idx_payment_holds_user_id" ON "public"."payment_holds" USING "btree" ("user_id");



CREATE INDEX "idx_payment_logs_created_at" ON "public"."payment_logs" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_payment_logs_status" ON "public"."payment_logs" USING "btree" ("status");



CREATE INDEX "idx_payment_logs_user_id" ON "public"."payment_logs" USING "btree" ("user_id");



CREATE INDEX "idx_payment_methods_user_id" ON "public"."payment_methods" USING "btree" ("user_id");



CREATE INDEX "idx_payment_transactions_user_id" ON "public"."payment_transactions" USING "btree" ("user_id");



CREATE INDEX "idx_payout_audit_log_created_at" ON "public"."payout_audit_log" USING "btree" ("created_at");



CREATE INDEX "idx_payout_audit_log_payout_request_id" ON "public"."payout_audit_log" USING "btree" ("payout_request_id");



CREATE INDEX "idx_payout_audit_log_processed_by" ON "public"."payout_audit_log" USING "btree" ("processed_by");



CREATE INDEX "idx_payout_requests_admin_id" ON "public"."payout_requests" USING "btree" ("admin_id");



CREATE INDEX "idx_payout_requests_created_at" ON "public"."payout_requests" USING "btree" ("created_at");



CREATE INDEX "idx_payout_requests_processed_by" ON "public"."payout_requests" USING "btree" ("processed_by");



CREATE INDEX "idx_payout_requests_status" ON "public"."payout_requests" USING "btree" ("status");



CREATE INDEX "idx_payout_requests_user" ON "public"."payout_requests" USING "btree" ("user_id");



CREATE INDEX "idx_payout_requests_user_id" ON "public"."payout_requests" USING "btree" ("user_id");



CREATE INDEX "idx_payout_requests_user_id_status" ON "public"."payout_requests" USING "btree" ("user_id", "status");



CREATE INDEX "idx_payout_settings_enabled" ON "public"."payout_settings" USING "btree" ("payouts_enabled");



CREATE INDEX "idx_payout_settings_user_id" ON "public"."payout_settings" USING "btree" ("user_id");



CREATE INDEX "idx_payouts_status" ON "public"."payouts" USING "btree" ("status");



CREATE INDEX "idx_payouts_user_id" ON "public"."payouts" USING "btree" ("user_id");



CREATE INDEX "idx_post_gifts_post_id" ON "public"."post_gifts" USING "btree" ("post_id");



CREATE INDEX "idx_post_gifts_sender_id" ON "public"."post_gifts" USING "btree" ("sender_id");



CREATE INDEX "idx_posts_user_id" ON "public"."posts" USING "btree" ("user_id");



CREATE INDEX "idx_profiles_id" ON "public"."profiles" USING "btree" ("id");



CREATE INDEX "idx_profiles_recruiter_id" ON "public"."profiles" USING "btree" ("recruiter_id");



CREATE INDEX "idx_promo_code_uses_code" ON "public"."promo_code_uses" USING "btree" ("promo_code_id");



CREATE INDEX "idx_promo_code_uses_promo_code_id" ON "public"."promo_code_uses" USING "btree" ("promo_code_id");



CREATE INDEX "idx_promo_code_uses_user" ON "public"."promo_code_uses" USING "btree" ("user_id");



CREATE INDEX "idx_promo_code_uses_user_id" ON "public"."promo_code_uses" USING "btree" ("user_id");



CREATE INDEX "idx_promo_codes_active" ON "public"."promo_codes" USING "btree" ("is_active", "valid_until");



CREATE INDEX "idx_promo_codes_code" ON "public"."promo_codes" USING "btree" ("code");



CREATE INDEX "idx_properties_user" ON "public"."trollstown_properties" USING "btree" ("user_id");



CREATE INDEX "idx_property_upgrades_property" ON "public"."trollstown_property_upgrades" USING "btree" ("property_id");



CREATE INDEX "idx_property_upgrades_user" ON "public"."trollstown_property_upgrades" USING "btree" ("user_id");



CREATE INDEX "idx_punishment_transactions_created" ON "public"."punishment_transactions" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_punishment_transactions_user" ON "public"."punishment_transactions" USING "btree" ("user_id");



CREATE INDEX "idx_punishment_transactions_user_id" ON "public"."punishment_transactions" USING "btree" ("user_id");



CREATE INDEX "idx_punishments_status" ON "public"."punishments" USING "btree" ("status");



CREATE INDEX "idx_punishments_type" ON "public"."punishments" USING "btree" ("type");



CREATE INDEX "idx_punishments_user_id" ON "public"."punishments" USING "btree" ("user_id");



CREATE INDEX "idx_receipts_message" ON "public"."message_receipts" USING "btree" ("message_id");



CREATE INDEX "idx_receipts_read" ON "public"."message_receipts" USING "btree" ("user_id", "read_at");



CREATE INDEX "idx_receipts_user_message" ON "public"."message_receipts" USING "btree" ("user_id", "message_id");



CREATE INDEX "idx_referral_bonus_month" ON "public"."referral_monthly_bonus" USING "btree" ("month");



CREATE INDEX "idx_referral_bonus_recruiter_id" ON "public"."referral_monthly_bonus" USING "btree" ("recruiter_id");



CREATE INDEX "idx_referral_bonus_referred_user_id" ON "public"."referral_monthly_bonus" USING "btree" ("referred_user_id");



CREATE INDEX "idx_referral_claims_referred_user_id" ON "public"."referral_claims" USING "btree" ("referred_user_id");



CREATE INDEX "idx_referral_claims_user_id" ON "public"."referral_claims" USING "btree" ("user_id");



CREATE INDEX "idx_referral_monthly_bonus_recruiter_id" ON "public"."referral_monthly_bonus" USING "btree" ("recruiter_id");



CREATE INDEX "idx_referral_monthly_bonus_referred_user_id" ON "public"."referral_monthly_bonus" USING "btree" ("referred_user_id");



CREATE INDEX "idx_referrals_deadline" ON "public"."referrals" USING "btree" ("deadline");



CREATE INDEX "idx_referrals_recruiter_id" ON "public"."referrals" USING "btree" ("recruiter_id");



CREATE INDEX "idx_referrals_referred" ON "public"."referrals" USING "btree" ("referred_id");



CREATE INDEX "idx_referrals_referred_user_id" ON "public"."referrals" USING "btree" ("referred_user_id");



CREATE INDEX "idx_referrals_referrer" ON "public"."referrals" USING "btree" ("referrer_id");



CREATE INDEX "idx_referrals_reward_status" ON "public"."referrals" USING "btree" ("reward_status");



CREATE INDEX "idx_referrals_status" ON "public"."referrals" USING "btree" ("status");



CREATE INDEX "idx_referrals_user_id" ON "public"."referrals" USING "btree" ("user_id");



CREATE INDEX "idx_report_cases_status" ON "public"."report_cases" USING "btree" ("status", "severity");



CREATE INDEX "idx_reputation_events_created_at" ON "public"."reputation_events" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_reputation_events_target_id" ON "public"."reputation_events" USING "btree" ("target_id");



CREATE INDEX "idx_reputation_events_triggered_by" ON "public"."reputation_events" USING "btree" ("triggered_by");



CREATE INDEX "idx_reputation_events_type" ON "public"."reputation_events" USING "btree" ("reputation_type");



CREATE INDEX "idx_risk_events_created" ON "public"."risk_events" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_risk_events_created_at" ON "public"."risk_events" USING "btree" ("created_at");



CREATE INDEX "idx_risk_events_severity" ON "public"."risk_events" USING "btree" ("severity");



CREATE INDEX "idx_risk_events_user" ON "public"."risk_events" USING "btree" ("user_id");



CREATE INDEX "idx_risk_events_user_id" ON "public"."risk_events" USING "btree" ("user_id");



CREATE INDEX "idx_risk_profile_frozen" ON "public"."user_risk_profile" USING "btree" ("is_frozen");



CREATE INDEX "idx_risk_profile_score" ON "public"."user_risk_profile" USING "btree" ("risk_score" DESC);



CREATE INDEX "idx_royal_family_history_admin_id" ON "public"."royal_family_history" USING "btree" ("admin_id");



CREATE INDEX "idx_royal_family_history_user" ON "public"."royal_family_history" USING "btree" ("user_id");



CREATE INDEX "idx_royal_family_history_user_id" ON "public"."royal_family_history" USING "btree" ("user_id");



CREATE INDEX "idx_royal_family_perks_title" ON "public"."royal_family_perks" USING "btree" ("title_id");



CREATE INDEX "idx_royal_family_perks_title_id" ON "public"."royal_family_perks" USING "btree" ("title_id");



CREATE INDEX "idx_royal_family_titles_active" ON "public"."royal_family_titles" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_royal_family_titles_admin_id" ON "public"."royal_family_titles" USING "btree" ("admin_id");



CREATE INDEX "idx_royal_family_titles_user_admin" ON "public"."royal_family_titles" USING "btree" ("user_id", "admin_id");



CREATE INDEX "idx_royal_family_titles_user_id" ON "public"."royal_family_titles" USING "btree" ("user_id");



CREATE INDEX "idx_scheduled_announcements_created_by" ON "public"."scheduled_announcements" USING "btree" ("created_by");



CREATE INDEX "idx_secretary_assignments_assigned_by" ON "public"."secretary_assignments" USING "btree" ("assigned_by");



CREATE INDEX "idx_secretary_assignments_secretary_id" ON "public"."secretary_assignments" USING "btree" ("secretary_id");



CREATE INDEX "idx_security_events_created_at" ON "public"."security_events" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_security_events_user_id" ON "public"."security_events" USING "btree" ("user_id");



CREATE INDEX "idx_seller_reliability_risk" ON "public"."seller_reliability" USING "btree" ("is_high_risk");



CREATE INDEX "idx_seller_reliability_seller_id" ON "public"."seller_reliability" USING "btree" ("seller_id");



CREATE INDEX "idx_seller_reliability_tier" ON "public"."seller_reliability" USING "btree" ("reliability_tier");



CREATE INDEX "idx_shadow_bans_active" ON "public"."shadow_bans" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_shadow_bans_officer_id" ON "public"."shadow_bans" USING "btree" ("officer_id");



CREATE INDEX "idx_shadow_bans_stream" ON "public"."shadow_bans" USING "btree" ("stream_id");



CREATE INDEX "idx_shadow_bans_stream_id" ON "public"."shadow_bans" USING "btree" ("stream_id");



CREATE INDEX "idx_shadow_bans_target" ON "public"."shadow_bans" USING "btree" ("target_user_id", "is_active");



CREATE INDEX "idx_shadow_bans_target_user_id" ON "public"."shadow_bans" USING "btree" ("target_user_id");



CREATE INDEX "idx_shifts_date" ON "public"."shifts" USING "btree" ("date");



CREATE INDEX "idx_shifts_user_id" ON "public"."shifts" USING "btree" ("user_id");



CREATE INDEX "idx_shop_transactions_item_id" ON "public"."shop_transactions" USING "btree" ("item_id");



CREATE INDEX "idx_shop_transactions_shop_id" ON "public"."shop_transactions" USING "btree" ("shop_id");



CREATE INDEX "idx_shop_transactions_user_id" ON "public"."shop_transactions" USING "btree" ("user_id");



CREATE INDEX "idx_shops_owner_id" ON "public"."shops" USING "btree" ("owner_id");



CREATE INDEX "idx_square_events_created" ON "public"."square_events" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_square_events_event_id" ON "public"."square_events" USING "btree" ("event_id");



CREATE INDEX "idx_square_events_type" ON "public"."square_events" USING "btree" ("type");



CREATE INDEX "idx_staff_applications_created_at" ON "public"."staff_applications" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_staff_applications_reviewer_id" ON "public"."staff_applications" USING "btree" ("reviewer_id");



CREATE INDEX "idx_staff_applications_role" ON "public"."staff_applications" USING "btree" ("applied_role");



CREATE INDEX "idx_staff_applications_status" ON "public"."staff_applications" USING "btree" ("status");



CREATE INDEX "idx_staff_applications_user_id" ON "public"."staff_applications" USING "btree" ("user_id");



CREATE INDEX "idx_staff_profiles_email" ON "public"."staff_profiles" USING "btree" ("email");



CREATE INDEX "idx_staff_profiles_role" ON "public"."staff_profiles" USING "btree" ("role");



CREATE INDEX "idx_staff_profiles_status" ON "public"."staff_profiles" USING "btree" ("status");



CREATE INDEX "idx_staff_profiles_user_id" ON "public"."staff_profiles" USING "btree" ("user_id");



CREATE INDEX "idx_store_items_active" ON "public"."store_items" USING "btree" ("is_active");



CREATE INDEX "idx_store_items_sort" ON "public"."store_items" USING "btree" ("sort_order");



CREATE INDEX "idx_store_items_type" ON "public"."store_items" USING "btree" ("type");



CREATE INDEX "idx_stores_owner_id" ON "public"."stores" USING "btree" ("owner_id");



CREATE INDEX "idx_stores_status" ON "public"."stores" USING "btree" ("status");



CREATE UNIQUE INDEX "idx_stores_unique_owner" ON "public"."stores" USING "btree" ("owner_id") WHERE ("status" = 'active'::"text");



CREATE INDEX "idx_stream_discovery_prefs_user" ON "public"."stream_discovery_prefs" USING "btree" ("user_id");



CREATE INDEX "idx_stream_discovery_prefs_user_id" ON "public"."stream_discovery_prefs" USING "btree" ("user_id");



CREATE INDEX "idx_stream_entrances_stream_id" ON "public"."stream_entrances" USING "btree" ("stream_id");



CREATE INDEX "idx_stream_entrances_user_id" ON "public"."stream_entrances" USING "btree" ("user_id");



CREATE INDEX "idx_stream_entries_stream_id" ON "public"."stream_entries" USING "btree" ("stream_id");



CREATE INDEX "idx_stream_entries_user_id" ON "public"."stream_entries" USING "btree" ("user_id");



CREATE INDEX "idx_stream_events_stream_id" ON "public"."stream_events" USING "btree" ("stream_id");



CREATE INDEX "idx_stream_gifts_sender_created" ON "public"."stream_gifts" USING "btree" ("sender_id", "created_at" DESC);



CREATE INDEX "idx_stream_gifts_stream_created" ON "public"."stream_gifts" USING "btree" ("stream_id", "created_at" DESC);



CREATE INDEX "idx_stream_gifts_stream_id" ON "public"."stream_gifts" USING "btree" ("stream_id");



CREATE INDEX "idx_stream_join_requests_stream_created" ON "public"."stream_join_requests" USING "btree" ("stream_id", "created_at" DESC);



CREATE INDEX "idx_stream_join_requests_stream_id" ON "public"."stream_join_requests" USING "btree" ("stream_id");



CREATE INDEX "idx_stream_join_requests_user_created" ON "public"."stream_join_requests" USING "btree" ("user_id", "created_at" DESC);



CREATE INDEX "idx_stream_join_requests_user_id" ON "public"."stream_join_requests" USING "btree" ("user_id");



CREATE INDEX "idx_stream_likes_stream_created" ON "public"."stream_likes" USING "btree" ("stream_id", "created_at" DESC);



CREATE INDEX "idx_stream_likes_stream_id" ON "public"."stream_likes" USING "btree" ("stream_id");



CREATE INDEX "idx_stream_likes_user_created" ON "public"."stream_likes" USING "btree" ("user_id", "created_at" DESC);



CREATE INDEX "idx_stream_likes_user_id" ON "public"."stream_likes" USING "btree" ("user_id");



CREATE INDEX "idx_stream_messages_stream_created" ON "public"."stream_messages" USING "btree" ("stream_id", "created_at" DESC);



CREATE INDEX "idx_stream_messages_user_created" ON "public"."stream_messages" USING "btree" ("user_id", "created_at" DESC);



CREATE INDEX "idx_stream_messages_user_id" ON "public"."stream_messages" USING "btree" ("user_id");



CREATE INDEX "idx_stream_momentum_stream_id" ON "public"."stream_momentum" USING "btree" ("stream_id");



CREATE INDEX "idx_stream_mute_counts_last_muted_by" ON "public"."stream_mute_counts" USING "btree" ("last_muted_by");



CREATE INDEX "idx_stream_mute_counts_stream_id" ON "public"."stream_mute_counts" USING "btree" ("stream_id");



CREATE INDEX "idx_stream_mute_counts_target_user_id" ON "public"."stream_mute_counts" USING "btree" ("target_user_id");



CREATE INDEX "idx_stream_participants_stream_id" ON "public"."stream_participants" USING "btree" ("stream_id");



CREATE INDEX "idx_stream_presets_user_id" ON "public"."stream_presets" USING "btree" ("user_id");



CREATE INDEX "idx_stream_ranking_score" ON "public"."stream_ranking" USING "btree" ("final_score" DESC);



CREATE INDEX "idx_stream_ranking_stream_id" ON "public"."stream_ranking" USING "btree" ("stream_id");



CREATE INDEX "idx_stream_ranking_updated" ON "public"."stream_ranking" USING "btree" ("last_updated" DESC);



CREATE INDEX "idx_stream_reactions_stream_created" ON "public"."stream_reactions" USING "btree" ("stream_id", "created_at" DESC);



CREATE INDEX "idx_stream_reactions_stream_id" ON "public"."stream_reactions" USING "btree" ("stream_id");



CREATE INDEX "idx_stream_reactions_user_created" ON "public"."stream_reactions" USING "btree" ("user_id", "created_at" DESC);



CREATE INDEX "idx_stream_reactions_user_id" ON "public"."stream_reactions" USING "btree" ("user_id");



CREATE INDEX "idx_stream_reports_reporter_id" ON "public"."stream_reports" USING "btree" ("reporter_id");



CREATE INDEX "idx_stream_reports_stream_id" ON "public"."stream_reports" USING "btree" ("stream_id");



CREATE INDEX "idx_stream_sessions_status" ON "public"."stream_sessions" USING "btree" ("status");



CREATE INDEX "idx_stream_sessions_streamer" ON "public"."stream_sessions" USING "btree" ("streamer_id", "started_at" DESC);



CREATE INDEX "idx_stream_snack_purchases_stream_created" ON "public"."stream_snack_purchases" USING "btree" ("stream_id", "created_at" DESC);



CREATE INDEX "idx_stream_snack_purchases_stream_id" ON "public"."stream_snack_purchases" USING "btree" ("stream_id");



CREATE INDEX "idx_stream_snack_purchases_user_id" ON "public"."stream_snack_purchases" USING "btree" ("user_id");



CREATE INDEX "idx_stream_snack_purchases_user_stream_created" ON "public"."stream_snack_purchases" USING "btree" ("user_id", "stream_id", "created_at" DESC);



CREATE INDEX "idx_stream_viewers_stream_id" ON "public"."stream_viewers" USING "btree" ("stream_id");



CREATE INDEX "idx_stream_viewers_user_id" ON "public"."stream_viewers" USING "btree" ("user_id");



CREATE INDEX "idx_stream_vods_stream_id" ON "public"."stream_vods" USING "btree" ("stream_id");



CREATE INDEX "idx_streams_broadcaster_id" ON "public"."streams" USING "btree" ("broadcaster_id");



CREATE INDEX "idx_streams_host_user_id" ON "public"."streams" USING "btree" ("host_user_id");



CREATE INDEX "idx_streams_is_live" ON "public"."streams" USING "btree" ("is_live");



CREATE INDEX "idx_streams_owner_id" ON "public"."streams" USING "btree" ("owner_id");



CREATE INDEX "idx_streams_participants_active" ON "public"."streams_participants" USING "btree" ("stream_id", "is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_streams_participants_chat_mute" ON "public"."streams_participants" USING "btree" ("stream_id", "user_id", "chat_mute_until") WHERE ("chat_mute_until" IS NOT NULL);



CREATE INDEX "idx_streams_participants_is_moderator" ON "public"."streams_participants" USING "btree" ("stream_id", "is_moderator") WHERE ("is_moderator" = true);



CREATE INDEX "idx_streams_participants_stream_id" ON "public"."streams_participants" USING "btree" ("stream_id");



CREATE UNIQUE INDEX "idx_streams_participants_unique_active" ON "public"."streams_participants" USING "btree" ("stream_id", "user_id") WHERE ("is_active" = true);



CREATE INDEX "idx_streams_participants_user_id" ON "public"."streams_participants" USING "btree" ("user_id");



CREATE INDEX "idx_streams_popularity" ON "public"."streams" USING "btree" ("popularity" DESC);



CREATE INDEX "idx_streams_recording_url" ON "public"."streams" USING "btree" ("recording_url");



CREATE INDEX "idx_streams_save_requested" ON "public"."streams" USING "btree" ("save_requested");



CREATE INDEX "idx_streams_start_time" ON "public"."streams" USING "btree" ("start_time");



CREATE INDEX "idx_streams_started_at" ON "public"."streams" USING "btree" ("started_at" DESC);



CREATE INDEX "idx_streams_status" ON "public"."streams" USING "btree" ("status");



CREATE INDEX "idx_streams_streamer_id" ON "public"."streams" USING "btree" ("streamer_id");



CREATE INDEX "idx_support_tickets_created_at" ON "public"."support_tickets" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_support_tickets_status" ON "public"."support_tickets" USING "btree" ("status");



CREATE INDEX "idx_support_tickets_user_id" ON "public"."support_tickets" USING "btree" ("user_id");



CREATE INDEX "idx_system_alerts_user_id" ON "public"."system_alerts" USING "btree" ("user_id");



CREATE INDEX "idx_system_errors_user_id" ON "public"."system_errors" USING "btree" ("user_id");



CREATE INDEX "idx_task_completions_family_id" ON "public"."task_completions" USING "btree" ("family_id");



CREATE INDEX "idx_task_completions_task" ON "public"."task_completions" USING "btree" ("task_id");



CREATE INDEX "idx_task_completions_task_id" ON "public"."task_completions" USING "btree" ("task_id");



CREATE INDEX "idx_task_completions_user_id" ON "public"."task_completions" USING "btree" ("user_id");



CREATE INDEX "idx_task_history_task_id" ON "public"."task_history" USING "btree" ("task_id");



CREATE INDEX "idx_task_history_user_id" ON "public"."task_history" USING "btree" ("user_id");



CREATE INDEX "idx_tax_report_status_user_id" ON "public"."tax_report_status" USING "btree" ("user_id");



CREATE INDEX "idx_ticket_messages_sender_id" ON "public"."ticket_messages" USING "btree" ("sender_id");



CREATE INDEX "idx_ticket_messages_ticket_id" ON "public"."ticket_messages" USING "btree" ("ticket_id");



CREATE INDEX "idx_training_sessions_officer" ON "public"."officer_training_sessions" USING "btree" ("officer_id");



CREATE INDEX "idx_training_sessions_scenario" ON "public"."officer_training_sessions" USING "btree" ("scenario_id");



CREATE INDEX "idx_transactions_user_id" ON "public"."transactions" USING "btree" ("user_id");



CREATE INDEX "idx_troll_battle_gifts_battle" ON "public"."troll_battle_gifts" USING "btree" ("battle_id");



CREATE INDEX "idx_troll_battle_gifts_battle_id" ON "public"."troll_battle_gifts" USING "btree" ("battle_id");



CREATE INDEX "idx_troll_battle_gifts_receiver_role" ON "public"."troll_battle_gifts" USING "btree" ("receiver_role");



CREATE INDEX "idx_troll_battle_gifts_sender_id" ON "public"."troll_battle_gifts" USING "btree" ("sender_id");



CREATE INDEX "idx_troll_battles_broadcaster1_id" ON "public"."troll_battles" USING "btree" ("broadcaster1_id");



CREATE INDEX "idx_troll_battles_broadcaster2_id" ON "public"."troll_battles" USING "btree" ("broadcaster2_id");



CREATE INDEX "idx_troll_battles_challenger" ON "public"."troll_battles" USING "btree" ("challenger_id");



CREATE INDEX "idx_troll_battles_challenger_id" ON "public"."troll_battles" USING "btree" ("challenger_id");



CREATE INDEX "idx_troll_battles_created_at" ON "public"."troll_battles" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_troll_battles_host" ON "public"."troll_battles" USING "btree" ("host_id");



CREATE INDEX "idx_troll_battles_host_id" ON "public"."troll_battles" USING "btree" ("host_id");



CREATE INDEX "idx_troll_battles_status" ON "public"."troll_battles" USING "btree" ("status");



CREATE INDEX "idx_troll_battles_winner_id" ON "public"."troll_battles" USING "btree" ("winner_id");



CREATE INDEX "idx_troll_dna_events_user_id" ON "public"."troll_dna_events" USING "btree" ("user_id");



CREATE INDEX "idx_troll_dna_profiles_user_id" ON "public"."troll_dna_profiles" USING "btree" ("user_id");



CREATE INDEX "idx_troll_drops_created_at" ON "public"."troll_drops" USING "btree" ("created_at");



CREATE INDEX "idx_troll_drops_expires_at" ON "public"."troll_drops" USING "btree" ("expires_at");



CREATE INDEX "idx_troll_drops_log_broadcaster" ON "public"."troll_drops_log" USING "btree" ("broadcaster_id", "created_at" DESC);



CREATE INDEX "idx_troll_drops_log_broadcaster_id" ON "public"."troll_drops_log" USING "btree" ("broadcaster_id");



CREATE INDEX "idx_troll_drops_log_cycle" ON "public"."troll_drops_log" USING "btree" ("cycle_start");



CREATE INDEX "idx_troll_drops_log_stream_id" ON "public"."troll_drops_log" USING "btree" ("stream_id");



CREATE INDEX "idx_troll_drops_stream_id" ON "public"."troll_drops" USING "btree" ("stream_id");



CREATE INDEX "idx_troll_drops_user_id" ON "public"."troll_drops" USING "btree" ("user_id");



CREATE INDEX "idx_troll_event_claims_event" ON "public"."troll_event_claims" USING "btree" ("event_id");



CREATE INDEX "idx_troll_event_claims_event_id" ON "public"."troll_event_claims" USING "btree" ("event_id");



CREATE INDEX "idx_troll_event_claims_user" ON "public"."troll_event_claims" USING "btree" ("user_id");



CREATE INDEX "idx_troll_event_claims_user_id" ON "public"."troll_event_claims" USING "btree" ("user_id");



CREATE INDEX "idx_troll_events_active" ON "public"."troll_events" USING "btree" ("active", "expires_at");



CREATE INDEX "idx_troll_events_created" ON "public"."troll_events" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_troll_families_created_by" ON "public"."troll_families" USING "btree" ("created_by");



CREATE INDEX "idx_troll_family_members_family_id" ON "public"."troll_family_members" USING "btree" ("family_id");



CREATE INDEX "idx_troll_family_members_user_id" ON "public"."troll_family_members" USING "btree" ("user_id");



CREATE INDEX "idx_troll_family_messages_family_id" ON "public"."troll_family_messages" USING "btree" ("family_id");



CREATE INDEX "idx_troll_family_messages_sender_id" ON "public"."troll_family_messages" USING "btree" ("sender_id");



CREATE INDEX "idx_troll_family_wars_challenger_family_id" ON "public"."troll_family_wars" USING "btree" ("challenger_family_id");



CREATE INDEX "idx_troll_family_wars_defender_family_id" ON "public"."troll_family_wars" USING "btree" ("defender_family_id");



CREATE INDEX "idx_troll_officer_applications_user_id" ON "public"."troll_officer_applications" USING "btree" ("user_id");



CREATE INDEX "idx_troll_officers_user_id" ON "public"."troll_officers" USING "btree" ("user_id");



CREATE INDEX "idx_troll_post_comments_created_at" ON "public"."troll_post_comments" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_troll_post_comments_post_id" ON "public"."troll_post_comments" USING "btree" ("post_id");



CREATE INDEX "idx_troll_post_comments_user_id" ON "public"."troll_post_comments" USING "btree" ("user_id");



CREATE INDEX "idx_troll_post_gifts_post_id" ON "public"."troll_post_gifts" USING "btree" ("post_id");



CREATE INDEX "idx_troll_post_gifts_receiver_id" ON "public"."troll_post_gifts" USING "btree" ("receiver_id");



CREATE INDEX "idx_troll_post_gifts_sender_id" ON "public"."troll_post_gifts" USING "btree" ("sender_id");



CREATE INDEX "idx_troll_post_reactions_post_id" ON "public"."troll_post_reactions" USING "btree" ("post_id");



CREATE INDEX "idx_troll_post_reactions_user_id" ON "public"."troll_post_reactions" USING "btree" ("user_id");



CREATE INDEX "idx_troll_post_views_post_id" ON "public"."troll_post_views" USING "btree" ("post_id");



CREATE INDEX "idx_troll_post_views_user_id" ON "public"."troll_post_views" USING "btree" ("user_id");



CREATE INDEX "idx_troll_post_views_user_post" ON "public"."troll_post_views" USING "btree" ("user_id", "post_id");



CREATE INDEX "idx_troll_posts_created_at" ON "public"."troll_posts" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_troll_posts_user_id" ON "public"."troll_posts" USING "btree" ("user_id");



CREATE INDEX "idx_troll_stream_messages_stream_id" ON "public"."troll_stream_messages" USING "btree" ("stream_id");



CREATE INDEX "idx_troll_stream_messages_user_id" ON "public"."troll_stream_messages" USING "btree" ("user_id");



CREATE INDEX "idx_troll_streams_user_id" ON "public"."troll_streams" USING "btree" ("user_id");



CREATE INDEX "idx_troll_wall_gifts_post_id" ON "public"."troll_wall_gifts" USING "btree" ("post_id");



CREATE INDEX "idx_troll_wall_gifts_sender_id" ON "public"."troll_wall_gifts" USING "btree" ("sender_id");



CREATE INDEX "idx_troll_wall_likes_post_id" ON "public"."troll_wall_likes" USING "btree" ("post_id");



CREATE INDEX "idx_troll_wall_likes_unique" ON "public"."troll_wall_likes" USING "btree" ("post_id", "user_id");



CREATE INDEX "idx_troll_wall_likes_user_id" ON "public"."troll_wall_likes" USING "btree" ("user_id");



CREATE INDEX "idx_troll_wall_posts_created_at" ON "public"."troll_wall_posts" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_troll_wall_posts_is_pinned_created_at" ON "public"."troll_wall_posts" USING "btree" ("is_pinned" DESC, "created_at" DESC);



CREATE INDEX "idx_troll_wall_posts_likes" ON "public"."troll_wall_posts" USING "btree" ("likes" DESC);



CREATE INDEX "idx_troll_wall_posts_post_type" ON "public"."troll_wall_posts" USING "btree" ("post_type");



CREATE INDEX "idx_troll_wall_posts_reply_to" ON "public"."troll_wall_posts" USING "btree" ("reply_to_post_id") WHERE ("reply_to_post_id" IS NOT NULL);



CREATE INDEX "idx_troll_wall_posts_user_id" ON "public"."troll_wall_posts" USING "btree" ("user_id");



CREATE INDEX "idx_troll_wall_reactions_post_id" ON "public"."troll_wall_reactions" USING "btree" ("post_id");



CREATE INDEX "idx_troll_wall_reactions_user_id" ON "public"."troll_wall_reactions" USING "btree" ("user_id");



CREATE INDEX "idx_trollcity_orders_buyer_id" ON "public"."trollcity_orders" USING "btree" ("buyer_id");



CREATE INDEX "idx_trollcity_orders_product_id" ON "public"."trollcity_orders" USING "btree" ("product_id");



CREATE INDEX "idx_trollcity_orders_shop_id" ON "public"."trollcity_orders" USING "btree" ("shop_id");



CREATE INDEX "idx_trollcity_products_shop_id" ON "public"."trollcity_products" USING "btree" ("shop_id");



CREATE INDEX "idx_trollcity_shops_owner_id" ON "public"."trollcity_shops" USING "btree" ("owner_id");



CREATE INDEX "idx_trollmonds_pool_contrib_stream_created" ON "public"."coin_pool_contributions" USING "btree" ("stream_id", "created_at" DESC);



CREATE INDEX "idx_trollmonds_pools_stream_id" ON "public"."trollmonds_pools" USING "btree" ("stream_id");



CREATE INDEX "idx_trolls_night_applications_user_id" ON "public"."trolls_night_applications" USING "btree" ("user_id");



CREATE INDEX "idx_trollstown_properties_user_id" ON "public"."trollstown_properties" USING "btree" ("user_id");



CREATE INDEX "idx_trollstown_property_upgrades_property_id" ON "public"."trollstown_property_upgrades" USING "btree" ("property_id");



CREATE INDEX "idx_trollstown_property_upgrades_user_id" ON "public"."trollstown_property_upgrades" USING "btree" ("user_id");



CREATE INDEX "idx_trolltract_contracts_signed_at" ON "public"."trolltract_contracts" USING "btree" ("signed_at" DESC);



CREATE INDEX "idx_trolltract_contracts_user_id" ON "public"."trolltract_contracts" USING "btree" ("user_id");



CREATE INDEX "idx_trolltract_weekly_rewards_contract_id" ON "public"."trolltract_weekly_rewards" USING "btree" ("contract_id");



CREATE INDEX "idx_tromody_battles_left_user" ON "public"."tromody_battles" USING "btree" ("left_user_id");



CREATE INDEX "idx_tromody_battles_left_user_id" ON "public"."tromody_battles" USING "btree" ("left_user_id");



CREATE INDEX "idx_tromody_battles_right_user" ON "public"."tromody_battles" USING "btree" ("right_user_id");



CREATE INDEX "idx_tromody_battles_right_user_id" ON "public"."tromody_battles" USING "btree" ("right_user_id");



CREATE INDEX "idx_tromody_battles_started_at" ON "public"."tromody_battles" USING "btree" ("battle_started_at" DESC);



CREATE INDEX "idx_tromody_battles_winner" ON "public"."tromody_battles" USING "btree" ("winner_user_id");



CREATE INDEX "idx_tromody_battles_winner_user_id" ON "public"."tromody_battles" USING "btree" ("winner_user_id");



CREATE INDEX "idx_tromody_gifts_session_id" ON "public"."tromody_gifts" USING "btree" ("session_id");



CREATE INDEX "idx_tromody_matches_player1_id" ON "public"."tromody_matches" USING "btree" ("player1_id");



CREATE INDEX "idx_tromody_matches_player2_id" ON "public"."tromody_matches" USING "btree" ("player2_id");



CREATE INDEX "idx_tromody_matches_winner_id" ON "public"."tromody_matches" USING "btree" ("winner_id");



CREATE INDEX "idx_upm_default" ON "public"."user_payment_methods" USING "btree" ("user_id", "is_default");



CREATE INDEX "idx_upm_user" ON "public"."user_payment_methods" USING "btree" ("user_id");



CREATE INDEX "idx_user_active_items_item_id" ON "public"."user_active_items" USING "btree" ("item_id");



CREATE INDEX "idx_user_active_items_user_id" ON "public"."user_active_items" USING "btree" ("user_id");



CREATE INDEX "idx_user_agreements_accepted_at" ON "public"."user_agreements" USING "btree" ("accepted_at");



CREATE INDEX "idx_user_agreements_agreement_version" ON "public"."user_agreements" USING "btree" ("agreement_version");



CREATE INDEX "idx_user_agreements_terms_accepted" ON "public"."user_agreements" USING "btree" ("terms_accepted");



CREATE INDEX "idx_user_agreements_user_id" ON "public"."user_agreements" USING "btree" ("user_id");



CREATE INDEX "idx_user_badges_earned_badge_id" ON "public"."user_badges_earned" USING "btree" ("badge_id");



CREATE INDEX "idx_user_badges_earned_user_id" ON "public"."user_badges_earned" USING "btree" ("user_id");



CREATE INDEX "idx_user_balances_user_id" ON "public"."user_balances" USING "btree" ("user_id");



CREATE INDEX "idx_user_bans_banned_by" ON "public"."user_bans" USING "btree" ("banned_by");



CREATE INDEX "idx_user_bans_user_id" ON "public"."user_bans" USING "btree" ("user_id");



CREATE INDEX "idx_user_boosts_user_id" ON "public"."user_boosts" USING "btree" ("user_id");



CREATE INDEX "idx_user_call_sounds_user" ON "public"."user_call_sounds" USING "btree" ("user_id");



CREATE INDEX "idx_user_district_progress_district_id" ON "public"."user_district_progress" USING "btree" ("district_id");



CREATE INDEX "idx_user_district_progress_user" ON "public"."user_district_progress" USING "btree" ("user_id");



CREATE INDEX "idx_user_district_progress_user_id" ON "public"."user_district_progress" USING "btree" ("user_id");



CREATE INDEX "idx_user_entrance_effects_active" ON "public"."user_entrance_effects" USING "btree" ("user_id") WHERE ("is_active" = true);



CREATE INDEX "idx_user_entrance_effects_effect_id" ON "public"."user_entrance_effects" USING "btree" ("effect_id");



CREATE INDEX "idx_user_entrance_effects_user" ON "public"."user_entrance_effects" USING "btree" ("user_id");



CREATE INDEX "idx_user_entrance_effects_user_id" ON "public"."user_entrance_effects" USING "btree" ("user_id");



CREATE INDEX "idx_user_follows_follower" ON "public"."user_follows" USING "btree" ("follower_id");



CREATE INDEX "idx_user_follows_follower_id" ON "public"."user_follows" USING "btree" ("follower_id");



CREATE INDEX "idx_user_follows_following" ON "public"."user_follows" USING "btree" ("following_id");



CREATE INDEX "idx_user_follows_following_id" ON "public"."user_follows" USING "btree" ("following_id");



CREATE INDEX "idx_user_insurance_plan_id" ON "public"."user_insurance" USING "btree" ("plan_id");



CREATE INDEX "idx_user_insurance_user_id" ON "public"."user_insurance" USING "btree" ("user_id");



CREATE INDEX "idx_user_insurances_active" ON "public"."user_insurances" USING "btree" ("user_id") WHERE ("is_active" = true);



CREATE INDEX "idx_user_insurances_insurance_id" ON "public"."user_insurances" USING "btree" ("insurance_id");



CREATE INDEX "idx_user_insurances_user" ON "public"."user_insurances" USING "btree" ("user_id");



CREATE INDEX "idx_user_insurances_user_id" ON "public"."user_insurances" USING "btree" ("user_id");



CREATE INDEX "idx_user_inventory_item_id" ON "public"."user_inventory" USING "btree" ("item_id");



CREATE INDEX "idx_user_inventory_user_id" ON "public"."user_inventory" USING "btree" ("user_id");



CREATE INDEX "idx_user_ip_tracking_user_id" ON "public"."user_ip_tracking" USING "btree" ("user_id");



CREATE INDEX "idx_user_payout_settings_user_id" ON "public"."user_payout_settings" USING "btree" ("user_id");



CREATE INDEX "idx_user_perks_active" ON "public"."user_perks" USING "btree" ("user_id") WHERE ("is_active" = true);



CREATE INDEX "idx_user_perks_perk_id" ON "public"."user_perks" USING "btree" ("perk_id");



CREATE INDEX "idx_user_perks_user" ON "public"."user_perks" USING "btree" ("user_id");



CREATE INDEX "idx_user_perks_user_id" ON "public"."user_perks" USING "btree" ("user_id");



CREATE INDEX "idx_user_profiles_birthday_coins" ON "public"."user_profiles" USING "btree" ("birthday_coins_awarded_date") WHERE ("birthday_coins_awarded_date" IS NOT NULL);



CREATE INDEX "idx_user_profiles_empire_partner" ON "public"."user_profiles" USING "btree" ("empire_partner");



CREATE INDEX "idx_user_profiles_empire_role" ON "public"."user_profiles" USING "btree" ("empire_role");



CREATE INDEX "idx_user_profiles_ghost_mode_expires_at" ON "public"."user_profiles" USING "btree" ("ghost_mode_expires_at");



CREATE INDEX "idx_user_profiles_is_admin" ON "public"."user_profiles" USING "btree" ("is_admin") WHERE ("is_admin" = true);



CREATE INDEX "idx_user_profiles_is_empire_partner" ON "public"."user_profiles" USING "btree" ("is_empire_partner");



CREATE INDEX "idx_user_profiles_is_officer" ON "public"."user_profiles" USING "btree" ("is_troll_officer") WHERE ("is_troll_officer" = true);



CREATE INDEX "idx_user_profiles_is_og" ON "public"."user_profiles" USING "btree" ("is_og_user") WHERE ("is_og_user" = true);



CREATE INDEX "idx_user_profiles_is_troller" ON "public"."user_profiles" USING "btree" ("is_troller") WHERE ("is_troller" = true);



CREATE INDEX "idx_user_profiles_last_known_ip" ON "public"."user_profiles" USING "btree" ("last_known_ip");



CREATE INDEX "idx_user_profiles_lead_officer" ON "public"."user_profiles" USING "btree" ("is_lead_officer") WHERE ("is_lead_officer" = true);



CREATE INDEX "idx_user_profiles_live_restricted_until" ON "public"."user_profiles" USING "btree" ("live_restricted_until");



CREATE INDEX "idx_user_profiles_mic_muted_until" ON "public"."user_profiles" USING "btree" ("mic_muted_until");



CREATE INDEX "idx_user_profiles_officer_level" ON "public"."user_profiles" USING "btree" ("officer_level") WHERE ("is_troll_officer" = true);



CREATE INDEX "idx_user_profiles_og_badge" ON "public"."user_profiles" USING "btree" ("og_badge");



CREATE INDEX "idx_user_profiles_partner_status" ON "public"."user_profiles" USING "btree" ("partner_status");



CREATE INDEX "idx_user_profiles_paypal_email" ON "public"."user_profiles" USING "btree" ("payout_paypal_email") WHERE ("payout_paypal_email" IS NOT NULL);



CREATE INDEX "idx_user_profiles_rank" ON "public"."user_profiles" USING "btree" ("rank");



CREATE INDEX "idx_user_profiles_role" ON "public"."user_profiles" USING "btree" ("role");



CREATE INDEX "idx_user_profiles_seller_verified" ON "public"."user_profiles" USING "btree" ("seller_verified") WHERE ("seller_verified" = true);



CREATE INDEX "idx_user_profiles_troller_level" ON "public"."user_profiles" USING "btree" ("troller_level") WHERE ("is_troller" = true);



CREATE INDEX "idx_user_profiles_user_id" ON "public"."user_profiles" USING "btree" ("user_id");



CREATE INDEX "idx_user_profiles_username" ON "public"."user_profiles" USING "btree" ("username");



CREATE INDEX "idx_user_profiles_username_lower" ON "public"."user_profiles" USING "btree" ("lower"("username"));



CREATE INDEX "idx_user_reputation_priority" ON "public"."user_reputation" USING "btree" ("is_escalation_priority");



CREATE INDEX "idx_user_reputation_tier" ON "public"."user_reputation" USING "btree" ("reputation_tier");



CREATE INDEX "idx_user_reputation_user_id" ON "public"."user_reputation" USING "btree" ("user_id");



CREATE INDEX "idx_user_risk_profile_is_frozen" ON "public"."user_risk_profile" USING "btree" ("is_frozen");



CREATE INDEX "idx_user_risk_profile_risk_score" ON "public"."user_risk_profile" USING "btree" ("risk_score");



CREATE INDEX "idx_user_risk_profile_user_id" ON "public"."user_risk_profile" USING "btree" ("user_id");



CREATE INDEX "idx_user_roles_user" ON "public"."user_roles" USING "btree" ("user_id");



CREATE INDEX "idx_user_roles_user_id" ON "public"."user_roles" USING "btree" ("user_id");



CREATE INDEX "idx_user_tax_info_user_id" ON "public"."user_tax_info" USING "btree" ("user_id");



CREATE INDEX "idx_users_email" ON "public"."users" USING "btree" ("email");



CREATE INDEX "idx_users_id" ON "public"."users" USING "btree" ("id");



CREATE INDEX "idx_vendor_invoices_due" ON "public"."vendor_invoices" USING "btree" ("due_date");



CREATE INDEX "idx_vendor_invoices_vendor_date" ON "public"."vendor_invoices" USING "btree" ("vendor", "invoice_date" DESC);



CREATE INDEX "idx_verification_requests_admin_reviewer" ON "public"."verification_requests" USING "btree" ("admin_reviewer");



CREATE INDEX "idx_verification_requests_created" ON "public"."verification_requests" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_verification_requests_duplicate_of_id" ON "public"."verification_requests" USING "btree" ("duplicate_of_id");



CREATE INDEX "idx_verification_requests_id_hash" ON "public"."verification_requests" USING "btree" ("id_photo_hash");



CREATE INDEX "idx_verification_requests_source" ON "public"."verification_requests" USING "btree" ("source");



CREATE INDEX "idx_verification_requests_status" ON "public"."verification_requests" USING "btree" ("status");



CREATE INDEX "idx_verification_requests_user" ON "public"."verification_requests" USING "btree" ("user_id");



CREATE INDEX "idx_verification_requests_user_id" ON "public"."verification_requests" USING "btree" ("user_id");



CREATE INDEX "idx_verification_transactions_created" ON "public"."verification_transactions" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_verification_transactions_user" ON "public"."verification_transactions" USING "btree" ("user_id");



CREATE INDEX "idx_verification_transactions_user_id" ON "public"."verification_transactions" USING "btree" ("user_id");



CREATE INDEX "idx_visa_redemptions_created" ON "public"."visa_redemptions" USING "btree" ("created_at");



CREATE INDEX "idx_visa_redemptions_status" ON "public"."visa_redemptions" USING "btree" ("status");



CREATE INDEX "idx_visa_redemptions_user" ON "public"."visa_redemptions" USING "btree" ("user_id");



CREATE INDEX "idx_wall_posts_created_at" ON "public"."wall_posts" USING "btree" ("created_at");



CREATE INDEX "idx_wall_posts_user_id" ON "public"."wall_posts" USING "btree" ("user_id");



CREATE INDEX "idx_war_results_family_id" ON "public"."war_results" USING "btree" ("family_id");



CREATE INDEX "idx_war_results_war_id" ON "public"."war_results" USING "btree" ("war_id");



CREATE INDEX "idx_weekly_officer_reports_lead_officer_id" ON "public"."weekly_officer_reports" USING "btree" ("lead_officer_id");



CREATE INDEX "idx_weekly_reports_created_at" ON "public"."weekly_officer_reports" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_weekly_reports_lead_officer_id" ON "public"."weekly_officer_reports" USING "btree" ("lead_officer_id");



CREATE INDEX "idx_weekly_reports_week_end" ON "public"."weekly_officer_reports" USING "btree" ("week_end");



CREATE INDEX "idx_weekly_reports_week_start" ON "public"."weekly_officer_reports" USING "btree" ("week_start");



CREATE INDEX "idx_wheel_spins_created" ON "public"."wheel_spins" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_wheel_spins_outcome" ON "public"."wheel_spins" USING "btree" ("outcome");



CREATE INDEX "idx_wheel_spins_user" ON "public"."wheel_spins" USING "btree" ("user_id");



CREATE INDEX "idx_wheel_spins_user_id" ON "public"."wheel_spins" USING "btree" ("user_id");



CREATE INDEX "millionaire_hof_created_idx" ON "public"."millionaire_hall_of_fame" USING "btree" ("created_at" DESC);



CREATE INDEX "notifications_is_sent_idx" ON "public"."notifications" USING "btree" ("is_sent");



CREATE INDEX "notifications_type_idx" ON "public"."notifications" USING "btree" ("type");



CREATE INDEX "notifications_user_id_created_at_idx" ON "public"."notifications" USING "btree" ("user_id", "created_at" DESC);



CREATE INDEX "notifications_user_id_is_read_idx" ON "public"."notifications" USING "btree" ("user_id", "is_read");



CREATE UNIQUE INDEX "one_active_insurance" ON "public"."user_active_items" USING "btree" ("user_id") WHERE (("is_active" = true) AND ("item_type" = 'insurance'::"text"));



CREATE UNIQUE INDEX "one_active_per_type" ON "public"."user_active_items" USING "btree" ("user_id", "item_type") WHERE ("is_active" = true);



CREATE UNIQUE INDEX "payout_requests_user_idempotency_key_idx" ON "public"."payout_requests" USING "btree" ("user_id", "idempotency_key") WHERE ("idempotency_key" IS NOT NULL);



CREATE UNIQUE INDEX "profiles_auth_user_id_unique" ON "public"."profiles" USING "btree" ("auth_user_id");



CREATE UNIQUE INDEX "profiles_user_id_unique" ON "public"."profiles" USING "btree" ("user_id");



CREATE UNIQUE INDEX "profiles_username_unique" ON "public"."profiles" USING "btree" ("lower"("username"));



CREATE INDEX "property_upgrades_owner_user_id_idx" ON "public"."property_upgrades" USING "btree" ("owner_user_id");



CREATE INDEX "property_upgrades_property_id_idx" ON "public"."property_upgrades" USING "btree" ("property_id");



CREATE INDEX "property_upgrades_upgrade_key_idx" ON "public"."property_upgrades" USING "btree" ("upgrade_key");



CREATE UNIQUE INDEX "provider_costs_provider_idx" ON "public"."provider_costs" USING "btree" ("provider");



CREATE UNIQUE INDEX "referral_claims_unique_user_referred" ON "public"."referral_claims" USING "btree" ("user_id", "referred_user_id");



CREATE INDEX "shop_transactions_shop_id_idx" ON "public"."shop_transactions" USING "btree" ("shop_id");



CREATE INDEX "system_alerts_created_at_idx" ON "public"."system_alerts" USING "btree" ("created_at" DESC);



CREATE INDEX "system_alerts_status_idx" ON "public"."system_alerts" USING "btree" ("status");



CREATE INDEX "system_alerts_user_id_idx" ON "public"."system_alerts" USING "btree" ("user_id");



CREATE INDEX "system_errors_created_at_idx" ON "public"."system_errors" USING "btree" ("created_at" DESC);



CREATE INDEX "system_errors_user_id_idx" ON "public"."system_errors" USING "btree" ("user_id");



CREATE INDEX "tfm_user_idx" ON "public"."troll_family_members" USING "btree" ("user_id");



CREATE INDEX "ticket_messages_created_at_idx" ON "public"."ticket_messages" USING "btree" ("created_at" DESC);



CREATE INDEX "ticket_messages_ticket_idx" ON "public"."ticket_messages" USING "btree" ("ticket_id");



CREATE UNIQUE INDEX "troll_families_name_unique" ON "public"."troll_families" USING "btree" ("name");



CREATE INDEX "troll_family_memberships_family_idx" ON "public"."troll_family_memberships" USING "btree" ("family_id");



CREATE INDEX "troll_family_memberships_user_idx" ON "public"."troll_family_memberships" USING "btree" ("user_id");



CREATE UNIQUE INDEX "uniq_family_members" ON "public"."family_members" USING "btree" ("family_id", "user_id");



CREATE UNIQUE INDEX "uniq_mai_appeals_one" ON "public"."mai_appeals" USING "btree" ("case_type", "case_id", "appellant_user_id");



CREATE UNIQUE INDEX "uniq_troll_family_members" ON "public"."troll_family_members" USING "btree" ("family_id", "user_id");



CREATE UNIQUE INDEX "uniq_upm_card" ON "public"."user_payment_methods" USING "btree" ("user_id", "square_card_id");



CREATE UNIQUE INDEX "uniq_user_follows" ON "public"."user_follows" USING "btree" ("follower_id", "following_id");



CREATE UNIQUE INDEX "unique_royal_troll_per_family" ON "public"."family_members" USING "btree" ("family_id") WHERE ("role" = 'royal_troll'::"text");



CREATE INDEX "user_notifications_user_id_idx" ON "public"."user_notifications" USING "btree" ("user_id");



CREATE UNIQUE INDEX "user_profiles_user_id_unique" ON "public"."user_profiles" USING "btree" ("user_id");



CREATE UNIQUE INDEX "user_profiles_userid_unique" ON "public"."user_profiles" USING "btree" ("user_id");



CREATE UNIQUE INDEX "user_profiles_username_unique" ON "public"."user_profiles" USING "btree" ("username") WHERE ("username" IS NOT NULL);



CREATE UNIQUE INDEX "user_tax_info_user_id_unique" ON "public"."user_tax_info" USING "btree" ("user_id");



CREATE INDEX "visa_redemptions_status_idx" ON "public"."visa_redemptions" USING "btree" ("status");



CREATE INDEX "visa_redemptions_user_id_idx" ON "public"."visa_redemptions" USING "btree" ("user_id");



CREATE INDEX "web_push_subscriptions_user_id_idx" ON "public"."web_push_subscriptions" USING "btree" ("user_id");



CREATE OR REPLACE TRIGGER "abuse_reports_updated_at" BEFORE UPDATE ON "public"."abuse_reports" FOR EACH ROW EXECUTE FUNCTION "public"."update_abuse_reports_updated_at"();



CREATE OR REPLACE TRIGGER "assign_og_on_register" BEFORE INSERT ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."set_og_badge"();



CREATE OR REPLACE TRIGGER "block_cashouts_trigger" BEFORE INSERT ON "public"."cashout_requests" FOR EACH ROW EXECUTE FUNCTION "public"."block_cashouts_when_locked"();



CREATE OR REPLACE TRIGGER "cleanup_sessions_trigger" AFTER INSERT ON "public"."active_sessions" FOR EACH STATEMENT EXECUTE FUNCTION "public"."trigger_cleanup_sessions"();



CREATE OR REPLACE TRIGGER "marketplace_items_sync_title_trigger" BEFORE INSERT OR UPDATE ON "public"."marketplace_items" FOR EACH ROW EXECUTE FUNCTION "public"."marketplace_items_sync_title"();



CREATE OR REPLACE TRIGGER "officer_live_assignments_updated_at" BEFORE UPDATE ON "public"."officer_live_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."update_officer_live_assignments_updated_at"();



CREATE OR REPLACE TRIGGER "officer_work_sessions_updated_at" BEFORE UPDATE ON "public"."officer_work_sessions" FOR EACH ROW EXECUTE FUNCTION "public"."update_officer_work_sessions_updated_at"();



CREATE OR REPLACE TRIGGER "prevent_hr_field_changes_trigger" BEFORE UPDATE ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."prevent_hr_field_changes"();



CREATE OR REPLACE TRIGGER "prevent_privilege_escalation" BEFORE UPDATE ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."prevent_profile_privilege_escalation"();



CREATE OR REPLACE TRIGGER "prevent_protected_profile_changes_trigger" BEFORE UPDATE ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."prevent_protected_profile_changes"();



CREATE OR REPLACE TRIGGER "prevent_role_change_trigger" BEFORE UPDATE ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."prevent_role_change"();



CREATE OR REPLACE TRIGGER "provider_costs_updated_at" BEFORE UPDATE ON "public"."provider_costs" FOR EACH ROW EXECUTE FUNCTION "public"."update_provider_costs_updated_at"();



CREATE OR REPLACE TRIGGER "revoke_insurance_on_transfer" BEFORE UPDATE OF "user_id" ON "public"."trollstown_properties" FOR EACH ROW EXECUTE FUNCTION "public"."trg_revoke_property_insurance_on_transfer"();



CREATE OR REPLACE TRIGGER "set_broadcast_seats_updated_at" BEFORE UPDATE ON "public"."broadcast_seats" FOR EACH ROW EXECUTE FUNCTION "public"."broadcast_seats_updated_at"();



CREATE OR REPLACE TRIGGER "set_empire_applications_updated_at" BEFORE UPDATE ON "public"."empire_applications" FOR EACH ROW EXECUTE FUNCTION "public"."update_empire_applications_updated_at"();



CREATE OR REPLACE TRIGGER "set_officer_orientation_results_updated_at" BEFORE UPDATE ON "public"."officer_orientation_results" FOR EACH ROW EXECUTE FUNCTION "public"."update_officer_orientation_results_updated_at"();



CREATE OR REPLACE TRIGGER "set_officer_shift_logs_updated_at" BEFORE UPDATE ON "public"."officer_shift_logs" FOR EACH ROW EXECUTE FUNCTION "public"."update_officer_shift_logs_updated_at"();



CREATE OR REPLACE TRIGGER "set_payout_requests_updated_at" BEFORE UPDATE ON "public"."payout_requests" FOR EACH ROW EXECUTE FUNCTION "public"."update_payout_requests_updated_at"();



CREATE OR REPLACE TRIGGER "set_referral_deadline_trigger" BEFORE INSERT ON "public"."referrals" FOR EACH ROW EXECUTE FUNCTION "public"."set_referral_deadline"();



CREATE OR REPLACE TRIGGER "set_weekly_reports_updated_at" BEFORE UPDATE ON "public"."weekly_officer_reports" FOR EACH ROW EXECUTE FUNCTION "public"."update_weekly_reports_updated_at"();



CREATE OR REPLACE TRIGGER "sync_badge_from_role_trigger" AFTER UPDATE OF "role" ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."sync_badge_from_role"();



CREATE OR REPLACE TRIGGER "tr_grant_og_badge" BEFORE INSERT OR UPDATE ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."grant_og_badge"();



CREATE OR REPLACE TRIGGER "tr_track_broadcaster_earnings" AFTER INSERT ON "public"."gifts" FOR EACH ROW EXECUTE FUNCTION "public"."track_broadcaster_earnings"();



CREATE OR REPLACE TRIGGER "trg_admin_coin_revenue_updated_at" BEFORE UPDATE ON "public"."admin_coin_revenue" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_assign_og_user" BEFORE INSERT ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."assign_og_user"();



CREATE OR REPLACE TRIGGER "trg_broadcaster_metrics_touch_updated" BEFORE UPDATE ON "public"."broadcaster_metrics" FOR EACH ROW EXECUTE FUNCTION "public"."fn_touch_updated_at"();



CREATE OR REPLACE TRIGGER "trg_cashout_requests_block_lock" BEFORE INSERT ON "public"."cashout_requests" FOR EACH ROW EXECUTE FUNCTION "public"."ensure_payout_not_locked"();



CREATE OR REPLACE TRIGGER "trg_coin_ledger_apply" AFTER INSERT ON "public"."coin_ledger" FOR EACH ROW EXECUTE FUNCTION "public"."fn_apply_coin_ledger"();



CREATE OR REPLACE TRIGGER "trg_create_family_stats" AFTER INSERT ON "public"."troll_families" FOR EACH ROW EXECUTE FUNCTION "public"."create_family_stats_row"();



CREATE OR REPLACE TRIGGER "trg_create_message_receipts" AFTER INSERT ON "public"."conversation_messages" FOR EACH ROW EXECUTE FUNCTION "public"."create_message_receipts"();



CREATE OR REPLACE TRIGGER "trg_economy_abuse_no_delete" BEFORE DELETE ON "public"."economy_abuse_flags" FOR EACH ROW EXECUTE FUNCTION "public"."_mai_block_mutations"();



CREATE OR REPLACE TRIGGER "trg_economy_abuse_no_update" BEFORE UPDATE ON "public"."economy_abuse_flags" FOR EACH ROW EXECUTE FUNCTION "public"."_mai_block_mutations"();



CREATE OR REPLACE TRIGGER "trg_example" BEFORE INSERT ON "public"."battle_gifts" FOR EACH ROW EXECUTE FUNCTION "public"."some_function"();



CREATE OR REPLACE TRIGGER "trg_finalize_redemption" AFTER UPDATE OF "status" ON "public"."gift_card_redemptions" FOR EACH ROW EXECUTE FUNCTION "public"."finalize_redemption_on_sent"();



CREATE OR REPLACE TRIGGER "trg_finalize_redemption_status" AFTER UPDATE OF "status" ON "public"."gift_card_redemptions" FOR EACH ROW EXECUTE FUNCTION "public"."finalize_redemption_status"();



CREATE OR REPLACE TRIGGER "trg_giftcard_failure_alert" AFTER UPDATE OF "fulfillment_status" ON "public"."giftcard_fulfillments" FOR EACH ROW EXECUTE FUNCTION "public"."on_giftcard_failure_alert"();



CREATE OR REPLACE TRIGGER "trg_log_payout_status" AFTER UPDATE ON "public"."payout_requests" FOR EACH ROW EXECUTE FUNCTION "public"."log_payout_status_change"();



CREATE OR REPLACE TRIGGER "trg_log_user_moderation" AFTER UPDATE ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."log_user_moderation"();



CREATE OR REPLACE TRIGGER "trg_mai_gift_abuse" AFTER INSERT ON "public"."gifts" FOR EACH ROW EXECUTE FUNCTION "public"."_mai_gift_abuse_trigger"();



CREATE OR REPLACE TRIGGER "trg_mai_timeline_no_delete" BEFORE DELETE ON "public"."mai_timeline_events" FOR EACH ROW EXECUTE FUNCTION "public"."_mai_block_mutations"();



CREATE OR REPLACE TRIGGER "trg_mai_timeline_no_update" BEFORE UPDATE ON "public"."mai_timeline_events" FOR EACH ROW EXECUTE FUNCTION "public"."_mai_block_mutations"();



CREATE OR REPLACE TRIGGER "trg_payout_requests_block_lock" BEFORE INSERT ON "public"."payout_requests" FOR EACH ROW EXECUTE FUNCTION "public"."ensure_payout_not_locked"();



CREATE OR REPLACE TRIGGER "trg_payout_requests_window" BEFORE INSERT ON "public"."payout_requests" FOR EACH ROW EXECUTE FUNCTION "public"."ensure_payout_window_open"();



CREATE OR REPLACE TRIGGER "trg_payout_touch_updated" BEFORE UPDATE ON "public"."payout_requests" FOR EACH ROW EXECUTE FUNCTION "public"."fn_touch_updated_at"();



CREATE OR REPLACE TRIGGER "trg_prevent_negative_troll_coins" AFTER UPDATE ON "public"."gift_card_redemptions" FOR EACH ROW WHEN (("new"."status" = 'sent'::"text")) EXECUTE FUNCTION "public"."prevent_negative_troll_coins"();



CREATE OR REPLACE TRIGGER "trg_prevent_over_reservation" BEFORE INSERT ON "public"."gift_card_redemptions" FOR EACH ROW EXECUTE FUNCTION "public"."prevent_over_reservation"();



CREATE OR REPLACE TRIGGER "trg_prevent_redemption_tier_changes" BEFORE UPDATE ON "public"."gift_card_redemptions" FOR EACH ROW EXECUTE FUNCTION "public"."prevent_redemption_tier_changes"();



CREATE OR REPLACE TRIGGER "trg_process_gift_transaction" AFTER INSERT ON "public"."gift_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."process_gift_transaction"();



CREATE OR REPLACE TRIGGER "trg_reserve_paid_coins" AFTER INSERT ON "public"."gift_card_redemptions" FOR EACH ROW EXECUTE FUNCTION "public"."reserve_paid_coins_on_redemption"();



CREATE OR REPLACE TRIGGER "trg_reserve_troll_coins" AFTER INSERT ON "public"."gift_card_redemptions" FOR EACH ROW EXECUTE FUNCTION "public"."reserve_troll_coins_on_redemption"();



CREATE OR REPLACE TRIGGER "trg_set_action_logs_created_day" BEFORE INSERT ON "public"."action_logs" FOR EACH ROW EXECUTE FUNCTION "public"."set_action_logs_created_day"();



CREATE OR REPLACE TRIGGER "trg_set_court_session_started_by" BEFORE INSERT ON "public"."court_sessions" FOR EACH ROW EXECUTE FUNCTION "public"."set_court_session_started_by"();



CREATE OR REPLACE TRIGGER "trg_set_default_troll_coins" BEFORE INSERT ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."set_default_troll_coins"();



CREATE OR REPLACE TRIGGER "trg_set_og_status" BEFORE INSERT ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."set_og_status_for_new_users"();



CREATE OR REPLACE TRIGGER "trg_set_trollstown_coins" BEFORE INSERT ON "public"."trollstown_properties" FOR EACH ROW EXECUTE FUNCTION "public"."set_trollstown_coins_on_insert"();



CREATE OR REPLACE TRIGGER "trg_staff_applications_updated_at" BEFORE UPDATE ON "public"."staff_applications" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_staff_profiles_updated_at" BEFORE UPDATE ON "public"."staff_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_streamer_xp" AFTER UPDATE ON "public"."streams" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_award_streamer_xp"();



CREATE OR REPLACE TRIGGER "trg_sync_action_type" BEFORE INSERT OR UPDATE ON "public"."moderation_actions" FOR EACH ROW EXECUTE FUNCTION "public"."sync_action_type"();



CREATE OR REPLACE TRIGGER "trg_sync_empire_applicant_id" BEFORE INSERT OR UPDATE ON "public"."empire_applications" FOR EACH ROW EXECUTE FUNCTION "public"."sync_empire_applicant_id"();



CREATE OR REPLACE TRIGGER "trg_sync_family_coins" BEFORE UPDATE ON "public"."family_stats" FOR EACH ROW EXECUTE FUNCTION "public"."sync_family_coins"();



CREATE OR REPLACE TRIGGER "trg_sync_key_columns" BEFORE INSERT OR UPDATE ON "public"."app_settings" FOR EACH ROW EXECUTE FUNCTION "public"."sync_key_columns"();



CREATE OR REPLACE TRIGGER "trg_sync_troll_role" BEFORE INSERT OR UPDATE ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."sync_troll_role"();



CREATE OR REPLACE TRIGGER "trg_sync_trollstown_coins" AFTER UPDATE OF "troll_coins" ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."sync_trollstown_coins_from_profiles"();



CREATE OR REPLACE TRIGGER "trg_sync_vault_tokens" BEFORE UPDATE ON "public"."family_stats" FOR EACH ROW EXECUTE FUNCTION "public"."sync_vault_tokens"();



CREATE OR REPLACE TRIGGER "trg_tax_status" AFTER INSERT OR UPDATE ON "public"."payout_requests" FOR EACH ROW EXECUTE FUNCTION "public"."update_tax_status"();



CREATE OR REPLACE TRIGGER "trg_touch_intake" BEFORE UPDATE ON "public"."executive_intake" FOR EACH ROW EXECUTE FUNCTION "public"."touch_updated_at"();



CREATE OR REPLACE TRIGGER "trg_two_secretaries_max" BEFORE INSERT ON "public"."secretary_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."enforce_two_secretaries_max"();



CREATE OR REPLACE TRIGGER "trg_update_admin_tax_reviews_timestamp" BEFORE UPDATE ON "public"."admin_tax_reviews" FOR EACH ROW EXECUTE FUNCTION "public"."update_admin_tax_reviews_timestamp"();



CREATE OR REPLACE TRIGGER "trg_update_timestamp" BEFORE UPDATE ON "public"."app_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_timestamp"();



CREATE OR REPLACE TRIGGER "trg_user_levels_touch_updated" BEFORE UPDATE ON "public"."user_levels" FOR EACH ROW EXECUTE FUNCTION "public"."fn_touch_updated_at"();



CREATE OR REPLACE TRIGGER "trg_user_wallets_touch_updated" BEFORE UPDATE ON "public"."user_wallets" FOR EACH ROW EXECUTE FUNCTION "public"."fn_touch_updated_at"();



CREATE OR REPLACE TRIGGER "trg_visa_redemptions_window" BEFORE INSERT ON "public"."visa_redemptions" FOR EACH ROW EXECUTE FUNCTION "public"."ensure_payout_window_open"();



CREATE OR REPLACE TRIGGER "trigger_auto_grant_admin_officer" BEFORE INSERT OR UPDATE ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."auto_grant_admin_officer_status"();



CREATE OR REPLACE TRIGGER "trigger_auto_post_battle_result" AFTER UPDATE ON "public"."troll_battles" FOR EACH ROW EXECUTE FUNCTION "public"."auto_post_battle_result"();



CREATE OR REPLACE TRIGGER "trigger_auto_remove_verification" AFTER UPDATE OF "is_banned", "ban_expires_at" ON "public"."user_profiles" FOR EACH ROW WHEN ((("new"."is_banned" = true) AND ("new"."ban_expires_at" IS NULL))) EXECUTE FUNCTION "public"."auto_remove_verification_on_ban"();



CREATE OR REPLACE TRIGGER "trigger_auto_upgrade_influencer" AFTER UPDATE OF "is_verified" ON "public"."user_profiles" FOR EACH ROW WHEN (("new"."is_verified" = true)) EXECUTE FUNCTION "public"."auto_upgrade_influencer_tier"();



CREATE OR REPLACE TRIGGER "trigger_chargeback_ban" AFTER INSERT OR UPDATE OF "status" ON "public"."revenue_ledger" FOR EACH ROW EXECUTE FUNCTION "public"."handle_chargeback_ban"();



CREATE OR REPLACE TRIGGER "trigger_check_insurance_expiry" BEFORE INSERT OR UPDATE ON "public"."user_insurances" FOR EACH ROW EXECUTE FUNCTION "public"."check_insurance_expiry"();



CREATE OR REPLACE TRIGGER "trigger_check_perk_expiry" BEFORE INSERT OR UPDATE ON "public"."user_perks" FOR EACH ROW EXECUTE FUNCTION "public"."check_perk_expiry"();



CREATE OR REPLACE TRIGGER "trigger_creator_applications_updated_at" BEFORE UPDATE ON "public"."creator_applications" FOR EACH ROW EXECUTE FUNCTION "public"."update_creator_applications_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_hr_employees_updated_at" BEFORE UPDATE ON "public"."hr_employees" FOR EACH ROW EXECUTE FUNCTION "public"."update_hr_employees_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_interview_sessions_updated_at" BEFORE UPDATE ON "public"."interview_sessions" FOR EACH ROW EXECUTE FUNCTION "public"."update_interview_sessions_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_job_applications_updated_at" BEFORE UPDATE ON "public"."job_applications" FOR EACH ROW EXECUTE FUNCTION "public"."update_job_applications_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_notify_gift_received" AFTER INSERT ON "public"."gifts" FOR EACH ROW WHEN (("new"."receiver_id" IS NOT NULL)) EXECUTE FUNCTION "public"."notify_gift_received"();



CREATE OR REPLACE TRIGGER "trigger_notify_moderation_action" AFTER INSERT ON "public"."moderation_actions" FOR EACH ROW EXECUTE FUNCTION "public"."notify_moderation_action"();



CREATE OR REPLACE TRIGGER "trigger_notify_payout_status" AFTER UPDATE ON "public"."payout_requests" FOR EACH ROW EXECUTE FUNCTION "public"."notify_payout_status"();



CREATE OR REPLACE TRIGGER "trigger_payment_logs_updated_at" BEFORE UPDATE ON "public"."payment_logs" FOR EACH ROW EXECUTE FUNCTION "public"."update_payment_logs_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_payment_revenue_update" AFTER INSERT OR UPDATE OF "status" ON "public"."payment_logs" FOR EACH ROW EXECUTE FUNCTION "public"."update_platform_revenue_on_payment"();



CREATE OR REPLACE TRIGGER "trigger_set_updated_at" BEFORE UPDATE ON "public"."broadcaster_applications" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_stores_updated_at" BEFORE UPDATE ON "public"."stores" FOR EACH ROW EXECUTE FUNCTION "public"."update_stores_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_sync_troll_battle_broadcasters" BEFORE INSERT OR UPDATE ON "public"."troll_battles" FOR EACH ROW EXECUTE FUNCTION "public"."sync_troll_battle_broadcasters"();



CREATE OR REPLACE TRIGGER "trigger_sync_troll_role" BEFORE INSERT OR UPDATE ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."sync_troll_role"();



CREATE OR REPLACE TRIGGER "trigger_update_battle_coins" AFTER INSERT ON "public"."battle_gifts" FOR EACH ROW EXECUTE FUNCTION "public"."update_battle_coins"();



CREATE OR REPLACE TRIGGER "trigger_update_court_docket_updated_at" BEFORE UPDATE ON "public"."court_docket" FOR EACH ROW EXECUTE FUNCTION "public"."update_court_docket_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_officer_tier_badge" BEFORE INSERT OR UPDATE OF "officer_level" ON "public"."user_profiles" FOR EACH ROW WHEN ((("new"."is_troll_officer" = true) OR ("new"."role" = 'troll_officer'::"text"))) EXECUTE FUNCTION "public"."update_officer_tier_badge"();



CREATE OR REPLACE TRIGGER "update_applications_updated_at" BEFORE UPDATE ON "public"."applications" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_earnings_updated_at" BEFORE UPDATE ON "public"."earnings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_payouts_updated_at" BEFORE UPDATE ON "public"."payouts" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_post_comments_count" AFTER INSERT OR DELETE ON "public"."troll_post_comments" FOR EACH ROW EXECUTE FUNCTION "public"."update_post_engagement_counts"();



CREATE OR REPLACE TRIGGER "update_stream_coins_trigger" AFTER INSERT ON "public"."gifts" FOR EACH ROW EXECUTE FUNCTION "public"."update_stream_coins_from_gift"();



CREATE OR REPLACE TRIGGER "update_streams_updated_at" BEFORE UPDATE ON "public"."streams" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_user_agreements_updated_at" BEFORE UPDATE ON "public"."user_agreements" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_wall_posts_updated_at" BEFORE UPDATE ON "public"."wall_posts" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



ALTER TABLE ONLY "public"."abuse_reports"
    ADD CONSTRAINT "abuse_reports_offender_user_id_fkey" FOREIGN KEY ("offender_user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."abuse_reports"
    ADD CONSTRAINT "abuse_reports_reported_by_fkey" FOREIGN KEY ("reported_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."abuse_reports"
    ADD CONSTRAINT "abuse_reports_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id");



ALTER TABLE ONLY "public"."action_logs"
    ADD CONSTRAINT "action_logs_actor_id_fkey" FOREIGN KEY ("actor_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."active_sessions"
    ADD CONSTRAINT "active_sessions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."activity_logs"
    ADD CONSTRAINT "activity_logs_gifter_id_fkey" FOREIGN KEY ("gifter_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."activity_logs"
    ADD CONSTRAINT "activity_logs_receiver_id_fkey" FOREIGN KEY ("receiver_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."activity_logs"
    ADD CONSTRAINT "activity_logs_target_user_id_fkey" FOREIGN KEY ("target_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."activity_logs"
    ADD CONSTRAINT "activity_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."admin_adjustments"
    ADD CONSTRAINT "admin_adjustments_admin_id_fkey" FOREIGN KEY ("admin_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."admin_adjustments"
    ADD CONSTRAINT "admin_adjustments_target_user_id_fkey" FOREIGN KEY ("target_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."admin_coin_revenue"
    ADD CONSTRAINT "admin_coin_revenue_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."admin_flags"
    ADD CONSTRAINT "admin_flags_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."admin_gift_totals"
    ADD CONSTRAINT "admin_gift_totals_admin_id_fkey" FOREIGN KEY ("admin_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."admin_gift_totals"
    ADD CONSTRAINT "admin_gift_totals_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."admin_pool"
    ADD CONSTRAINT "admin_pool_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."admin_tax_reviews"
    ADD CONSTRAINT "admin_tax_reviews_reviewer_id_fkey" FOREIGN KEY ("reviewer_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."admin_tax_reviews"
    ADD CONSTRAINT "admin_tax_reviews_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."admin_top_buyers"
    ADD CONSTRAINT "admin_top_buyers_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."ai_action_logs"
    ADD CONSTRAINT "ai_action_logs_applied_by_fkey" FOREIGN KEY ("applied_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."ai_action_logs"
    ADD CONSTRAINT "ai_action_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."applications"
    ADD CONSTRAINT "applications_appeal_reviewed_by_fkey" FOREIGN KEY ("appeal_reviewed_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."applications"
    ADD CONSTRAINT "applications_lead_officer_reviewed_by_fkey" FOREIGN KEY ("lead_officer_reviewed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."applications"
    ADD CONSTRAINT "applications_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."applications"
    ADD CONSTRAINT "applications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."balance_ledger"
    ADD CONSTRAINT "balance_ledger_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."battle_gifts"
    ADD CONSTRAINT "battle_gifts_battle_id_fkey" FOREIGN KEY ("battle_id") REFERENCES "public"."troll_battles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."battle_gifts"
    ADD CONSTRAINT "battle_gifts_receiver_id_fkey" FOREIGN KEY ("receiver_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."battle_gifts"
    ADD CONSTRAINT "battle_gifts_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."battle_history"
    ADD CONSTRAINT "battle_history_battle_id_fkey" FOREIGN KEY ("battle_id") REFERENCES "public"."troll_battles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."battle_history"
    ADD CONSTRAINT "battle_history_opponent_id_fkey" FOREIGN KEY ("opponent_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."battle_history"
    ADD CONSTRAINT "battle_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."battle_rewards"
    ADD CONSTRAINT "battle_rewards_battle_id_fkey" FOREIGN KEY ("battle_id") REFERENCES "public"."troll_battles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."battle_rewards"
    ADD CONSTRAINT "battle_rewards_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."battle_sessions"
    ADD CONSTRAINT "battle_sessions_opponent_stream_id_fkey" FOREIGN KEY ("opponent_stream_id") REFERENCES "public"."streams"("id");



ALTER TABLE ONLY "public"."battle_sessions"
    ADD CONSTRAINT "battle_sessions_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."broadcast_cycle_stats"
    ADD CONSTRAINT "broadcast_cycle_stats_broadcaster_id_fkey" FOREIGN KEY ("broadcaster_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."broadcast_cycle_stats"
    ADD CONSTRAINT "broadcast_cycle_stats_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."broadcast_seats"
    ADD CONSTRAINT "broadcast_seats_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."broadcast_seats"
    ADD CONSTRAINT "broadcast_seats_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."broadcast_tokens"
    ADD CONSTRAINT "broadcast_tokens_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."broadcast_tokens"
    ADD CONSTRAINT "broadcast_tokens_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."broadcaster_applications"
    ADD CONSTRAINT "broadcaster_applications_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."broadcaster_applications"
    ADD CONSTRAINT "broadcaster_applications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."broadcaster_earnings"
    ADD CONSTRAINT "broadcaster_earnings_broadcaster_id_fkey" FOREIGN KEY ("broadcaster_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."call_history"
    ADD CONSTRAINT "call_history_caller_id_fkey" FOREIGN KEY ("caller_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."call_history"
    ADD CONSTRAINT "call_history_receiver_id_fkey" FOREIGN KEY ("receiver_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."call_minutes"
    ADD CONSTRAINT "call_minutes_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."case_audit_logs"
    ADD CONSTRAINT "case_audit_logs_actor_id_fkey" FOREIGN KEY ("actor_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."case_audit_logs"
    ADD CONSTRAINT "case_audit_logs_case_id_fkey" FOREIGN KEY ("case_id") REFERENCES "public"."court_cases"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."case_evidence"
    ADD CONSTRAINT "case_evidence_case_id_fkey" FOREIGN KEY ("case_id") REFERENCES "public"."court_cases"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."case_evidence"
    ADD CONSTRAINT "case_evidence_uploader_id_fkey" FOREIGN KEY ("uploader_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."case_evidence"
    ADD CONSTRAINT "case_evidence_verified_by_fkey" FOREIGN KEY ("verified_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."case_participants"
    ADD CONSTRAINT "case_participants_case_id_fkey" FOREIGN KEY ("case_id") REFERENCES "public"."court_cases"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."case_participants"
    ADD CONSTRAINT "case_participants_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."cashout_requests"
    ADD CONSTRAINT "cashout_requests_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("user_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."city_events"
    ADD CONSTRAINT "city_events_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."clan_rewards"
    ADD CONSTRAINT "clan_rewards_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."clan_vault"
    ADD CONSTRAINT "clan_vault_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."coinback_log"
    ADD CONSTRAINT "coinback_log_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."conversation_members"
    ADD CONSTRAINT "conversation_members_conversation_id_fkey" FOREIGN KEY ("conversation_id") REFERENCES "public"."conversations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."conversation_members"
    ADD CONSTRAINT "conversation_members_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."conversation_messages"
    ADD CONSTRAINT "conversation_messages_conversation_id_fkey" FOREIGN KEY ("conversation_id") REFERENCES "public"."conversations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."conversation_messages"
    ADD CONSTRAINT "conversation_messages_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."conversations"
    ADD CONSTRAINT "conversations_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."court_box_members"
    ADD CONSTRAINT "court_box_members_session_id_fkey" FOREIGN KEY ("session_id") REFERENCES "public"."court_sessions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."court_box_members"
    ADD CONSTRAINT "court_box_members_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."court_cases"
    ADD CONSTRAINT "court_cases_accuser_fkey" FOREIGN KEY ("accuser") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."court_cases"
    ADD CONSTRAINT "court_cases_defendant_fkey" FOREIGN KEY ("defendant") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."court_cases"
    ADD CONSTRAINT "court_cases_defendant_id_fkey" FOREIGN KEY ("defendant_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."court_cases"
    ADD CONSTRAINT "court_cases_judge_id_fkey" FOREIGN KEY ("judge_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."court_cases"
    ADD CONSTRAINT "court_cases_plaintiff_id_fkey" FOREIGN KEY ("plaintiff_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."court_docket"
    ADD CONSTRAINT "court_docket_assigned_officer_fkey" FOREIGN KEY ("assigned_officer") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."court_docket"
    ADD CONSTRAINT "court_docket_court_session_id_fkey" FOREIGN KEY ("court_session_id") REFERENCES "public"."court_sessions"("id");



ALTER TABLE ONLY "public"."court_docket"
    ADD CONSTRAINT "court_docket_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."court_rulings_archive"
    ADD CONSTRAINT "court_rulings_archive_appealed_ruling_id_fkey" FOREIGN KEY ("appealed_ruling_id") REFERENCES "public"."court_rulings_archive"("id");



ALTER TABLE ONLY "public"."court_rulings_archive"
    ADD CONSTRAINT "court_rulings_archive_court_session_id_fkey" FOREIGN KEY ("court_session_id") REFERENCES "public"."court_sessions"("id");



ALTER TABLE ONLY "public"."court_sessions"
    ADD CONSTRAINT "court_sessions_accuser_id_fkey" FOREIGN KEY ("accuser_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."court_sessions"
    ADD CONSTRAINT "court_sessions_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."court_sessions"
    ADD CONSTRAINT "court_sessions_defendant_id_fkey" FOREIGN KEY ("defendant_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."court_sessions"
    ADD CONSTRAINT "court_sessions_judge_id_fkey" FOREIGN KEY ("judge_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."court_sessions"
    ADD CONSTRAINT "court_sessions_started_by_fkey" FOREIGN KEY ("started_by") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."court_sessions"
    ADD CONSTRAINT "court_sessions_summons_id_fkey" FOREIGN KEY ("summons_id") REFERENCES "public"."court_summons"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."court_summons"
    ADD CONSTRAINT "court_summons_accuser_id_fkey" FOREIGN KEY ("accuser_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."court_summons"
    ADD CONSTRAINT "court_summons_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."court_summons"
    ADD CONSTRAINT "court_summons_defendant_id_fkey" FOREIGN KEY ("defendant_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."court_summons"
    ADD CONSTRAINT "court_summons_incident_id_fkey" FOREIGN KEY ("incident_id") REFERENCES "public"."mai_incidents"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."court_summons"
    ADD CONSTRAINT "court_summons_judge_id_fkey" FOREIGN KEY ("judge_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."court_summons"
    ADD CONSTRAINT "court_summons_summoned_user_id_fkey" FOREIGN KEY ("summoned_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."creator_applications"
    ADD CONSTRAINT "creator_applications_reviewer_id_fkey" FOREIGN KEY ("reviewer_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."creator_applications"
    ADD CONSTRAINT "creator_applications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."creator_migration_claims"
    ADD CONSTRAINT "creator_migration_claims_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."creator_migration_claims"
    ADD CONSTRAINT "creator_migration_claims_verified_by_fkey" FOREIGN KEY ("verified_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."creators_over_600"
    ADD CONSTRAINT "creators_over_600_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."critical_alerts"
    ADD CONSTRAINT "critical_alerts_resolved_by_fkey" FOREIGN KEY ("resolved_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."daily_giveaways"
    ADD CONSTRAINT "daily_giveaways_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."daily_logins"
    ADD CONSTRAINT "daily_logins_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."declined_transactions"
    ADD CONSTRAINT "declined_transactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."deed_transfers"
    ADD CONSTRAINT "deed_transfers_deed_id_fkey" FOREIGN KEY ("deed_id") REFERENCES "public"."deeds"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."deed_transfers"
    ADD CONSTRAINT "deed_transfers_from_user_id_fkey" FOREIGN KEY ("from_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."deed_transfers"
    ADD CONSTRAINT "deed_transfers_to_user_id_fkey" FOREIGN KEY ("to_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."deeds"
    ADD CONSTRAINT "deeds_current_owner_user_id_fkey" FOREIGN KEY ("current_owner_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."deeds"
    ADD CONSTRAINT "deeds_owner_user_id_fkey" FOREIGN KEY ("owner_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."deeds"
    ADD CONSTRAINT "deeds_property_id_fkey" FOREIGN KEY ("property_id") REFERENCES "public"."properties"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."district_announcements"
    ADD CONSTRAINT "district_announcements_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."district_announcements"
    ADD CONSTRAINT "district_announcements_district_id_fkey" FOREIGN KEY ("district_id") REFERENCES "public"."city_districts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."district_features"
    ADD CONSTRAINT "district_features_district_id_fkey" FOREIGN KEY ("district_id") REFERENCES "public"."city_districts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."economy_abuse_flags"
    ADD CONSTRAINT "economy_abuse_flags_related_user_id_fkey" FOREIGN KEY ("related_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."economy_abuse_flags"
    ADD CONSTRAINT "economy_abuse_flags_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."economy_abuse_flags"
    ADD CONSTRAINT "economy_abuse_flags_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."empire_applications"
    ADD CONSTRAINT "empire_applications_applicant_id_fkey" FOREIGN KEY ("applicant_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."empire_applications"
    ADD CONSTRAINT "empire_applications_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."empire_applications"
    ADD CONSTRAINT "empire_applications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."empire_partner_rewards"
    ADD CONSTRAINT "empire_partner_rewards_referred_user_id_fkey" FOREIGN KEY ("referred_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."empire_partner_rewards"
    ADD CONSTRAINT "empire_partner_rewards_referrer_id_fkey" FOREIGN KEY ("referrer_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."empire_partners"
    ADD CONSTRAINT "empire_partners_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."escalation_reports"
    ADD CONSTRAINT "escalation_reports_escalated_by_fkey" FOREIGN KEY ("escalated_by") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."escalation_reports"
    ADD CONSTRAINT "escalation_reports_escalated_to_fkey" FOREIGN KEY ("escalated_to") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."escalation_reports"
    ADD CONSTRAINT "escalation_reports_original_report_id_fkey" FOREIGN KEY ("original_report_id") REFERENCES "public"."moderation_reports"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."event_participants"
    ADD CONSTRAINT "event_participants_event_id_fkey" FOREIGN KEY ("event_id") REFERENCES "public"."city_events"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."event_participants"
    ADD CONSTRAINT "event_participants_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."executive_intake"
    ADD CONSTRAINT "executive_intake_assigned_secretary_fkey" FOREIGN KEY ("assigned_secretary") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."executive_intake"
    ADD CONSTRAINT "executive_intake_submitted_by_fkey" FOREIGN KEY ("submitted_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."executive_reports"
    ADD CONSTRAINT "executive_reports_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."families"
    ADD CONSTRAINT "families_founder_id_fkey" FOREIGN KEY ("founder_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."family_activity_log"
    ADD CONSTRAINT "family_activity_log_actor_id_fkey" FOREIGN KEY ("actor_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."family_activity_log"
    ADD CONSTRAINT "family_activity_log_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."troll_families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_activity_log"
    ADD CONSTRAINT "family_activity_log_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_badges_earned"
    ADD CONSTRAINT "family_badges_earned_badge_id_fkey" FOREIGN KEY ("badge_id") REFERENCES "public"."badge_definitions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_badges_earned"
    ADD CONSTRAINT "family_badges_earned_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."troll_families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_boosts"
    ADD CONSTRAINT "family_boosts_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."troll_families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_invites"
    ADD CONSTRAINT "family_invites_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."troll_families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_lounge_messages"
    ADD CONSTRAINT "family_lounge_messages_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_lounge_messages"
    ADD CONSTRAINT "family_lounge_messages_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."family_members"
    ADD CONSTRAINT "family_members_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."troll_families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_members"
    ADD CONSTRAINT "family_members_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_shop_purchases"
    ADD CONSTRAINT "family_shop_purchases_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."troll_families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_shop_purchases"
    ADD CONSTRAINT "family_shop_purchases_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."family_shop_items"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."family_shop_purchases"
    ADD CONSTRAINT "family_shop_purchases_purchased_by_fkey" FOREIGN KEY ("purchased_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."family_stats"
    ADD CONSTRAINT "family_stats_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."troll_families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_tasks"
    ADD CONSTRAINT "family_tasks_assigned_to_fkey" FOREIGN KEY ("assigned_to") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_tasks"
    ADD CONSTRAINT "family_tasks_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_tasks"
    ADD CONSTRAINT "family_tasks_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."troll_families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_tasks_new"
    ADD CONSTRAINT "family_tasks_new_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_war_stats"
    ADD CONSTRAINT "family_war_stats_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."troll_families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_wars"
    ADD CONSTRAINT "family_wars_attacking_family_id_fkey" FOREIGN KEY ("attacking_family_id") REFERENCES "public"."families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_wars"
    ADD CONSTRAINT "family_wars_defending_family_id_fkey" FOREIGN KEY ("defending_family_id") REFERENCES "public"."families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."family_wars"
    ADD CONSTRAINT "family_wars_family_a_id_fkey" FOREIGN KEY ("family_a_id") REFERENCES "public"."troll_families"("id");



ALTER TABLE ONLY "public"."family_wars"
    ADD CONSTRAINT "family_wars_family_b_id_fkey" FOREIGN KEY ("family_b_id") REFERENCES "public"."troll_families"("id");



ALTER TABLE ONLY "public"."coin_transactions"
    ADD CONSTRAINT "fk_coin_user" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_perks"
    ADD CONSTRAINT "fk_user_perks_user_profiles" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ghost_presence_logs"
    ADD CONSTRAINT "ghost_presence_logs_officer_id_fkey" FOREIGN KEY ("officer_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ghost_presence_logs"
    ADD CONSTRAINT "ghost_presence_logs_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id");



ALTER TABLE ONLY "public"."gift_bonus_tracker"
    ADD CONSTRAINT "gift_bonus_tracker_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."gift_card_redemptions"
    ADD CONSTRAINT "gift_card_redemptions_gift_card_id_fkey" FOREIGN KEY ("gift_card_id") REFERENCES "public"."gift_cards"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."gift_card_redemptions"
    ADD CONSTRAINT "gift_card_redemptions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."gift_cards"
    ADD CONSTRAINT "gift_cards_redeemed_by_fkey" FOREIGN KEY ("redeemed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."gift_leaderboard_entries"
    ADD CONSTRAINT "gift_leaderboard_entries_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."troll_families"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."gift_leaderboard_entries"
    ADD CONSTRAINT "gift_leaderboard_entries_leaderboard_id_fkey" FOREIGN KEY ("leaderboard_id") REFERENCES "public"."gift_leaderboards"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."gift_leaderboard_entries"
    ADD CONSTRAINT "gift_leaderboard_entries_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."gift_xp_stats"
    ADD CONSTRAINT "gift_xp_stats_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."giftcard_fulfillments"
    ADD CONSTRAINT "giftcard_fulfillments_cashout_id_fkey" FOREIGN KEY ("cashout_id") REFERENCES "public"."cashout_requests"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."giftcard_fulfillments"
    ADD CONSTRAINT "giftcard_fulfillments_processed_by_fkey" FOREIGN KEY ("processed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."gifts_owned"
    ADD CONSTRAINT "gifts_owned_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."gifts"
    ADD CONSTRAINT "gifts_receiver_id_fkey" FOREIGN KEY ("receiver_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."gifts"
    ADD CONSTRAINT "gifts_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."gifts"
    ADD CONSTRAINT "gifts_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."home_feature_cycles"
    ADD CONSTRAINT "home_feature_cycles_winner_user_fk" FOREIGN KEY ("winner_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."home_feature_cycles"
    ADD CONSTRAINT "home_feature_cycles_winner_user_id_fkey" FOREIGN KEY ("winner_user_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."home_feature_spend"
    ADD CONSTRAINT "home_feature_spend_cycle_id_fkey" FOREIGN KEY ("cycle_id") REFERENCES "public"."home_feature_cycles"("id");



ALTER TABLE ONLY "public"."home_feature_spend"
    ADD CONSTRAINT "home_feature_spend_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."honorary_family_members"
    ADD CONSTRAINT "honorary_family_members_admin_id_fkey" FOREIGN KEY ("admin_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."honorary_family_members"
    ADD CONSTRAINT "honorary_family_members_assigned_by_fkey" FOREIGN KEY ("assigned_by") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."honorary_family_members"
    ADD CONSTRAINT "honorary_family_members_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."hr_employees"
    ADD CONSTRAINT "hr_employees_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."hr_events"
    ADD CONSTRAINT "hr_events_performed_by_fkey" FOREIGN KEY ("performed_by") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."hr_events"
    ADD CONSTRAINT "hr_events_target_staff_id_fkey" FOREIGN KEY ("target_staff_id") REFERENCES "public"."staff_profiles"("staff_id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."hr_events"
    ADD CONSTRAINT "hr_events_target_user_id_fkey" FOREIGN KEY ("target_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."hr_notes"
    ADD CONSTRAINT "hr_notes_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."hr_notes"
    ADD CONSTRAINT "hr_notes_target_staff_id_fkey" FOREIGN KEY ("target_staff_id") REFERENCES "public"."staff_profiles"("staff_id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."hr_notes"
    ADD CONSTRAINT "hr_notes_target_user_id_fkey" FOREIGN KEY ("target_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."identity_reward_logs"
    ADD CONSTRAINT "identity_reward_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."insurance_logs"
    ADD CONSTRAINT "insurance_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."interview_sessions"
    ADD CONSTRAINT "interview_sessions_admin_id_fkey" FOREIGN KEY ("admin_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."interview_sessions"
    ADD CONSTRAINT "interview_sessions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ip_bans"
    ADD CONSTRAINT "ip_bans_banned_by_fkey" FOREIGN KEY ("banned_by") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."job_applications"
    ADD CONSTRAINT "job_applications_interview_id_fkey" FOREIGN KEY ("interview_id") REFERENCES "public"."interview_sessions"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."job_applications"
    ADD CONSTRAINT "job_applications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."kick_logs"
    ADD CONSTRAINT "kick_logs_kicked_by_user_id_fkey" FOREIGN KEY ("kicked_by_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."kick_logs"
    ADD CONSTRAINT "kick_logs_kicked_user_id_fkey" FOREIGN KEY ("kicked_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."kick_logs"
    ADD CONSTRAINT "kick_logs_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."lucky_coin_events"
    ADD CONSTRAINT "lucky_trollmond_events_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mai_appeals"
    ADD CONSTRAINT "mai_appeals_appellant_user_id_fkey" FOREIGN KEY ("appellant_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mai_appeals"
    ADD CONSTRAINT "mai_appeals_decided_by_fkey" FOREIGN KEY ("decided_by") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."mai_incidents"
    ADD CONSTRAINT "mai_incidents_host_user_id_fkey" FOREIGN KEY ("host_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."mai_incidents"
    ADD CONSTRAINT "mai_incidents_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."mai_overrides"
    ADD CONSTRAINT "mai_overrides_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."mai_timeline_events"
    ADD CONSTRAINT "mai_timeline_events_actor_user_id_fkey" FOREIGN KEY ("actor_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."mai_timeline_events"
    ADD CONSTRAINT "mai_timeline_events_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."mai_timeline_events"
    ADD CONSTRAINT "mai_timeline_events_target_user_id_fkey" FOREIGN KEY ("target_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."mai_user_memory"
    ADD CONSTRAINT "mai_user_memory_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."message_receipts"
    ADD CONSTRAINT "message_receipts_message_id_fkey" FOREIGN KEY ("message_id") REFERENCES "public"."conversation_messages"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."message_receipts"
    ADD CONSTRAINT "message_receipts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."message_requests"
    ADD CONSTRAINT "message_requests_receiver_id_fkey" FOREIGN KEY ("receiver_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."message_requests"
    ADD CONSTRAINT "message_requests_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_receiver_id_fkey" FOREIGN KEY ("receiver_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."millionaire_hall_of_fame"
    ADD CONSTRAINT "millionaire_hall_of_fame_receiver_id_fkey" FOREIGN KEY ("receiver_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."millionaire_hall_of_fame"
    ADD CONSTRAINT "millionaire_hall_of_fame_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."moderation_actions"
    ADD CONSTRAINT "moderation_actions_actor_id_fkey" FOREIGN KEY ("actor_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."moderation_actions"
    ADD CONSTRAINT "moderation_actions_report_id_fkey" FOREIGN KEY ("report_id") REFERENCES "public"."moderation_reports"("id");



ALTER TABLE ONLY "public"."moderation_actions"
    ADD CONSTRAINT "moderation_actions_target_user_id_fkey" FOREIGN KEY ("target_user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."moderation_events"
    ADD CONSTRAINT "moderation_events_officer_id_fkey" FOREIGN KEY ("officer_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."moderation_events"
    ADD CONSTRAINT "moderation_events_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."moderation_events"
    ADD CONSTRAINT "moderation_events_target_user_id_fkey" FOREIGN KEY ("target_user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."moderation_fee_settings"
    ADD CONSTRAINT "moderation_fee_settings_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."moderation_reports"
    ADD CONSTRAINT "moderation_reports_reported_user_id_fkey" FOREIGN KEY ("reported_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."moderation_reports"
    ADD CONSTRAINT "moderation_reports_reporter_id_fkey" FOREIGN KEY ("reporter_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."moderation_reports"
    ADD CONSTRAINT "moderation_reports_resolved_by_fkey" FOREIGN KEY ("resolved_by") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."moderation_reports"
    ADD CONSTRAINT "moderation_reports_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."observer_ratings"
    ADD CONSTRAINT "observer_ratings_event_id_fkey" FOREIGN KEY ("event_id") REFERENCES "public"."moderation_events"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_actions"
    ADD CONSTRAINT "officer_actions_officer_id_fkey" FOREIGN KEY ("officer_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_actions"
    ADD CONSTRAINT "officer_actions_target_user_id_fkey" FOREIGN KEY ("target_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_badges"
    ADD CONSTRAINT "officer_badges_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_chat_messages"
    ADD CONSTRAINT "officer_chat_messages_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."officer_earnings"
    ADD CONSTRAINT "officer_earnings_action_id_fkey" FOREIGN KEY ("action_id") REFERENCES "public"."officer_actions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_earnings"
    ADD CONSTRAINT "officer_earnings_officer_id_fkey" FOREIGN KEY ("officer_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_live_assignments"
    ADD CONSTRAINT "officer_live_assignments_officer_id_fkey" FOREIGN KEY ("officer_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_live_assignments"
    ADD CONSTRAINT "officer_live_assignments_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_mission_logs"
    ADD CONSTRAINT "officer_mission_logs_officer_id_fkey" FOREIGN KEY ("officer_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_orientation_results"
    ADD CONSTRAINT "officer_orientation_results_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_orientations"
    ADD CONSTRAINT "officer_orientations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_payouts"
    ADD CONSTRAINT "officer_payouts_admin_id_fkey" FOREIGN KEY ("admin_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."officer_payouts"
    ADD CONSTRAINT "officer_payouts_officer_id_fkey" FOREIGN KEY ("officer_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_payouts"
    ADD CONSTRAINT "officer_payouts_shift_log_id_fkey" FOREIGN KEY ("shift_log_id") REFERENCES "public"."officer_shift_logs"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."officer_performance"
    ADD CONSTRAINT "officer_performance_officer_id_fkey" FOREIGN KEY ("officer_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_quiz_attempts"
    ADD CONSTRAINT "officer_quiz_attempts_orientation_id_fkey" FOREIGN KEY ("orientation_id") REFERENCES "public"."officer_orientations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_quiz_attempts"
    ADD CONSTRAINT "officer_quiz_attempts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."officer_quiz_results"
    ADD CONSTRAINT "officer_quiz_results_officer_id_fkey" FOREIGN KEY ("officer_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_quiz_results"
    ADD CONSTRAINT "officer_quiz_results_question_id_fkey" FOREIGN KEY ("question_id") REFERENCES "public"."officer_quiz_questions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_shift_logs"
    ADD CONSTRAINT "officer_shift_logs_officer_id_fkey" FOREIGN KEY ("officer_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_shift_logs"
    ADD CONSTRAINT "officer_shift_logs_shift_slot_id_fkey" FOREIGN KEY ("shift_slot_id") REFERENCES "public"."officer_shift_slots"("id");



ALTER TABLE ONLY "public"."officer_shift_slots"
    ADD CONSTRAINT "officer_shift_slots_officer_id_fkey" FOREIGN KEY ("officer_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."officer_stream_logs"
    ADD CONSTRAINT "officer_stream_logs_officer_id_fkey" FOREIGN KEY ("officer_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_stream_logs"
    ADD CONSTRAINT "officer_stream_logs_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_training_sessions"
    ADD CONSTRAINT "officer_training_sessions_officer_id_fkey" FOREIGN KEY ("officer_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."officer_training_sessions"
    ADD CONSTRAINT "officer_training_sessions_scenario_id_fkey" FOREIGN KEY ("scenario_id") REFERENCES "public"."training_scenarios"("id");



ALTER TABLE ONLY "public"."officer_weekly_reports"
    ADD CONSTRAINT "officer_weekly_reports_lead_officer_id_fkey" FOREIGN KEY ("lead_officer_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."officer_work_sessions"
    ADD CONSTRAINT "officer_work_sessions_officer_id_fkey" FOREIGN KEY ("officer_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."officer_work_sessions"
    ADD CONSTRAINT "officer_work_sessions_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."onboarding_events"
    ADD CONSTRAINT "onboarding_events_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."onboarding_progress"
    ADD CONSTRAINT "onboarding_progress_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."owc_transactions"
    ADD CONSTRAINT "owc_transactions_session_id_fkey" FOREIGN KEY ("session_id") REFERENCES "public"."officer_work_sessions"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."owc_transactions"
    ADD CONSTRAINT "owc_transactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payment_fees"
    ADD CONSTRAINT "payment_fees_revenue_id_fkey" FOREIGN KEY ("revenue_id") REFERENCES "public"."revenue_ledger"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payment_holds"
    ADD CONSTRAINT "payment_holds_placed_by_fkey" FOREIGN KEY ("placed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."payment_holds"
    ADD CONSTRAINT "payment_holds_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payment_logs"
    ADD CONSTRAINT "payment_logs_package_id_fkey" FOREIGN KEY ("package_id") REFERENCES "public"."coin_packages"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."payment_logs"
    ADD CONSTRAINT "payment_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payment_methods"
    ADD CONSTRAINT "payment_methods_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "payment_transactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payout_audit_log"
    ADD CONSTRAINT "payout_audit_log_payout_request_id_fkey" FOREIGN KEY ("payout_request_id") REFERENCES "public"."payout_requests"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payout_audit_log"
    ADD CONSTRAINT "payout_audit_log_processed_by_fkey" FOREIGN KEY ("processed_by") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."payout_requests"
    ADD CONSTRAINT "payout_requests_admin_id_fkey" FOREIGN KEY ("admin_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."payout_requests"
    ADD CONSTRAINT "payout_requests_processed_by_fkey" FOREIGN KEY ("processed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."payout_requests"
    ADD CONSTRAINT "payout_requests_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payout_requests"
    ADD CONSTRAINT "payout_requests_user_profiles_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("user_id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."payout_settings"
    ADD CONSTRAINT "payout_settings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."post_gifts"
    ADD CONSTRAINT "post_gifts_post_id_fkey" FOREIGN KEY ("post_id") REFERENCES "public"."posts"("id");



ALTER TABLE ONLY "public"."post_gifts"
    ADD CONSTRAINT "post_gifts_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."posts"
    ADD CONSTRAINT "posts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_auth_user_id_fkey" FOREIGN KEY ("auth_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_recruiter_id_fkey" FOREIGN KEY ("recruiter_id") REFERENCES "public"."profiles"("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."promo_code_uses"
    ADD CONSTRAINT "promo_code_uses_promo_code_id_fkey" FOREIGN KEY ("promo_code_id") REFERENCES "public"."promo_codes"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."promo_code_uses"
    ADD CONSTRAINT "promo_code_uses_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."properties"
    ADD CONSTRAINT "properties_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."properties"
    ADD CONSTRAINT "properties_owner_user_id_fkey" FOREIGN KEY ("owner_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."property_upgrades"
    ADD CONSTRAINT "property_upgrades_owner_user_id_fkey" FOREIGN KEY ("owner_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."property_upgrades"
    ADD CONSTRAINT "property_upgrades_property_id_fkey" FOREIGN KEY ("property_id") REFERENCES "public"."properties"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."punishment_transactions"
    ADD CONSTRAINT "punishment_transactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."referral_claims"
    ADD CONSTRAINT "referral_claims_referred_user_id_fkey" FOREIGN KEY ("referred_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."referral_claims"
    ADD CONSTRAINT "referral_claims_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."referral_monthly_bonus"
    ADD CONSTRAINT "referral_monthly_bonus_recruiter_id_fkey" FOREIGN KEY ("recruiter_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."referral_monthly_bonus"
    ADD CONSTRAINT "referral_monthly_bonus_referred_user_id_fkey" FOREIGN KEY ("referred_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."referrals"
    ADD CONSTRAINT "referrals_recruiter_id_fkey" FOREIGN KEY ("recruiter_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."referrals"
    ADD CONSTRAINT "referrals_referred_user_id_fkey" FOREIGN KEY ("referred_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."referrals"
    ADD CONSTRAINT "referrals_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."reputation_events"
    ADD CONSTRAINT "reputation_events_triggered_by_fkey" FOREIGN KEY ("triggered_by") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."risk_events"
    ADD CONSTRAINT "risk_events_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."royal_family_history"
    ADD CONSTRAINT "royal_family_history_admin_id_fkey" FOREIGN KEY ("admin_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."royal_family_history"
    ADD CONSTRAINT "royal_family_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."royal_family_perks"
    ADD CONSTRAINT "royal_family_perks_title_id_fkey" FOREIGN KEY ("title_id") REFERENCES "public"."royal_family_titles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."royal_family_titles"
    ADD CONSTRAINT "royal_family_titles_admin_id_fkey" FOREIGN KEY ("admin_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."royal_family_titles"
    ADD CONSTRAINT "royal_family_titles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."scheduled_announcements"
    ADD CONSTRAINT "scheduled_announcements_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."secretary_assignments"
    ADD CONSTRAINT "secretary_assignments_assigned_by_fkey" FOREIGN KEY ("assigned_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."secretary_assignments"
    ADD CONSTRAINT "secretary_assignments_secretary_id_fkey" FOREIGN KEY ("secretary_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."security_events"
    ADD CONSTRAINT "security_events_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."seller_reliability"
    ADD CONSTRAINT "seller_reliability_seller_id_fkey" FOREIGN KEY ("seller_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."shadow_bans"
    ADD CONSTRAINT "shadow_bans_officer_id_fkey" FOREIGN KEY ("officer_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."shadow_bans"
    ADD CONSTRAINT "shadow_bans_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id");



ALTER TABLE ONLY "public"."shadow_bans"
    ADD CONSTRAINT "shadow_bans_target_user_id_fkey" FOREIGN KEY ("target_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."shop_transactions"
    ADD CONSTRAINT "shop_transactions_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."inventory_items"("id");



ALTER TABLE ONLY "public"."shop_transactions"
    ADD CONSTRAINT "shop_transactions_shop_fk" FOREIGN KEY ("shop_id") REFERENCES "public"."shops"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."shop_transactions"
    ADD CONSTRAINT "shop_transactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."shops"
    ADD CONSTRAINT "shops_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."staff_applications"
    ADD CONSTRAINT "staff_applications_reviewer_id_fkey" FOREIGN KEY ("reviewer_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."staff_applications"
    ADD CONSTRAINT "staff_applications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."staff_profiles"
    ADD CONSTRAINT "staff_profiles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."stores"
    ADD CONSTRAINT "stores_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_discovery_prefs"
    ADD CONSTRAINT "stream_discovery_prefs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_entrances"
    ADD CONSTRAINT "stream_entrances_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id");



ALTER TABLE ONLY "public"."stream_entrances"
    ADD CONSTRAINT "stream_entrances_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."stream_entries"
    ADD CONSTRAINT "stream_entries_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_events"
    ADD CONSTRAINT "stream_events_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_gifts"
    ADD CONSTRAINT "stream_gifts_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_join_requests"
    ADD CONSTRAINT "stream_join_requests_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_join_requests"
    ADD CONSTRAINT "stream_join_requests_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_likes"
    ADD CONSTRAINT "stream_likes_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_likes"
    ADD CONSTRAINT "stream_likes_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_messages"
    ADD CONSTRAINT "stream_messages_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_momentum"
    ADD CONSTRAINT "stream_momentum_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_mute_counts"
    ADD CONSTRAINT "stream_mute_counts_last_muted_by_fkey" FOREIGN KEY ("last_muted_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."stream_mute_counts"
    ADD CONSTRAINT "stream_mute_counts_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_mute_counts"
    ADD CONSTRAINT "stream_mute_counts_target_user_id_fkey" FOREIGN KEY ("target_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_participants"
    ADD CONSTRAINT "stream_participants_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_passwords"
    ADD CONSTRAINT "stream_passwords_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_presets"
    ADD CONSTRAINT "stream_presets_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_ranking"
    ADD CONSTRAINT "stream_ranking_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_reactions"
    ADD CONSTRAINT "stream_reactions_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_reactions"
    ADD CONSTRAINT "stream_reactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_reports"
    ADD CONSTRAINT "stream_reports_reporter_id_fkey" FOREIGN KEY ("reporter_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."stream_reports"
    ADD CONSTRAINT "stream_reports_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_snack_purchases"
    ADD CONSTRAINT "stream_snack_purchases_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_snack_purchases"
    ADD CONSTRAINT "stream_snack_purchases_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_viewers"
    ADD CONSTRAINT "stream_viewers_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_viewers"
    ADD CONSTRAINT "stream_viewers_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_vods"
    ADD CONSTRAINT "stream_vods_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."streams"
    ADD CONSTRAINT "streams_broadcaster_id_fkey" FOREIGN KEY ("broadcaster_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."streams"
    ADD CONSTRAINT "streams_host_user_id_fkey" FOREIGN KEY ("host_user_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."streams"
    ADD CONSTRAINT "streams_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."streams_participants"
    ADD CONSTRAINT "streams_participants_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."streams_participants"
    ADD CONSTRAINT "streams_participants_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."system_alerts"
    ADD CONSTRAINT "system_alerts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."system_errors"
    ADD CONSTRAINT "system_errors_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."task_completions"
    ADD CONSTRAINT "task_completions_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."task_completions"
    ADD CONSTRAINT "task_completions_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."family_tasks_new"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."task_completions"
    ADD CONSTRAINT "task_completions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."task_history"
    ADD CONSTRAINT "task_history_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."family_tasks"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."task_history"
    ADD CONSTRAINT "task_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."tax_report_status"
    ADD CONSTRAINT "tax_report_status_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ticket_messages"
    ADD CONSTRAINT "ticket_messages_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."ticket_messages"
    ADD CONSTRAINT "ticket_messages_ticket_id_fkey" FOREIGN KEY ("ticket_id") REFERENCES "public"."support_tickets"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."transactions"
    ADD CONSTRAINT "transactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_battle_gifts"
    ADD CONSTRAINT "troll_battle_gifts_battle_id_fkey" FOREIGN KEY ("battle_id") REFERENCES "public"."troll_battles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_battle_gifts"
    ADD CONSTRAINT "troll_battle_gifts_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_battles"
    ADD CONSTRAINT "troll_battles_broadcaster1_id_fkey" FOREIGN KEY ("broadcaster1_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."troll_battles"
    ADD CONSTRAINT "troll_battles_broadcaster2_id_fkey" FOREIGN KEY ("broadcaster2_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."troll_battles"
    ADD CONSTRAINT "troll_battles_challenger_id_fkey" FOREIGN KEY ("challenger_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."troll_battles"
    ADD CONSTRAINT "troll_battles_host_id_fkey" FOREIGN KEY ("host_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."troll_battles"
    ADD CONSTRAINT "troll_battles_winner_id_fkey" FOREIGN KEY ("winner_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."troll_court_cases"
    ADD CONSTRAINT "troll_court_cases_assigned_judge_id_fkey" FOREIGN KEY ("assigned_judge_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."troll_court_cases"
    ADD CONSTRAINT "troll_court_cases_defendant_id_fkey" FOREIGN KEY ("defendant_id") REFERENCES "public"."profiles"("id");



ALTER TABLE ONLY "public"."troll_court_cases"
    ADD CONSTRAINT "troll_court_cases_plaintiff_id_fkey" FOREIGN KEY ("plaintiff_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."troll_dna_events"
    ADD CONSTRAINT "troll_dna_events_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_dna_profiles"
    ADD CONSTRAINT "troll_dna_profiles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."troll_drops_log"
    ADD CONSTRAINT "troll_drops_log_broadcaster_id_fkey" FOREIGN KEY ("broadcaster_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_drops_log"
    ADD CONSTRAINT "troll_drops_log_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_drops"
    ADD CONSTRAINT "troll_drops_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."troll_drops"
    ADD CONSTRAINT "troll_drops_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_event_claims"
    ADD CONSTRAINT "troll_event_claims_event_id_fkey" FOREIGN KEY ("event_id") REFERENCES "public"."troll_events"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_event_claims"
    ADD CONSTRAINT "troll_event_claims_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_families"
    ADD CONSTRAINT "troll_families_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."troll_family_members"
    ADD CONSTRAINT "troll_family_members_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."troll_families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_family_members"
    ADD CONSTRAINT "troll_family_members_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_family_messages"
    ADD CONSTRAINT "troll_family_messages_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."troll_families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_family_messages"
    ADD CONSTRAINT "troll_family_messages_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "public"."user_profiles"("id");



ALTER TABLE ONLY "public"."troll_family_wars"
    ADD CONSTRAINT "troll_family_wars_challenger_family_id_fkey" FOREIGN KEY ("challenger_family_id") REFERENCES "public"."troll_families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_family_wars"
    ADD CONSTRAINT "troll_family_wars_defender_family_id_fkey" FOREIGN KEY ("defender_family_id") REFERENCES "public"."troll_families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_officer_applications"
    ADD CONSTRAINT "troll_officer_applications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_officers"
    ADD CONSTRAINT "troll_officers_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_post_comments"
    ADD CONSTRAINT "troll_post_comments_post_id_fkey" FOREIGN KEY ("post_id") REFERENCES "public"."troll_posts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_post_comments"
    ADD CONSTRAINT "troll_post_comments_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_post_gifts"
    ADD CONSTRAINT "troll_post_gifts_post_id_fkey" FOREIGN KEY ("post_id") REFERENCES "public"."troll_posts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_post_gifts"
    ADD CONSTRAINT "troll_post_gifts_receiver_id_fkey" FOREIGN KEY ("receiver_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_post_gifts"
    ADD CONSTRAINT "troll_post_gifts_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_post_reactions"
    ADD CONSTRAINT "troll_post_reactions_post_id_fkey" FOREIGN KEY ("post_id") REFERENCES "public"."troll_posts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_post_reactions"
    ADD CONSTRAINT "troll_post_reactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_post_views"
    ADD CONSTRAINT "troll_post_views_post_id_fkey" FOREIGN KEY ("post_id") REFERENCES "public"."troll_posts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_post_views"
    ADD CONSTRAINT "troll_post_views_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."troll_posts"
    ADD CONSTRAINT "troll_posts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_stream_messages"
    ADD CONSTRAINT "troll_stream_messages_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."troll_streams"("id");



ALTER TABLE ONLY "public"."troll_stream_messages"
    ADD CONSTRAINT "troll_stream_messages_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."troll_streams"
    ADD CONSTRAINT "troll_streams_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."troll_wall_gifts"
    ADD CONSTRAINT "troll_wall_gifts_post_id_fkey" FOREIGN KEY ("post_id") REFERENCES "public"."troll_wall_posts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_wall_gifts"
    ADD CONSTRAINT "troll_wall_gifts_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_wall_likes"
    ADD CONSTRAINT "troll_wall_likes_post_id_fkey" FOREIGN KEY ("post_id") REFERENCES "public"."troll_wall_posts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_wall_likes"
    ADD CONSTRAINT "troll_wall_likes_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_wall_posts"
    ADD CONSTRAINT "troll_wall_posts_reply_to_post_id_fkey" FOREIGN KEY ("reply_to_post_id") REFERENCES "public"."troll_wall_posts"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."troll_wall_posts"
    ADD CONSTRAINT "troll_wall_posts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_wall_reactions"
    ADD CONSTRAINT "troll_wall_reactions_post_id_fkey" FOREIGN KEY ("post_id") REFERENCES "public"."troll_wall_posts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."troll_wall_reactions"
    ADD CONSTRAINT "troll_wall_reactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trollcity_orders"
    ADD CONSTRAINT "trollcity_orders_buyer_id_fkey" FOREIGN KEY ("buyer_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trollcity_orders"
    ADD CONSTRAINT "trollcity_orders_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."trollcity_products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trollcity_orders"
    ADD CONSTRAINT "trollcity_orders_shop_id_fkey" FOREIGN KEY ("shop_id") REFERENCES "public"."trollcity_shops"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trollcity_products"
    ADD CONSTRAINT "trollcity_products_shop_id_fkey" FOREIGN KEY ("shop_id") REFERENCES "public"."trollcity_shops"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trollcity_shops"
    ADD CONSTRAINT "trollcity_shops_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trollmond_transactions"
    ADD CONSTRAINT "trollmond_transactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."coin_pool_contributions"
    ADD CONSTRAINT "trollmonds_pool_contributions_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."coin_pool_contributions"
    ADD CONSTRAINT "trollmonds_pool_contributions_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trollmonds_pools"
    ADD CONSTRAINT "trollmonds_pools_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."streams"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trolls_night_applications"
    ADD CONSTRAINT "trolls_night_applications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trollstown_properties"
    ADD CONSTRAINT "trollstown_properties_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trollstown_property_upgrades"
    ADD CONSTRAINT "trollstown_property_upgrades_property_id_fkey" FOREIGN KEY ("property_id") REFERENCES "public"."trollstown_properties"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trollstown_property_upgrades"
    ADD CONSTRAINT "trollstown_property_upgrades_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trolltract_weekly_rewards"
    ADD CONSTRAINT "trolltract_weekly_rewards_contract_id_fkey" FOREIGN KEY ("contract_id") REFERENCES "public"."trolltract_contracts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."tromody_battles"
    ADD CONSTRAINT "tromody_battles_left_user_id_fkey" FOREIGN KEY ("left_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."tromody_battles"
    ADD CONSTRAINT "tromody_battles_right_user_id_fkey" FOREIGN KEY ("right_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."tromody_battles"
    ADD CONSTRAINT "tromody_battles_winner_user_id_fkey" FOREIGN KEY ("winner_user_id") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."tromody_gifts"
    ADD CONSTRAINT "tromody_gifts_session_id_fkey" FOREIGN KEY ("session_id") REFERENCES "public"."tromody_sessions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."tromody_matches"
    ADD CONSTRAINT "tromody_matches_player1_id_fkey" FOREIGN KEY ("player1_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."tromody_matches"
    ADD CONSTRAINT "tromody_matches_player2_id_fkey" FOREIGN KEY ("player2_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."tromody_matches"
    ADD CONSTRAINT "tromody_matches_winner_id_fkey" FOREIGN KEY ("winner_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."user_active_entrance_effect"
    ADD CONSTRAINT "user_active_entrance_effect_effect_id_fkey" FOREIGN KEY ("effect_id") REFERENCES "public"."entrance_effect_catalog"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_active_entrance_effect"
    ADD CONSTRAINT "user_active_entrance_effect_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_active_items"
    ADD CONSTRAINT "user_active_items_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_agreements"
    ADD CONSTRAINT "user_agreements_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_badges_earned"
    ADD CONSTRAINT "user_badges_earned_badge_id_fkey" FOREIGN KEY ("badge_id") REFERENCES "public"."badge_definitions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_badges_earned"
    ADD CONSTRAINT "user_badges_earned_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_balances"
    ADD CONSTRAINT "user_balances_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_bans"
    ADD CONSTRAINT "user_bans_banned_by_fkey" FOREIGN KEY ("banned_by") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_bans"
    ADD CONSTRAINT "user_bans_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_boosts"
    ADD CONSTRAINT "user_boosts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_broadcast_theme_purchases"
    ADD CONSTRAINT "user_broadcast_theme_purchases_theme_id_fkey" FOREIGN KEY ("theme_id") REFERENCES "public"."broadcast_background_themes"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_broadcast_theme_purchases"
    ADD CONSTRAINT "user_broadcast_theme_purchases_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_broadcast_theme_state"
    ADD CONSTRAINT "user_broadcast_theme_state_active_theme_id_fkey" FOREIGN KEY ("active_theme_id") REFERENCES "public"."broadcast_background_themes"("id");



ALTER TABLE ONLY "public"."user_broadcast_theme_state"
    ADD CONSTRAINT "user_broadcast_theme_state_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_call_sounds"
    ADD CONSTRAINT "user_call_sounds_sound_id_fkey" FOREIGN KEY ("sound_id") REFERENCES "public"."call_sound_catalog"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_call_sounds"
    ADD CONSTRAINT "user_call_sounds_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_district_progress"
    ADD CONSTRAINT "user_district_progress_district_id_fkey" FOREIGN KEY ("district_id") REFERENCES "public"."city_districts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_district_progress"
    ADD CONSTRAINT "user_district_progress_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_entrance_effects"
    ADD CONSTRAINT "user_entrance_effects_effect_id_fkey" FOREIGN KEY ("effect_id") REFERENCES "public"."entrance_effects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_entrance_effects"
    ADD CONSTRAINT "user_entrance_effects_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_follows"
    ADD CONSTRAINT "user_follows_follower_id_fkey" FOREIGN KEY ("follower_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_follows"
    ADD CONSTRAINT "user_follows_following_id_fkey" FOREIGN KEY ("following_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_insurance"
    ADD CONSTRAINT "user_insurance_plan_id_fkey" FOREIGN KEY ("plan_id") REFERENCES "public"."insurance_plans"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_insurance"
    ADD CONSTRAINT "user_insurance_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_insurances"
    ADD CONSTRAINT "user_insurances_insurance_id_fkey" FOREIGN KEY ("insurance_id") REFERENCES "public"."insurance_options"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_insurances"
    ADD CONSTRAINT "user_insurances_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_inventory"
    ADD CONSTRAINT "user_inventory_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."inventory_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_inventory"
    ADD CONSTRAINT "user_inventory_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_ip_tracking"
    ADD CONSTRAINT "user_ip_tracking_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_notifications"
    ADD CONSTRAINT "user_notifications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_payout_settings"
    ADD CONSTRAINT "user_payout_settings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_perks"
    ADD CONSTRAINT "user_perks_perk_id_fkey" FOREIGN KEY ("perk_id") REFERENCES "public"."perks"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_perks"
    ADD CONSTRAINT "user_perks_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_reputation"
    ADD CONSTRAINT "user_reputation_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_risk_profile"
    ADD CONSTRAINT "user_risk_profile_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_streamer_entitlements"
    ADD CONSTRAINT "user_streamer_entitlements_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_tax_info"
    ADD CONSTRAINT "user_tax_info_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."verification_requests"
    ADD CONSTRAINT "verification_requests_admin_reviewer_fkey" FOREIGN KEY ("admin_reviewer") REFERENCES "public"."user_profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."verification_requests"
    ADD CONSTRAINT "verification_requests_duplicate_of_id_fkey" FOREIGN KEY ("duplicate_of_id") REFERENCES "public"."verification_requests"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."verification_requests"
    ADD CONSTRAINT "verification_requests_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."verification_transactions"
    ADD CONSTRAINT "verification_transactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."visa_redemptions"
    ADD CONSTRAINT "visa_redemptions_fulfilled_by_fkey" FOREIGN KEY ("fulfilled_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."visa_redemptions"
    ADD CONSTRAINT "visa_redemptions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."war_results"
    ADD CONSTRAINT "war_results_family_id_fkey" FOREIGN KEY ("family_id") REFERENCES "public"."families"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."war_results"
    ADD CONSTRAINT "war_results_war_id_fkey" FOREIGN KEY ("war_id") REFERENCES "public"."wars"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."web_push_subscriptions"
    ADD CONSTRAINT "web_push_subscriptions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."weekly_officer_reports"
    ADD CONSTRAINT "weekly_officer_reports_lead_officer_id_fkey" FOREIGN KEY ("lead_officer_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."wheel_spins"
    ADD CONSTRAINT "wheel_spins_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE;



CREATE POLICY "Admin can manage secretaries" ON "public"."secretary_assignments" TO "authenticated" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



CREATE POLICY "Admin can read revenue settings" ON "public"."revenue_settings" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admin can update coins" ON "public"."user_profiles" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") AND ("is_admin" = true))) WITH CHECK ((("auth"."uid"() = "user_id") AND ("is_admin" = true)));



CREATE POLICY "Admin can view all earnings" ON "public"."broadcaster_earnings" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admin can view all executive reports" ON "public"."executive_reports" FOR SELECT TO "authenticated" USING ("public"."is_admin"());



CREATE POLICY "Admin can view all intake" ON "public"."executive_intake" FOR SELECT TO "authenticated" USING ("public"."is_admin"());



CREATE POLICY "Admin can view all risk profiles" ON "public"."user_risk_profile" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admin can view all wheel spins" ON "public"."wheel_spins" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admin can view square events" ON "public"."square_events" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admin/Secretary can delete redemptions" ON "public"."gift_card_redemptions" FOR DELETE TO "authenticated" USING ("public"."is_admin_or_secretary"());



CREATE POLICY "Admin/Secretary can update redemptions" ON "public"."gift_card_redemptions" FOR UPDATE TO "authenticated" USING ("public"."is_admin_or_secretary"()) WITH CHECK ("public"."is_admin_or_secretary"());



CREATE POLICY "Admin/Secretary can view all redemption requests" ON "public"."gift_card_redemptions" FOR SELECT TO "authenticated" USING ("public"."is_admin_or_secretary"());



CREATE POLICY "Admins and lead officers can view all orientation results" ON "public"."officer_orientation_results" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_lead_officer" = true))))));



CREATE POLICY "Admins and officers can delete any post" ON "public"."troll_posts" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'troll_officer'::"text"]))))));



CREATE POLICY "Admins and officers can manage announcements" ON "public"."district_announcements" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'officer'::"text"]))))));



CREATE POLICY "Admins and officers can view all kick logs" ON "public"."kick_logs" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."is_admin" = true) OR ("user_profiles"."is_troll_officer" = true))))));



CREATE POLICY "Admins can add ticket messages" ON "public"."ticket_messages" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can create bans" ON "public"."user_bans" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'moderator'::"text"]))))));



CREATE POLICY "Admins can delete any wall post" ON "public"."troll_wall_posts" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."is_admin" = true) OR ("user_profiles"."role" = 'admin'::"text"))))));



CREATE POLICY "Admins can insert payout settings" ON "public"."payout_settings" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'lead_officer'::"text"]))))));



CREATE POLICY "Admins can manage all applications" ON "public"."empire_applications" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can manage all hr events" ON "public"."hr_events" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true)))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true))))));



CREATE POLICY "Admins can manage all hr notes" ON "public"."hr_notes" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true)))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true))))));



CREATE POLICY "Admins can manage all momentum" ON "public"."stream_momentum" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can manage all staff applications" ON "public"."staff_applications" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true)))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true))))));



CREATE POLICY "Admins can manage all staff profiles" ON "public"."staff_profiles" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true)))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true))))));



CREATE POLICY "Admins can manage bonus claims" ON "public"."referral_monthly_bonus" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can manage district features" ON "public"."district_features" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can manage districts" ON "public"."city_districts" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can manage quiz questions" ON "public"."officer_quiz_questions" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can manage revenue settings" ON "public"."revenue_settings" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can read payment_fees" ON "public"."payment_fees" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("up"."role" = 'admin'::"text") OR ("up"."is_admin" = true))))));



CREATE POLICY "Admins can read revenue_ledger" ON "public"."revenue_ledger" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("up"."role" = 'admin'::"text") OR ("up"."is_admin" = true))))));



CREATE POLICY "Admins can read troll drops log" ON "public"."troll_drops_log" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("up"."role" = 'admin'::"text") OR ("up"."is_admin" = true) OR ("up"."is_officer" = true))))));



CREATE POLICY "Admins can read trollmonds contributions" ON "public"."coin_pool_contributions" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("up"."role" = 'admin'::"text") OR ("up"."is_admin" = true) OR ("up"."is_officer" = true))))));



CREATE POLICY "Admins can read vendor_invoices" ON "public"."vendor_invoices" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("up"."role" = 'admin'::"text") OR ("up"."is_admin" = true))))));



CREATE POLICY "Admins can update all onboarding progress" ON "public"."onboarding_progress" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can update all tickets" ON "public"."support_tickets" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text"))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can update bans" ON "public"."user_bans" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'moderator'::"text"]))))));



CREATE POLICY "Admins can update cashout requests" ON "public"."cashout_requests" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can update config" ON "public"."config" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can update error logs" ON "public"."error_logs" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text"))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can update payout requests" ON "public"."payout_requests" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can update reports" ON "public"."stream_reports" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'moderator'::"text"]))))));



CREATE POLICY "Admins can update tax info" ON "public"."user_tax_info" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view action logs" ON "public"."action_logs" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view all AI logs" ON "public"."ai_action_logs" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'hr_admin'::"text"]))))));



CREATE POLICY "Admins can view all action logs" ON "public"."action_logs" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view all adjustments" ON "public"."admin_adjustments" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can view all agreements" ON "public"."user_agreements" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view all applications" ON "public"."applications" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_lead_officer" = true) OR ("user_profiles"."officer_role" = ANY (ARRAY['lead_officer'::"text", 'owner'::"text"])))))));



CREATE POLICY "Admins can view all applications" ON "public"."creator_applications" USING ((EXISTS ( SELECT 1
   FROM "public"."profiles"
  WHERE (("profiles"."id" = "auth"."uid"()) AND ("profiles"."role" = ANY (ARRAY['admin'::"text", 'officer'::"text"]))))));



CREATE POLICY "Admins can view all bans" ON "public"."user_bans" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'moderator'::"text"]))))));



CREATE POLICY "Admins can view all battles" ON "public"."tromody_battles" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can view all cashout requests" ON "public"."cashout_requests" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can view all config" ON "public"."config" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can view all error logs" ON "public"."error_logs" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can view all escalations" ON "public"."escalation_reports" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view all gift totals" ON "public"."admin_gift_totals" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can view all giveaways" ON "public"."daily_giveaways" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view all history" ON "public"."royal_family_history" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can view all hr events" ON "public"."hr_events" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true))))));



CREATE POLICY "Admins can view all hr notes" ON "public"."hr_notes" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true))))));



CREATE POLICY "Admins can view all lucky events" ON "public"."lucky_coin_events" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can view all officer payouts" ON "public"."officer_payouts" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view all onboarding events" ON "public"."onboarding_events" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view all onboarding progress" ON "public"."onboarding_progress" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view all orientations" ON "public"."officer_orientations" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view all payout requests" ON "public"."payout_requests" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can view all payouts" ON "public"."payouts" TO "authenticated" USING (((( SELECT "users"."email"
   FROM "auth"."users"
  WHERE ("users"."id" = ( SELECT "auth"."uid"() AS "uid"))))::"text" = 'trollcity2025@gmail.com'::"text"));



CREATE POLICY "Admins can view all perks" ON "public"."royal_family_perks" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can view all quiz attempts" ON "public"."officer_quiz_attempts" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view all reports" ON "public"."stream_reports" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'moderator'::"text"]))))));



CREATE POLICY "Admins can view all reports" ON "public"."weekly_officer_reports" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view all staff applications" ON "public"."staff_applications" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true))))));



CREATE POLICY "Admins can view all staff profiles" ON "public"."staff_profiles" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true))))));



CREATE POLICY "Admins can view all stores" ON "public"."stores" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'officer'::"text"]))))));



CREATE POLICY "Admins can view all tax info" ON "public"."user_tax_info" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view all ticket messages" ON "public"."ticket_messages" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view all tickets" ON "public"."support_tickets" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can view all training sessions" ON "public"."officer_training_sessions" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."troll_role" = 'admin'::"text"))))));



CREATE POLICY "Admins can view coin reward pool" ON "public"."coin_reward_pool" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("up"."role" = 'admin'::"text") OR ("up"."is_admin" = true))))));



CREATE POLICY "Admins can view contracts" ON "public"."trolltract_contracts" FOR SELECT TO "authenticated" USING ((COALESCE(("auth"."jwt"() ->> 'role'::"text"), ''::"text") = ANY (ARRAY['admin'::"text", 'lead_troll_officer'::"text", 'troll_officer'::"text"])));



CREATE POLICY "Admins can view declined transactions" ON "public"."declined_transactions" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins can view errors" ON "public"."system_errors" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view insurance logs" ON "public"."insurance_logs" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins can view referral bonuses" ON "public"."referral_monthly_bonus" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins manage family purchases" ON "public"."family_shop_purchases" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true)))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins manage family shop items" ON "public"."family_shop_items" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true)))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Admins only" ON "public"."provider_costs" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Admins write vendor_invoices" ON "public"."vendor_invoices" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("up"."role" = 'admin'::"text") OR ("up"."is_admin" = true)))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("up"."role" = 'admin'::"text") OR ("up"."is_admin" = true))))));



CREATE POLICY "Allow admins and lead officers to read payout audit logs" ON "public"."payout_audit_log" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."officer_role" = 'lead_officer'::"text"))))));



CREATE POLICY "Allow logged-in users to insert their own streams" ON "public"."streams" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Allow read access to broadcast seats" ON "public"."broadcast_seats" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Allow select for service role" ON "public"."user_ip_tracking" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."role"() AS "role") = 'service_role'::"text"));



CREATE POLICY "Allow service role full access to broadcast seats" ON "public"."broadcast_seats" TO "service_role" USING (true);



CREATE POLICY "Allow service role full access to payout audit logs" ON "public"."payout_audit_log" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Allow session management for authenticated users" ON "public"."active_sessions" TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Allow session reads for service role" ON "public"."active_sessions" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Allow streamer to manage troll drops" ON "public"."troll_drops" FOR UPDATE TO "authenticated" USING (("stream_id" IN ( SELECT "streams"."id"
   FROM "public"."streams"
  WHERE ("streams"."broadcaster_id" = ( SELECT "auth"."uid"() AS "uid")))));



CREATE POLICY "Allow user to delete own methods" ON "public"."user_payment_methods" FOR DELETE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Allow user to insert own methods" ON "public"."user_payment_methods" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Allow user to view own methods" ON "public"."user_payment_methods" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Allow users to insert their own properties" ON "public"."trollstown_properties" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Allow users to insert their own property upgrades" ON "public"."trollstown_property_upgrades" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Allow users to update their own properties" ON "public"."trollstown_properties" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id")) WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Allow users to update their own property upgrades" ON "public"."trollstown_property_upgrades" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id")) WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Allow users to view their own properties" ON "public"."trollstown_properties" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Allow users to view their own property upgrades" ON "public"."trollstown_property_upgrades" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Allow users to view their own streams" ON "public"."streams" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Anyone can view active entrance effects" ON "public"."entrance_effects" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Anyone can view active gifts" ON "public"."gifts" FOR SELECT TO "authenticated" USING (("is_active" = true));



CREATE POLICY "Anyone can view active insurance" ON "public"."insurance" FOR SELECT TO "authenticated" USING (("is_active" = true));



CREATE POLICY "Anyone can view active insurance options" ON "public"."insurance_options" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Anyone can view active packages" ON "public"."insurance_packages" FOR SELECT TO "authenticated" USING (("is_active" = true));



CREATE POLICY "Anyone can view active perks" ON "public"."perks" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Anyone can view active tiers" ON "public"."cashout_tiers" FOR SELECT TO "authenticated" USING (("is_active" = true));



CREATE POLICY "Anyone can view active troll events" ON "public"."troll_events" FOR SELECT USING ((("active" = true) AND ("expires_at" > "now"())));



CREATE POLICY "Anyone can view broadcasts" ON "public"."admin_broadcasts" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Anyone can view comments" ON "public"."troll_post_comments" FOR SELECT USING (true);



CREATE POLICY "Anyone can view families" ON "public"."families" FOR SELECT USING (true);



CREATE POLICY "Anyone can view live streams" ON "public"."streams" FOR SELECT USING ((("is_live" = true) OR ("auth"."role"() = 'authenticated'::"text")));



CREATE POLICY "Anyone can view public config" ON "public"."config" FOR SELECT TO "authenticated" USING (("is_public" = true));



CREATE POLICY "Anyone can view reports on public streams" ON "public"."stream_reports" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."streams"
  WHERE (("streams"."id" = "stream_reports"."stream_id") AND ("streams"."status" = 'live'::"text")))));



CREATE POLICY "Anyone can view troll_families" ON "public"."troll_families" FOR SELECT USING (true);



CREATE POLICY "Anyone can view user profiles" ON "public"."user_profiles" FOR SELECT USING (true);



CREATE POLICY "Anyone can view wall gifts" ON "public"."troll_wall_gifts" FOR SELECT USING (true);



CREATE POLICY "Anyone can view wall posts" ON "public"."troll_wall_posts" FOR SELECT USING (true);



CREATE POLICY "Anyone can view wall reactions" ON "public"."troll_wall_reactions" FOR SELECT USING (true);



CREATE POLICY "Auth read all streams" ON "public"."streams" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Auth users can create families" ON "public"."families" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Auth users can create troll_families" ON "public"."troll_families" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated can insert logs" ON "public"."action_logs" FOR INSERT WITH CHECK ((("auth"."role"() = 'authenticated'::"text") OR ("auth"."role"() = 'service_role'::"text")));



CREATE POLICY "Authenticated can read moderation fee settings" ON "public"."moderation_fee_settings" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") IS NOT NULL));



CREATE POLICY "Authenticated users can create posts" ON "public"."troll_wall_posts" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Authenticated users can create wall posts" ON "public"."wall_posts" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") IS NOT NULL));



CREATE POLICY "Authenticated users can insert AI logs" ON "public"."ai_action_logs" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Authenticated users can like posts" ON "public"."troll_wall_likes" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Authenticated users can react to posts" ON "public"."troll_wall_reactions" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Authenticated users can send gifts" ON "public"."troll_wall_gifts" FOR INSERT WITH CHECK (("auth"."uid"() = "sender_id"));



CREATE POLICY "Authenticated users can view training scenarios" ON "public"."training_scenarios" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authority can manage docket entries" ON "public"."court_docket" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_lead_officer" = true))))));



CREATE POLICY "Authority can view all docket entries" ON "public"."court_docket" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_lead_officer" = true) OR ("user_profiles"."is_troll_officer" = true))))));



CREATE POLICY "Broadcasters can create battles" ON "public"."troll_battles" FOR INSERT TO "authenticated" WITH CHECK (((( SELECT "auth"."uid"() AS "uid") = "host_id") OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'broadcaster'::"text"])))))));



CREATE POLICY "Broadcasters can view entries for their streams" ON "public"."stream_entries" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."streams"
  WHERE (("streams"."id" = "stream_entries"."stream_id") AND ("streams"."broadcaster_id" = ( SELECT "auth"."uid"() AS "uid"))))));



CREATE POLICY "Broadcasters can view their own earnings" ON "public"."broadcaster_earnings" FOR SELECT USING (("broadcaster_id" = "auth"."uid"()));



CREATE POLICY "City events admin write" ON "public"."city_events" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "City events read access" ON "public"."city_events" FOR SELECT USING (true);



CREATE POLICY "Court rulings admin read" ON "public"."court_rulings_archive" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'troll_officer'::"text"])) OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_troll_officer" = true))))));



CREATE POLICY "Court rulings admin write" ON "public"."court_rulings_archive" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'troll_officer'::"text"])) OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_troll_officer" = true))))));



CREATE POLICY "Court rulings public read" ON "public"."court_rulings_archive" FOR SELECT USING (("is_public" = true));



CREATE POLICY "Creators insert payout" ON "public"."payout_requests" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid") = "user_id"));



CREATE POLICY "Creators read own payouts" ON "public"."payout_requests" FOR SELECT TO "authenticated" USING ((( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid") = "user_id"));



CREATE POLICY "Enable insert for authenticated users only" ON "public"."officer_applications" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Enable insert for authenticated users only" ON "public"."user_notifications" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Escalation matrix admin write" ON "public"."escalation_matrix" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Escalation matrix read access" ON "public"."escalation_matrix" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'troll_officer'::"text"])) OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_troll_officer" = true))))));



CREATE POLICY "Event participants read access" ON "public"."event_participants" FOR SELECT USING ((("user_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true)))))));



CREATE POLICY "Event participants write access" ON "public"."event_participants" USING ((("user_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true)))))));



CREATE POLICY "Everyone can read case templates" ON "public"."case_templates" FOR SELECT USING (true);



CREATE POLICY "Everyone can read logs" ON "public"."case_audit_logs" FOR SELECT USING (true);



CREATE POLICY "Everyone can read public cases" ON "public"."court_cases" FOR SELECT USING (true);



CREATE POLICY "Everyone can view active districts" ON "public"."city_districts" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Everyone can view honorary family members" ON "public"."honorary_family_members" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Everyone can view royal family titles" ON "public"."royal_family_titles" FOR SELECT USING (true);



CREATE POLICY "Family leaders can purchase items" ON "public"."family_shop_purchases" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."troll_family_memberships" "m"
  WHERE (("m"."user_id" = "auth"."uid"()) AND ("m"."family_id" = "family_shop_purchases"."family_id") AND ("m"."role" = ANY (ARRAY['leader'::"text", 'officer'::"text"]))))));



CREATE POLICY "Family leaders can update roles" ON "public"."troll_family_memberships" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."troll_family_memberships" "m"
  WHERE (("m"."user_id" = "auth"."uid"()) AND ("m"."family_id" = "troll_family_memberships"."family_id") AND ("m"."role" = 'leader'::"text"))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."troll_family_memberships" "m"
  WHERE (("m"."user_id" = "auth"."uid"()) AND ("m"."family_id" = "troll_family_memberships"."family_id") AND ("m"."role" = 'leader'::"text")))));



CREATE POLICY "Family members can send messages" ON "public"."family_lounge_messages" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."family_members"
  WHERE (("family_members"."family_id" = "family_lounge_messages"."family_id") AND ("family_members"."user_id" = ( SELECT "auth"."uid"() AS "uid"))))));



CREATE POLICY "Family members can view family tasks" ON "public"."family_tasks_new" FOR SELECT TO "authenticated" USING (("family_id" IN ( SELECT "family_members"."family_id"
   FROM "public"."family_members"
  WHERE ("family_members"."user_id" = ( SELECT "auth"."uid"() AS "uid")))));



CREATE POLICY "Family members can view purchases" ON "public"."family_shop_purchases" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."troll_family_memberships" "m"
  WHERE (("m"."user_id" = "auth"."uid"()) AND ("m"."family_id" = "family_shop_purchases"."family_id")))));



CREATE POLICY "Family shop items public readable" ON "public"."family_shop_items" FOR SELECT USING (true);



CREATE POLICY "HR employees managed by HR" ON "public"."hr_employees" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true) OR ("p"."role" = 'hr_admin'::"text")))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true) OR ("p"."role" = 'hr_admin'::"text"))))));



CREATE POLICY "HR employees viewable by HR" ON "public"."hr_employees" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true) OR ("p"."role" = 'hr_admin'::"text"))))));



CREATE POLICY "Host can update join requests" ON "public"."stream_join_requests" FOR UPDATE TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") IS NOT NULL) AND (EXISTS ( SELECT 1
   FROM "public"."streams" "s"
  WHERE (("s"."id" = "stream_join_requests"."stream_id") AND ("s"."broadcaster_id" = ( SELECT "auth"."uid"() AS "uid"))))))) WITH CHECK (((( SELECT "auth"."uid"() AS "uid") IS NOT NULL) AND (EXISTS ( SELECT 1
   FROM "public"."streams" "s"
  WHERE (("s"."id" = "stream_join_requests"."stream_id") AND ("s"."broadcaster_id" = ( SELECT "auth"."uid"() AS "uid")))))));



CREATE POLICY "Insert own cashout request" ON "public"."cashout_requests" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Interview sessions managed by HR" ON "public"."interview_sessions" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true) OR ("p"."role" = 'hr_admin'::"text")))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true) OR ("p"."role" = 'hr_admin'::"text"))))));



CREATE POLICY "Interview sessions viewable by participants or HR" ON "public"."interview_sessions" FOR SELECT TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "admin_id") OR (( SELECT "auth"."uid"() AS "uid") = "user_id") OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true) OR ("p"."role" = 'hr_admin'::"text")))))));



CREATE POLICY "Job applications created by owner" ON "public"."job_applications" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Job applications managed by HR" ON "public"."job_applications" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true) OR ("p"."role" = 'hr_admin'::"text")))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true) OR ("p"."role" = 'hr_admin'::"text"))))));



CREATE POLICY "Job applications viewable by owner or HR" ON "public"."job_applications" FOR SELECT TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "user_id") OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles" "p"
  WHERE (("p"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("p"."role" = 'admin'::"text") OR ("p"."is_admin" = true) OR ("p"."role" = 'hr_admin'::"text")))))));



CREATE POLICY "Judges can update cases" ON "public"."troll_court_cases" FOR UPDATE USING ((("auth"."uid"() = "assigned_judge_id") OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true)))))));



CREATE POLICY "Lead officers can delete any wall post" ON "public"."troll_wall_posts" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."is_lead_officer" = true)))));



CREATE POLICY "Lead officers can insert their own reports" ON "public"."weekly_officer_reports" FOR INSERT TO "authenticated" WITH CHECK (((( SELECT "auth"."uid"() AS "uid") = "lead_officer_id") AND (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."is_lead_officer" = true) OR ("user_profiles"."role" = 'admin'::"text")))))));



CREATE POLICY "Lead officers can view their own reports" ON "public"."weekly_officer_reports" FOR SELECT TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "lead_officer_id") OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true)))))));



CREATE POLICY "Lead/Admin can update payment holds" ON "public"."payment_holds" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'lead_troll_officer'::"text"])) OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_lead_officer" = true)))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'lead_troll_officer'::"text"])) OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_lead_officer" = true))))));



CREATE POLICY "Leaders can manage family members" ON "public"."family_members" USING ("public"."check_family_admin"("family_id", "auth"."uid"()));



CREATE POLICY "Leaders can update families" ON "public"."families" FOR UPDATE USING ((("founder_id" = "auth"."uid"()) OR "public"."check_family_admin"("id", "auth"."uid"())));



CREATE POLICY "Leaders can update troll_families" ON "public"."troll_families" FOR UPDATE USING ((("leader_id" = "auth"."uid"()) OR "public"."check_family_admin"("id", "auth"."uid"())));



CREATE POLICY "Memberships are public readable" ON "public"."troll_family_memberships" FOR SELECT USING (true);



CREATE POLICY "No one can delete redemptions" ON "public"."gift_card_redemptions" FOR DELETE TO "authenticated" USING (false);



CREATE POLICY "Officer chat insert" ON "public"."officer_chat_messages" FOR INSERT WITH CHECK ((("user_id" = "auth"."uid"()) AND (EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = "auth"."uid"()) AND (("up"."role" = ANY (ARRAY['admin'::"text", 'troll_officer'::"text"])) OR ("up"."is_admin" = true) OR ("up"."is_troll_officer" = true)))))));



CREATE POLICY "Officer chat select" ON "public"."officer_chat_messages" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = "auth"."uid"()) AND (("up"."role" = ANY (ARRAY['admin'::"text", 'troll_officer'::"text"])) OR ("up"."is_admin" = true) OR ("up"."is_troll_officer" = true))))));



CREATE POLICY "Officer performance read access" ON "public"."officer_performance" FOR SELECT USING ((("officer_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true)))))));



CREATE POLICY "Officer shift logs view" ON "public"."officer_shift_logs" FOR SELECT USING ((("officer_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = "auth"."uid"()) AND (("up"."role" = 'admin'::"text") OR ("up"."is_admin" = true)))))));



CREATE POLICY "Officers and admins can create IP bans" ON "public"."ip_bans" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."is_admin" = true) OR ("user_profiles"."is_troll_officer" = true))))));



CREATE POLICY "Officers and admins can update IP bans" ON "public"."ip_bans" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."is_admin" = true) OR ("user_profiles"."is_troll_officer" = true))))));



CREATE POLICY "Officers and admins can view IP bans" ON "public"."ip_bans" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."is_admin" = true) OR ("user_profiles"."is_troll_officer" = true))))));



CREATE POLICY "Officers and admins can view all kick logs" ON "public"."kick_logs" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."role" = 'troll_officer'::"text") OR ("user_profiles"."role" = 'lead_troll_officer'::"text") OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_troll_officer" = true) OR ("user_profiles"."is_lead_officer" = true))))));



CREATE POLICY "Officers and admins can view shift logs" ON "public"."officer_shift_logs" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'troll_officer'::"text", 'lead_troll_officer'::"text"])) OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_troll_officer" = true) OR ("user_profiles"."is_lead_officer" = true))))));



CREATE POLICY "Officers can create actions" ON "public"."moderation_actions" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."is_officer" = true) OR ("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."role" = 'troll_officer'::"text"))))));



CREATE POLICY "Officers can create cases" ON "public"."court_cases" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() IS NOT NULL));



CREATE POLICY "Officers can create risk events" ON "public"."risk_events" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."is_officer" = true) OR ("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Officers can delete any wall post" ON "public"."troll_wall_posts" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."is_troll_officer" = true)))));



CREATE POLICY "Officers can delete own shift slots" ON "public"."officer_shift_slots" FOR DELETE TO "authenticated" USING (((("officer_id" = ( SELECT "auth"."uid"() AS "uid")) AND ("status" <> 'active'::"text")) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text"))))));



CREATE POLICY "Officers can insert own logs" ON "public"."officer_stream_logs" FOR INSERT WITH CHECK ((("officer_id" = "auth"."uid"()) AND (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'troll_officer'::"text"])))))));



CREATE POLICY "Officers can insert own payouts" ON "public"."officer_payouts" FOR INSERT WITH CHECK (("officer_id" = "auth"."uid"()));



CREATE POLICY "Officers can insert own shift logs" ON "public"."officer_shift_logs" FOR INSERT WITH CHECK ((("officer_id" = "auth"."uid"()) AND (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'troll_officer'::"text"])))))));



CREATE POLICY "Officers can insert own shift slots" ON "public"."officer_shift_slots" FOR INSERT TO "authenticated" WITH CHECK ((("officer_id" = ( SELECT "auth"."uid"() AS "uid")) AND (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'troll_officer'::"text") OR ("user_profiles"."is_troll_officer" = true)))))));



CREATE POLICY "Officers can manage earnings" ON "public"."broadcaster_earnings" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."is_officer" = true) OR ("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Officers can manage risk profiles" ON "public"."user_risk_profile" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."is_officer" = true) OR ("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Officers can update moderation fee settings" ON "public"."moderation_fee_settings" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."role" = 'troll_officer'::"text") OR ("user_profiles"."role" = 'lead_troll_officer'::"text") OR ("user_profiles"."is_troll_officer" = true) OR ("user_profiles"."is_lead_officer" = true)))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."role" = 'troll_officer'::"text") OR ("user_profiles"."role" = 'lead_troll_officer'::"text") OR ("user_profiles"."is_troll_officer" = true) OR ("user_profiles"."is_lead_officer" = true))))));



CREATE POLICY "Officers can update own logs" ON "public"."officer_stream_logs" FOR UPDATE USING ((("officer_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text"))))));



CREATE POLICY "Officers can update own shift logs" ON "public"."officer_shift_logs" FOR UPDATE USING ((("officer_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text"))))));



CREATE POLICY "Officers can update own shift slots" ON "public"."officer_shift_slots" FOR UPDATE TO "authenticated" USING ((("officer_id" = ( SELECT "auth"."uid"() AS "uid")) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text"))))));



CREATE POLICY "Officers can update reports" ON "public"."moderation_reports" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."is_officer" = true) OR ("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."role" = 'troll_officer'::"text"))))));



CREATE POLICY "Officers can view all actions" ON "public"."moderation_actions" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."is_officer" = true) OR ("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."role" = 'troll_officer'::"text"))))));



CREATE POLICY "Officers can view all earnings" ON "public"."broadcaster_earnings" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."is_officer" = true) OR ("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Officers can view all reports" ON "public"."moderation_reports" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."is_officer" = true) OR ("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."role" = 'troll_officer'::"text"))))));



CREATE POLICY "Officers can view all risk events" ON "public"."risk_events" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."is_officer" = true) OR ("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Officers can view all risk profiles" ON "public"."user_risk_profile" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."is_officer" = true) OR ("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Officers can view escalations to them" ON "public"."escalation_reports" FOR SELECT TO "authenticated" USING ((("escalated_to" = ( SELECT "auth"."uid"() AS "uid")) AND (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."is_troll_officer" = true) OR ("user_profiles"."role" = 'troll_officer'::"text")))))));



CREATE POLICY "Officers can view own actions" ON "public"."officer_actions" FOR SELECT TO "authenticated" USING ((("officer_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text"))))));



CREATE POLICY "Officers can view own earnings" ON "public"."officer_earnings" FOR SELECT TO "authenticated" USING ((("officer_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = 'admin'::"text"))))));



CREATE POLICY "Officers can view own logs" ON "public"."officer_stream_logs" FOR SELECT USING ((("officer_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'troll_officer'::"text"])))))));



CREATE POLICY "Officers can view own payouts" ON "public"."officer_payouts" FOR SELECT USING (("officer_id" = "auth"."uid"()));



CREATE POLICY "Officers can view own shift logs" ON "public"."officer_shift_logs" FOR SELECT USING ((("officer_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'troll_officer'::"text"])))))));



CREATE POLICY "Officers can view own shift slots" ON "public"."officer_shift_slots" FOR SELECT TO "authenticated" USING ((("officer_id" = ( SELECT "auth"."uid"() AS "uid")) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'troll_officer'::"text"])))))));



CREATE POLICY "Officers see all payouts" ON "public"."payout_requests" FOR SELECT TO "authenticated" USING ("public"."is_officer_or_admin"());



CREATE POLICY "Officers update payouts" ON "public"."payout_requests" FOR UPDATE TO "authenticated" USING ("public"."is_officer_or_admin"());



CREATE POLICY "Only admins and lead officers can manage court sessions" ON "public"."court_sessions" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_lead_officer" = true)))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_lead_officer" = true))))));



CREATE POLICY "Only admins can create adjustments" ON "public"."admin_adjustments" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("user_profiles"."role" = 'admin'::"text")))));



CREATE POLICY "Only admins can create broadcasts" ON "public"."admin_broadcasts" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."is_admin" = true) OR ("user_profiles"."role" = 'admin'::"text"))))));



CREATE POLICY "Only backend can insert contracts" ON "public"."trolltract_contracts" FOR INSERT TO "authenticated" WITH CHECK (false);



CREATE POLICY "Participants can read evidence" ON "public"."case_evidence" FOR SELECT USING (true);



CREATE POLICY "Participants can read their cases" ON "public"."case_participants" FOR SELECT USING (true);



CREATE POLICY "Public can insert errors" ON "public"."system_errors" FOR INSERT TO "authenticated", "anon" WITH CHECK (true);



CREATE POLICY "Public can read live streams" ON "public"."streams" FOR SELECT USING (("is_live" = true));



CREATE POLICY "Public can view active items" ON "public"."user_active_items" FOR SELECT USING (true);



CREATE POLICY "Public can view active promo codes" ON "public"."promo_codes" FOR SELECT USING ((("is_active" = true) AND (("valid_until" IS NULL) OR ("valid_until" > "now"()))));



CREATE POLICY "Public can view active quiz questions" ON "public"."officer_quiz_questions" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Public can view broadcasts" ON "public"."admin_broadcasts" FOR SELECT TO "anon" USING (true);



CREATE POLICY "Public can view streams" ON "public"."streams" FOR SELECT USING (true);



CREATE POLICY "Public read access" ON "public"."user_follows" FOR SELECT USING (true);



CREATE POLICY "Reputation events read access" ON "public"."reputation_events" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'troll_officer'::"text"])) OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_troll_officer" = true))))));



CREATE POLICY "Reputation read access" ON "public"."user_reputation" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'troll_officer'::"text"])) OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_troll_officer" = true))))));



CREATE POLICY "Royal Troll can manage family tasks" ON "public"."family_tasks_new" TO "authenticated" USING (("family_id" IN ( SELECT "family_members"."family_id"
   FROM "public"."family_members"
  WHERE (("family_members"."user_id" = ( SELECT "auth"."uid"() AS "uid")) AND ("family_members"."is_royal_troll" = true)))));



CREATE POLICY "Royal Troll can manage invites" ON "public"."family_invites" TO "authenticated" USING (("family_id" IN ( SELECT "family_members"."family_id"
   FROM "public"."family_members"
  WHERE (("family_members"."user_id" = ( SELECT "auth"."uid"() AS "uid")) AND ("family_members"."is_royal_troll" = true)))));



CREATE POLICY "Royal Troll can verify completions" ON "public"."task_completions" FOR UPDATE TO "authenticated" USING (("family_id" IN ( SELECT "family_members"."family_id"
   FROM "public"."family_members"
  WHERE (("family_members"."user_id" = ( SELECT "auth"."uid"() AS "uid")) AND ("family_members"."is_royal_troll" = true)))));



CREATE POLICY "Secretaries and admin can update intake" ON "public"."executive_intake" FOR UPDATE TO "authenticated" USING (("public"."is_secretary"() OR "public"."is_admin"()));



CREATE POLICY "Secretaries can create executive reports" ON "public"."executive_reports" FOR INSERT TO "authenticated" WITH CHECK ("public"."is_secretary"());



CREATE POLICY "Secretaries can view all intake" ON "public"."executive_intake" FOR SELECT TO "authenticated" USING ("public"."is_secretary"());



CREATE POLICY "Secretaries can view executive reports" ON "public"."executive_reports" FOR SELECT TO "authenticated" USING (("public"."is_secretary"() OR "public"."is_admin"()));



CREATE POLICY "Secretary can view own assignment" ON "public"."secretary_assignments" FOR SELECT TO "authenticated" USING ((("secretary_id" = ( SELECT "auth"."uid"() AS "uid")) OR "public"."is_admin"()));



CREATE POLICY "Secretary+ can insert payment holds" ON "public"."payment_holds" FOR INSERT TO "authenticated" WITH CHECK (((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'lead_troll_officer'::"text", 'secretary'::"text"])) OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_lead_officer" = true))))) AND (NOT (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "payment_holds"."user_id") AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))))));



CREATE POLICY "Seller reliability read access" ON "public"."seller_reliability" FOR SELECT USING ((("seller_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'troll_officer'::"text"])) OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_troll_officer" = true)))))));



CREATE POLICY "Service role can insert profiles" ON "public"."user_profiles" FOR INSERT TO "authenticated" WITH CHECK (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can update coins" ON "public"."user_profiles" FOR UPDATE TO "authenticated" USING (("auth"."role"() = 'service_role'::"text")) WITH CHECK (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role full access" ON "public"."user_profiles" TO "authenticated" USING (("auth"."role"() = 'service_role'::"text")) WITH CHECK (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role inserts payment_fees" ON "public"."payment_fees" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."role"() AS "role") = 'service_role'::"text"));



CREATE POLICY "Service role inserts revenue_ledger" ON "public"."revenue_ledger" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."role"() AS "role") = 'service_role'::"text"));



CREATE POLICY "Staff can create fulfillments" ON "public"."giftcard_fulfillments" FOR INSERT TO "authenticated" WITH CHECK ("public"."is_staff"());



CREATE POLICY "Staff can manage redemptions" ON "public"."visa_redemptions" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = "auth"."uid"()) AND (("up"."role" = 'admin'::"text") OR ("up"."role" = 'secretary'::"text") OR ("up"."is_admin" = true)))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = "auth"."uid"()) AND (("up"."role" = 'admin'::"text") OR ("up"."role" = 'secretary'::"text") OR ("up"."is_admin" = true))))));



CREATE POLICY "Staff can read MAI timeline" ON "public"."mai_timeline_events" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("up"."role" = ANY (ARRAY['admin'::"text", 'lead_troll_officer'::"text"])) OR ("up"."is_admin" = true) OR ("up"."is_lead_officer" = true))))));



CREATE POLICY "Staff can read economy abuse flags" ON "public"."economy_abuse_flags" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("up"."role" = ANY (ARRAY['admin'::"text", 'lead_troll_officer'::"text"])) OR ("up"."is_admin" = true) OR ("up"."is_lead_officer" = true))))));



CREATE POLICY "Staff can read overrides" ON "public"."mai_overrides" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("up"."role" = ANY (ARRAY['admin'::"text", 'lead_troll_officer'::"text"])) OR ("up"."is_admin" = true) OR ("up"."is_lead_officer" = true))))));



CREATE POLICY "Staff can update alerts" ON "public"."critical_alerts" FOR UPDATE TO "authenticated" USING ("public"."is_staff"());



CREATE POLICY "Staff can update cashout status" ON "public"."cashout_requests" FOR UPDATE TO "authenticated" USING ("public"."is_staff"());



CREATE POLICY "Staff can update fulfillments" ON "public"."giftcard_fulfillments" FOR UPDATE TO "authenticated" USING ("public"."is_staff"());



CREATE POLICY "Staff can view alerts" ON "public"."critical_alerts" FOR SELECT TO "authenticated" USING ("public"."is_staff"());



CREATE POLICY "Staff can view all cashouts" ON "public"."cashout_requests" FOR SELECT TO "authenticated" USING ("public"."is_staff"());



CREATE POLICY "Staff can view all payment holds" ON "public"."payment_holds" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'lead_troll_officer'::"text", 'troll_officer'::"text", 'secretary'::"text"])) OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_lead_officer" = true) OR ("user_profiles"."is_troll_officer" = true))))));



CREATE POLICY "Staff can view fulfillments" ON "public"."giftcard_fulfillments" FOR SELECT TO "authenticated" USING ("public"."is_staff"());



CREATE POLICY "Staff can view mai incidents" ON "public"."mai_incidents" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("up"."role" = ANY (ARRAY['admin'::"text", 'lead_troll_officer'::"text"])) OR ("up"."is_admin" = true) OR ("up"."is_lead_officer" = true))))));



CREATE POLICY "Store owners can update own stores" ON "public"."stores" FOR UPDATE USING (("auth"."uid"() = "owner_id"));



CREATE POLICY "Store owners can view own stores" ON "public"."stores" FOR SELECT USING (("auth"."uid"() = "owner_id"));



CREATE POLICY "Stream discovery prefs access" ON "public"."stream_discovery_prefs" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Stream owners can manage momentum" ON "public"."stream_momentum" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."streams"
  WHERE (("streams"."id" = "stream_momentum"."stream_id") AND ("streams"."broadcaster_id" = ( SELECT "auth"."uid"() AS "uid"))))));



CREATE POLICY "Stream ranking admin write" ON "public"."stream_ranking" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "Stream ranking read access" ON "public"."stream_ranking" FOR SELECT USING (true);



CREATE POLICY "Streamer controls their own stream" ON "public"."streams" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "owner_id"));



CREATE POLICY "System can insert family stats" ON "public"."family_stats" FOR INSERT TO "authenticated" WITH CHECK (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "System can insert logs" ON "public"."action_logs" FOR INSERT TO "authenticated" WITH CHECK (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "User can insert their payout request" ON "public"."payout_requests" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid") = "user_id"));



CREATE POLICY "User can view own redemptions" ON "public"."visa_redemptions" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "User can view their own payout requests" ON "public"."payout_requests" FOR SELECT TO "authenticated" USING ((( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid") = "user_id"));



CREATE POLICY "User or host can read join requests" ON "public"."stream_join_requests" FOR SELECT TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") IS NOT NULL) AND ((( SELECT "auth"."uid"() AS "uid") = "user_id") OR (EXISTS ( SELECT 1
   FROM "public"."streams" "s"
  WHERE (("s"."id" = "stream_join_requests"."stream_id") AND ("s"."broadcaster_id" = ( SELECT "auth"."uid"() AS "uid"))))))));



CREATE POLICY "User update own stream" ON "public"."streams" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id")) WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can add ticket messages" ON "public"."ticket_messages" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."support_tickets" "t"
  WHERE (("t"."id" = "ticket_messages"."ticket_id") AND ("t"."user_id" = "auth"."uid"())))));



CREATE POLICY "Users can create conversations" ON "public"."conversations" FOR INSERT WITH CHECK (("auth"."uid"() IS NOT NULL));



CREATE POLICY "Users can create one appeal" ON "public"."mai_appeals" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "appellant_user_id"));



CREATE POLICY "Users can create own applications" ON "public"."applications" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can create own applications" ON "public"."creator_applications" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can create own migration claim" ON "public"."creator_migration_claims" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can create payout requests" ON "public"."payout_requests" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid") = "user_id"));



CREATE POLICY "Users can create reports" ON "public"."moderation_reports" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "reporter_id"));



CREATE POLICY "Users can create reports" ON "public"."stream_reports" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "reporter_id"));



CREATE POLICY "Users can create their own redemption requests" ON "public"."gift_card_redemptions" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "Users can create their task completions" ON "public"."task_completions" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "Users can create wall posts" ON "public"."troll_wall_posts" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can delete own web push subscriptions" ON "public"."web_push_subscriptions" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can delete their own active items" ON "public"."user_active_items" FOR DELETE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can delete their own comments" ON "public"."troll_post_comments" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can delete their own posts" ON "public"."troll_posts" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can delete their own posts" ON "public"."troll_wall_posts" FOR DELETE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can delete their own presets" ON "public"."stream_presets" FOR DELETE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can delete their own wall posts" ON "public"."troll_wall_posts" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can delete their own wall posts" ON "public"."wall_posts" FOR DELETE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can follow others" ON "public"."user_follows" FOR INSERT WITH CHECK (("auth"."uid"() = "follower_id"));



CREATE POLICY "Users can insert messages" ON "public"."messages" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid") = "user_id"));



CREATE POLICY "Users can insert notifications for themselves" ON "public"."notifications" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can insert own applications" ON "public"."empire_applications" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can insert own error logs" ON "public"."error_logs" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can insert own orientation results" ON "public"."officer_orientation_results" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "Users can insert own profile" ON "public"."user_profiles" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can insert own quiz attempts" ON "public"."officer_quiz_attempts" FOR INSERT WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can insert own tax info" ON "public"."user_tax_info" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can insert own tickets" ON "public"."support_tickets" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can insert own transactions" ON "public"."coin_transactions" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can insert referrals for themselves" ON "public"."referrals" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "referrer_id"));



CREATE POLICY "Users can insert their own active items" ON "public"."user_active_items" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can insert their own claims" ON "public"."troll_event_claims" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can insert their own coin transactions" ON "public"."coin_transactions" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "Users can insert their own comments" ON "public"."troll_post_comments" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can insert their own entries" ON "public"."stream_entries" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can insert their own insurance logs" ON "public"."insurance_logs" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can insert their own migration claim" ON "public"."creator_migration_claims" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can insert their own notifications" ON "public"."notifications" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can insert their own onboarding events" ON "public"."onboarding_events" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can insert their own payment methods" ON "public"."payment_methods" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can insert their own posts" ON "public"."troll_posts" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can insert their own presets" ON "public"."stream_presets" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can insert their own queue entry" ON "public"."tromody_queue" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can insert their own referral claims" ON "public"."referral_claims" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can insert their own training sessions" ON "public"."officer_training_sessions" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "officer_id"));



CREATE POLICY "Users can join a family" ON "public"."troll_family_memberships" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can join as participants" ON "public"."streams_participants" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can join families" ON "public"."family_members" FOR INSERT WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can leave their family" ON "public"."troll_family_memberships" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can like streams" ON "public"."stream_likes" FOR INSERT TO "authenticated" WITH CHECK (((( SELECT "auth"."uid"() AS "uid") IS NOT NULL) AND (( SELECT "auth"."uid"() AS "uid") = "user_id")));



CREATE POLICY "Users can manage their own active items" ON "public"."user_active_items" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can react in streams" ON "public"."stream_reactions" FOR INSERT TO "authenticated" WITH CHECK (((( SELECT "auth"."uid"() AS "uid") IS NOT NULL) AND (( SELECT "auth"."uid"() AS "uid") = "user_id")));



CREATE POLICY "Users can read own MAI memory" ON "public"."mai_user_memory" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can read own coinback log" ON "public"."coinback_log" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can read own notifications" ON "public"."notifications" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can read own profile" ON "public"."profiles" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "id"));



CREATE POLICY "Users can read own profile" ON "public"."user_profiles" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can read their own notifications" ON "public"."notifications" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can remove their own reactions" ON "public"."troll_wall_reactions" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can request to join a stream" ON "public"."stream_join_requests" FOR INSERT TO "authenticated" WITH CHECK (((( SELECT "auth"."uid"() AS "uid") IS NOT NULL) AND (( SELECT "auth"."uid"() AS "uid") = "user_id")));



CREATE POLICY "Users can send battle gifts" ON "public"."troll_battle_gifts" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "sender_id"));



CREATE POLICY "Users can send gifts" ON "public"."gift_transactions" FOR INSERT WITH CHECK (("auth"."uid"() = "sender_id"));



CREATE POLICY "Users can send stream messages" ON "public"."stream_messages" FOR INSERT TO "authenticated" WITH CHECK (((( SELECT "auth"."uid"() AS "uid") IS NOT NULL) AND (( SELECT "auth"."uid"() AS "uid") = "user_id")));



CREATE POLICY "Users can unfollow" ON "public"."user_follows" FOR DELETE USING (("auth"."uid"() = "follower_id"));



CREATE POLICY "Users can unfollow others" ON "public"."user_follows" FOR DELETE USING (("auth"."uid"() = "follower_id"));



CREATE POLICY "Users can unlike posts" ON "public"."troll_wall_likes" FOR DELETE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can unlike streams" ON "public"."stream_likes" FOR DELETE TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") IS NOT NULL) AND (( SELECT "auth"."uid"() AS "uid") = "user_id")));



CREATE POLICY "Users can update matches they are in" ON "public"."tromody_matches" FOR UPDATE TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "player1_id") OR (( SELECT "auth"."uid"() AS "uid") = "player2_id")));



CREATE POLICY "Users can update own MAI memory" ON "public"."mai_user_memory" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id")) WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can update own applications" ON "public"."empire_applications" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id")) WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can update own notifications" ON "public"."notifications" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update own orientation" ON "public"."officer_orientations" FOR UPDATE USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can update own orientation results" ON "public"."officer_orientation_results" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "Users can update own payout settings" ON "public"."user_payout_settings" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can update own pending applications" ON "public"."creator_applications" FOR UPDATE USING ((("auth"."uid"() = "user_id") AND ("status" = 'pending'::"text")));



CREATE POLICY "Users can update own pending migration claim" ON "public"."creator_migration_claims" FOR UPDATE USING ((("auth"."uid"() = "user_id") AND ("verification_status" = 'pending'::"text")));



CREATE POLICY "Users can update own profile" ON "public"."profiles" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "id"));



CREATE POLICY "Users can update own profile" ON "public"."user_profiles" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update own tax info" ON "public"."user_tax_info" FOR UPDATE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update own transactions" ON "public"."coin_transactions" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can update their own claim while pending" ON "public"."creator_migration_claims" FOR UPDATE USING ((("auth"."uid"() = "user_id") AND ("verification_status" = 'pending'::"text"))) WITH CHECK ((("auth"."uid"() = "user_id") AND ("verification_status" = 'pending'::"text")));



CREATE POLICY "Users can update their own entrance effects" ON "public"."user_entrance_effects" FOR UPDATE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update their own entries" ON "public"."stream_entries" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can update their own insurances" ON "public"."user_insurances" FOR UPDATE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update their own notifications" ON "public"."notifications" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id")) WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can update their own onboarding progress" ON "public"."onboarding_progress" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can update their own payment methods" ON "public"."payment_methods" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can update their own perks" ON "public"."user_perks" FOR UPDATE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update their own posts" ON "public"."troll_posts" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can update their own posts" ON "public"."troll_wall_posts" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id")) WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can update their own presets" ON "public"."stream_presets" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can update their own progress" ON "public"."user_district_progress" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can update their own queue entry" ON "public"."tromody_queue" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can update their own referral status" ON "public"."referrals" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "referrer_id"));



CREATE POLICY "Users can update their own wall posts" ON "public"."wall_posts" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can update their participant status" ON "public"."streams_participants" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can upsert own MAI memory" ON "public"."mai_user_memory" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can upsert own payout settings" ON "public"."user_payout_settings" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can upsert own web push subscriptions" ON "public"."web_push_subscriptions" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view adjustments to their account" ON "public"."admin_adjustments" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "target_user_id"));



CREATE POLICY "Users can view announcements for accessible districts" ON "public"."district_announcements" FOR SELECT USING ((("is_active" = true) AND (("district_id" IS NULL) OR (EXISTS ( SELECT 1
   FROM "public"."city_districts" "cd"
  WHERE (("cd"."id" = "district_announcements"."district_id") AND ("cd"."is_active" = true)))))));



CREATE POLICY "Users can view battles they participated in" ON "public"."tromody_battles" FOR SELECT USING ((("auth"."uid"() = "left_user_id") OR ("auth"."uid"() = "right_user_id")));



CREATE POLICY "Users can view family invites" ON "public"."family_invites" FOR SELECT TO "authenticated" USING (("family_id" IN ( SELECT "family_members"."family_id"
   FROM "public"."family_members"
  WHERE ("family_members"."user_id" = ( SELECT "auth"."uid"() AS "uid")))));



CREATE POLICY "Users can view family wars" ON "public"."family_wars" FOR SELECT TO "authenticated" USING ((("attacking_family_id" IN ( SELECT "family_members"."family_id"
   FROM "public"."family_members"
  WHERE ("family_members"."user_id" = ( SELECT "auth"."uid"() AS "uid")))) OR ("defending_family_id" IN ( SELECT "family_members"."family_id"
   FROM "public"."family_members"
  WHERE ("family_members"."user_id" = ( SELECT "auth"."uid"() AS "uid"))))));



CREATE POLICY "Users can view features for accessible districts" ON "public"."district_features" FOR SELECT USING ((("is_enabled" = true) AND (EXISTS ( SELECT 1
   FROM "public"."city_districts" "cd"
  WHERE (("cd"."id" = "district_features"."district_id") AND ("cd"."is_active" = true) AND ((("cd"."required_role")::"text" = 'user'::"text") OR (("cd"."required_role")::"text" = ( SELECT "user_profiles"."role"
           FROM "public"."user_profiles"
          WHERE ("user_profiles"."id" = "auth"."uid"()))) OR ((("cd"."required_role")::"text" = 'family_member'::"text") AND (EXISTS ( SELECT 1
           FROM "public"."applications" "a"
          WHERE (("a"."user_id" = "auth"."uid"()) AND ("a"."type" = 'troll_family'::"text") AND ("a"."status" = 'approved'::"text")))))))))));



CREATE POLICY "Users can view matches they are in" ON "public"."tromody_matches" FOR SELECT TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "player1_id") OR (( SELECT "auth"."uid"() AS "uid") = "player2_id")));



CREATE POLICY "Users can view members of their families" ON "public"."family_members" FOR SELECT USING ("public"."check_family_membership"("family_id", "auth"."uid"()));



CREATE POLICY "Users can view own agreements" ON "public"."user_agreements" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view own applications" ON "public"."applications" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view own applications" ON "public"."creator_applications" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own applications" ON "public"."empire_applications" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view own balances" ON "public"."user_balances" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view own bans" ON "public"."user_bans" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view own bonus claims" ON "public"."referral_monthly_bonus" FOR SELECT USING (("auth"."uid"() = "recruiter_id"));



CREATE POLICY "Users can view own cashout requests" ON "public"."cashout_requests" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view own conversations" ON "public"."conversations" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."conversation_members" "cm"
  WHERE (("cm"."conversation_id" = "conversations"."id") AND ("cm"."user_id" = "auth"."uid"())))));



CREATE POLICY "Users can view own declined transactions" ON "public"."declined_transactions" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own earnings" ON "public"."broadcaster_earnings" FOR SELECT TO "authenticated" USING (("broadcaster_id" = "auth"."uid"()));



CREATE POLICY "Users can view own escalations" ON "public"."escalation_reports" FOR SELECT TO "authenticated" USING ((("escalated_by" = ( SELECT "auth"."uid"() AS "uid")) OR ("escalated_to" = ( SELECT "auth"."uid"() AS "uid"))));



CREATE POLICY "Users can view own membership" ON "public"."family_members" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view own migration claims" ON "public"."creator_migration_claims" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own orientation" ON "public"."officer_orientations" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view own orientation results" ON "public"."officer_orientation_results" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "Users can view own payout requests" ON "public"."payout_requests" FOR SELECT TO "authenticated" USING ((( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid") = "user_id"));



CREATE POLICY "Users can view own payout settings" ON "public"."user_payout_settings" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view own promo code uses" ON "public"."promo_code_uses" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view own quiz attempts" ON "public"."officer_quiz_attempts" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view own recruiter relationship" ON "public"."profiles" FOR SELECT USING ((("auth"."uid"() = "id") OR ("auth"."uid"() = "recruiter_id")));



CREATE POLICY "Users can view own referral bonuses" ON "public"."referral_monthly_bonus" FOR SELECT USING (("auth"."uid"() = "recruiter_id"));



CREATE POLICY "Users can view own risk profile" ON "public"."user_risk_profile" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view own row" ON "public"."user_wallets" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view own tax info" ON "public"."user_tax_info" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own tickets" ON "public"."support_tickets" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view own transactions" ON "public"."balance_ledger" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view own transactions" ON "public"."coin_transactions" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view own web push subscriptions" ON "public"."web_push_subscriptions" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own wheel spins" ON "public"."wheel_spins" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view participants in their streams" ON "public"."streams_participants" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."streams"
  WHERE (("streams"."id" = "streams_participants"."stream_id") AND (("streams"."broadcaster_id" = ( SELECT "auth"."uid"() AS "uid")) OR ("streams_participants"."user_id" = ( SELECT "auth"."uid"() AS "uid")))))));



CREATE POLICY "Users can view public cases" ON "public"."troll_court_cases" FOR SELECT USING (true);



CREATE POLICY "Users can view task completions" ON "public"."task_completions" FOR SELECT TO "authenticated" USING (("family_id" IN ( SELECT "family_members"."family_id"
   FROM "public"."family_members"
  WHERE ("family_members"."user_id" = ( SELECT "auth"."uid"() AS "uid")))));



CREATE POLICY "Users can view their appeals" ON "public"."mai_appeals" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "appellant_user_id"));



CREATE POLICY "Users can view their battle history" ON "public"."battle_history" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their battle rewards" ON "public"."battle_rewards" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their gifts" ON "public"."gift_transactions" FOR SELECT USING ((("auth"."uid"() = "sender_id") OR ("auth"."uid"() = "receiver_id")));



CREATE POLICY "Users can view their own AI logs" ON "public"."ai_action_logs" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their own active items" ON "public"."user_active_items" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own alerts" ON "public"."system_alerts" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own applications" ON "public"."empire_applications" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "Users can view their own blocked users" ON "public"."blocked_users" FOR SELECT TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "blocker_id") OR (( SELECT "auth"."uid"() AS "uid") = "blocked_id")));



CREATE POLICY "Users can view their own claims" ON "public"."troll_event_claims" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own coin transactions" ON "public"."coin_transactions" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "Users can view their own devices" ON "public"."user_devices" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their own docket entries" ON "public"."court_docket" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own earnings" ON "public"."earnings" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their own empire referrals" ON "public"."empire_referrals" FOR SELECT TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "referrer_id") OR (( SELECT "auth"."uid"() AS "uid") = "referred_id")));



CREATE POLICY "Users can view their own entrance effects" ON "public"."user_entrance_effects" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own entrances" ON "public"."user_entrances" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their own entries" ON "public"."stream_entries" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their own follows" ON "public"."follows" FOR SELECT TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "follower_id") OR (( SELECT "auth"."uid"() AS "uid") = "following_id")));



CREATE POLICY "Users can view their own fulfillment status" ON "public"."giftcard_fulfillments" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."cashout_requests" "cr"
  WHERE (("cr"."id" = "giftcard_fulfillments"."cashout_id") AND ("cr"."user_id" = ( SELECT "auth"."uid"() AS "uid"))))));



CREATE POLICY "Users can view their own gift totals" ON "public"."admin_gift_totals" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view their own giveaways" ON "public"."daily_giveaways" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their own history" ON "public"."royal_family_history" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view their own insurances" ON "public"."user_insurances" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own kick logs" ON "public"."kick_logs" FOR SELECT TO "authenticated" USING ((("kicked_user_id" = ( SELECT "auth"."uid"() AS "uid")) OR ("kicked_by_user_id" = ( SELECT "auth"."uid"() AS "uid"))));



CREATE POLICY "Users can view their own lucky events" ON "public"."lucky_coin_events" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "Users can view their own messages" ON "public"."messages" FOR SELECT TO "authenticated" USING ((( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid") = "user_id"));



CREATE POLICY "Users can view their own migration claim" ON "public"."creator_migration_claims" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own notifications" ON "public"."notifications" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own onboarding events" ON "public"."onboarding_events" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their own onboarding progress" ON "public"."onboarding_progress" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their own payment holds" ON "public"."payment_holds" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "Users can view their own payouts" ON "public"."payouts" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their own perks" ON "public"."royal_family_perks" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."royal_family_titles" "rft"
  WHERE (("rft"."id" = "royal_family_perks"."title_id") AND ("rft"."user_id" = "auth"."uid"())))));



CREATE POLICY "Users can view their own perks" ON "public"."user_perks" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own presets" ON "public"."stream_presets" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their own progress" ON "public"."user_district_progress" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view their own punishments" ON "public"."punishments" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their own queue entry" ON "public"."tromody_queue" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their own redemption requests" ON "public"."gift_card_redemptions" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "Users can view their own referral claims" ON "public"."referral_claims" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own referrals" ON "public"."referrals" FOR SELECT TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "referrer_id") OR (( SELECT "auth"."uid"() AS "uid") = "referred_user_id")));



CREATE POLICY "Users can view their own reports" ON "public"."moderation_reports" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "reporter_id"));



CREATE POLICY "Users can view their own rewards" ON "public"."empire_partner_rewards" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "referrer_id"));



CREATE POLICY "Users can view their own risk events" ON "public"."risk_events" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view their own risk profile" ON "public"."user_risk_profile" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view their own shifts" ON "public"."shifts" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their own training sessions" ON "public"."officer_training_sessions" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "officer_id"));



CREATE POLICY "Users can view their own trophies" ON "public"."trophies" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their own typing status" ON "public"."typing_statuses" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view their own weekly reports" ON "public"."weekly_reports" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "reporter_id"));



CREATE POLICY "Users can view ticket messages" ON "public"."ticket_messages" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."support_tickets" "t"
  WHERE (("t"."id" = "ticket_messages"."ticket_id") AND ("t"."user_id" = "auth"."uid"())))));



CREATE POLICY "Users cannot update cashout after submission" ON "public"."cashout_requests" FOR UPDATE TO "authenticated" USING (false);



CREATE POLICY "Users cannot update redemption requests" ON "public"."gift_card_redemptions" FOR UPDATE TO "authenticated" USING (false) WITH CHECK (false);



CREATE POLICY "Users view own transactions" ON "public"."transactions" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users view their own contracts" ON "public"."trolltract_contracts" FOR SELECT TO "authenticated" USING ((( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid") = "user_id"));



CREATE POLICY "View active public court sessions" ON "public"."court_sessions" FOR SELECT TO "authenticated" USING ((("status" = 'active'::"text") AND ("is_public" = true)));



CREATE POLICY "View own summons or admin" ON "public"."court_summons" FOR SELECT TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "summoned_user_id") OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("up"."role" = 'admin'::"text") OR ("up"."role" = 'lead_troll_officer'::"text") OR ("up"."is_admin" = true)))))));



ALTER TABLE "public"."abuse_reports" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."action_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."active_sessions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."activity_log" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."activity_logs" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "admin select all messages" ON "public"."messages" FOR SELECT TO "authenticated" USING ((("auth"."jwt"() ->> 'email'::"text") = 'trollcity2025@gmail.com'::"text"));



CREATE POLICY "admin select all payouts" ON "public"."payout_requests" FOR SELECT TO "authenticated" USING ((("auth"."jwt"() ->> 'email'::"text") = 'trollcity2025@gmail.com'::"text"));



CREATE POLICY "admin select all streams" ON "public"."streams" FOR SELECT TO "authenticated" USING ((("auth"."jwt"() ->> 'email'::"text") = 'trollcity2025@gmail.com'::"text"));



CREATE POLICY "admin update all payouts" ON "public"."payout_requests" FOR UPDATE TO "authenticated" USING ((("auth"."jwt"() ->> 'email'::"text") = 'trollcity2025@gmail.com'::"text")) WITH CHECK ((("auth"."jwt"() ->> 'email'::"text") = 'trollcity2025@gmail.com'::"text"));



ALTER TABLE "public"."admin_adjustments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."admin_broadcasts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."admin_coin_revenue" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "admin_delete_user_wallets" ON "public"."user_wallets" FOR DELETE TO "authenticated" USING ("public"."is_admin"());



ALTER TABLE "public"."admin_flags" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."admin_gift_totals" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "admin_insert_user_wallets" ON "public"."user_wallets" FOR INSERT TO "authenticated" WITH CHECK ("public"."is_admin"());



CREATE POLICY "admin_select_user_wallets" ON "public"."user_wallets" FOR SELECT TO "authenticated" USING ("public"."is_admin"());



ALTER TABLE "public"."admin_tax_reviews" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."admin_top_buyers" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "admin_update_user_wallets" ON "public"."user_wallets" FOR UPDATE TO "authenticated" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



CREATE POLICY "admins_can_update_payments" ON "public"."payment_logs" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'moderator'::"text"])))))) WITH CHECK (true);



CREATE POLICY "admins_can_view_all_payments" ON "public"."payment_logs" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'moderator'::"text"]))))));



ALTER TABLE "public"."ai_action_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."app_settings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."app_updates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."applications" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "applications_insert_self" ON "public"."applications" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "applications_select" ON "public"."applications" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "applications_update_admin" ON "public"."applications" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."is_admin" = true) OR ("user_profiles"."is_lead_officer" = true) OR ("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'officer'::"text"])))))));



CREATE POLICY "auth_delete_own" ON "public"."activity_log" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."activity_logs" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."admin_coin_revenue" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."admin_flags" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."admin_tax_reviews" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."admin_top_buyers" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."ai_action_logs" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."applications" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."balance_ledger" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."battle_gifts" FOR DELETE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."battle_history" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."battle_rewards" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."broadcast_cycle_stats" FOR DELETE TO "authenticated" USING (("broadcaster_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."broadcast_seats" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."broadcast_tokens" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."broadcaster_applications" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."broadcaster_metrics" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."call_history" FOR DELETE TO "authenticated" USING (("receiver_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."call_minutes" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."call_sessions" FOR DELETE TO "authenticated" USING (("receiver_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."call_transactions" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."cashout_requests" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."coin_ledger" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."coin_pool_contributions" FOR DELETE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."coin_purchases" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."coin_transactions" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."coinback_log" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."court_box_members" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."court_sessions" FOR DELETE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."court_summons" FOR DELETE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."daily_giveaways" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."daily_rewards" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."earnings" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."economy_abuse_flags" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."empire_applications" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."error_logs" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."executive_reports" FOR DELETE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."family_lounge_messages" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."gift_bonus_tracker" FOR DELETE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."gifts" FOR DELETE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."gifts_owned" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."group_chats" FOR DELETE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."home_feature_spend" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."hr_employees" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."hr_notes" FOR DELETE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."identity_reward_logs" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."interview_sessions" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."job_applications" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."lucky_coin_events" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."mai_incidents" FOR DELETE TO "authenticated" USING (("host_user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."mai_overrides" FOR DELETE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."mai_user_memory" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."message_requests" FOR DELETE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."messages" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."moderation_notes" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."notifications" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."officer_applications" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."officer_badges" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."officer_chat" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."officer_chat_messages" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."officer_orientation_results" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."officer_quiz_attempts" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."onboarding_events" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."onboarding_progress" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."owc_transactions" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."payment_methods" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."payment_transactions" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."payout_requests" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."payout_reviews" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."payout_settings" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."payouts" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."platform_fees" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."post_gifts" FOR DELETE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."posts" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."promo_code_uses" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."punishment_transactions" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."punishments" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."referrals" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."report_cases" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."revenue_ledger" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."scheduled_announcements" FOR DELETE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."security_events" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."shifts" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."shop_partners" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."shop_transactions" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."shops" FOR DELETE TO "authenticated" USING (("owner_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."staff_applications" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."staff_profiles" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."stream_entrances" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."stream_entries" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."stream_events" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."stream_gifts" FOR DELETE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."stream_join_requests" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."stream_likes" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."stream_messages" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."stream_participants" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."stream_presets" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."stream_reactions" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."stream_snack_purchases" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."streams" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."streams_participants" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."support_tickets" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."task_completions" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."task_history" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."tax_report_status" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."transactions" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_battle_gifts" FOR DELETE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_dna_events" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_dna_profiles" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_drops" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_drops_log" FOR DELETE TO "authenticated" USING (("broadcaster_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_family_members" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_family_messages" FOR DELETE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_officer_applications" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_officers" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_post_comments" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_post_gifts" FOR DELETE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_post_reactions" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_post_views" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_posts" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_stream_messages" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_streams" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_wall_likes" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."troll_wall_posts" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."trollcity_shops" FOR DELETE TO "authenticated" USING (("owner_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."trollmond_ledger" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."trolls_night_applications" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."trollstown_properties" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."trollstown_property_upgrades" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."trolltract_contracts" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."tromody_queue" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."tromody_sessions" FOR DELETE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."trophies" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."typing_statuses" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."user_active_items" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."user_agreements" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."user_balances" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."user_bans" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."user_devices" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."user_entrances" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."user_insurance" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."user_inventory" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."user_ip_tracking" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."user_levels" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."user_payment_methods" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."user_payout_settings" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."user_roles" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."user_wallets" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."verification_requests" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."verification_transactions" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_delete_own" ON "public"."wall_posts" FOR DELETE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."activity_log" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."activity_logs" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."admin_coin_revenue" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."admin_flags" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."admin_tax_reviews" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."admin_top_buyers" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."ai_action_logs" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."balance_ledger" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."battle_gifts" FOR INSERT TO "authenticated" WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."battle_history" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."battle_rewards" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."broadcast_cycle_stats" FOR INSERT TO "authenticated" WITH CHECK (("broadcaster_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."broadcast_seats" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."broadcast_tokens" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."broadcaster_applications" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."broadcaster_metrics" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."call_history" FOR INSERT TO "authenticated" WITH CHECK (("receiver_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."call_minutes" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."call_sessions" FOR INSERT TO "authenticated" WITH CHECK (("receiver_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."call_transactions" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."cashout_requests" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."coin_ledger" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."coin_pool_contributions" FOR INSERT TO "authenticated" WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."coin_purchases" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."coinback_log" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."court_box_members" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."court_sessions" FOR INSERT TO "authenticated" WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."court_summons" FOR INSERT TO "authenticated" WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."daily_giveaways" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."daily_rewards" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."earnings" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."economy_abuse_flags" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."empire_applications" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."error_logs" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."executive_reports" FOR INSERT TO "authenticated" WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."family_lounge_messages" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."gift_bonus_tracker" FOR INSERT TO "authenticated" WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."gifts" FOR INSERT TO "authenticated" WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."gifts_owned" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."group_chats" FOR INSERT TO "authenticated" WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."home_feature_spend" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."hr_employees" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."hr_notes" FOR INSERT TO "authenticated" WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."identity_reward_logs" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."interview_sessions" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."job_applications" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."lucky_coin_events" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."mai_incidents" FOR INSERT TO "authenticated" WITH CHECK (("host_user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."mai_overrides" FOR INSERT TO "authenticated" WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."mai_user_memory" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."message_requests" FOR INSERT TO "authenticated" WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."messages" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."moderation_notes" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."notifications" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."officer_applications" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."officer_badges" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."officer_chat" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."officer_chat_messages" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."officer_quiz_attempts" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."onboarding_events" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."onboarding_progress" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."owc_transactions" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."payment_methods" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."payment_transactions" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."payout_requests" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."payout_reviews" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."payout_settings" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."payouts" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."platform_fees" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."post_gifts" FOR INSERT TO "authenticated" WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."posts" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."promo_code_uses" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."punishment_transactions" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."punishments" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."referrals" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."report_cases" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."revenue_ledger" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."scheduled_announcements" FOR INSERT TO "authenticated" WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."security_events" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."shifts" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."shop_partners" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."shop_transactions" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."shops" FOR INSERT TO "authenticated" WITH CHECK (("owner_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."staff_applications" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."staff_profiles" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."stream_entrances" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."stream_entries" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."stream_events" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."stream_gifts" FOR INSERT TO "authenticated" WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."stream_join_requests" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."stream_likes" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."stream_messages" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."stream_participants" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."stream_presets" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."stream_reactions" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."stream_snack_purchases" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."streams" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."streams_participants" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."support_tickets" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."task_history" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."tax_report_status" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."transactions" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_battle_gifts" FOR INSERT TO "authenticated" WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_dna_events" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_dna_profiles" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_drops" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_drops_log" FOR INSERT TO "authenticated" WITH CHECK (("broadcaster_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_family_members" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_family_messages" FOR INSERT TO "authenticated" WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_officer_applications" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_officers" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_post_comments" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_post_gifts" FOR INSERT TO "authenticated" WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_post_reactions" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_post_views" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_posts" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_stream_messages" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_streams" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_wall_likes" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."troll_wall_posts" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."trollcity_shops" FOR INSERT TO "authenticated" WITH CHECK (("owner_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."trollmond_ledger" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."trolls_night_applications" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."trollstown_properties" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."trollstown_property_upgrades" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."trolltract_contracts" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."tromody_queue" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."tromody_sessions" FOR INSERT TO "authenticated" WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."trophies" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."typing_statuses" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."user_active_items" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."user_agreements" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."user_balances" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."user_bans" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."user_devices" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."user_entrances" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."user_insurance" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."user_inventory" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."user_ip_tracking" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."user_levels" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."user_payment_methods" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."user_payout_settings" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."user_roles" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."user_wallets" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."verification_requests" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."verification_transactions" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_insert_own" ON "public"."wall_posts" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."activity_log" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."activity_logs" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."admin_coin_revenue" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."admin_flags" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."admin_tax_reviews" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."admin_top_buyers" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."ai_action_logs" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."balance_ledger" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."battle_gifts" FOR SELECT TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."battle_history" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."battle_rewards" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."broadcast_cycle_stats" FOR SELECT TO "authenticated" USING (("broadcaster_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."broadcast_seats" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."broadcast_tokens" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."broadcaster_applications" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."broadcaster_metrics" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."call_history" FOR SELECT TO "authenticated" USING (("receiver_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."call_minutes" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."call_sessions" FOR SELECT TO "authenticated" USING (("receiver_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."call_transactions" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."cashout_requests" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."coin_ledger" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."coin_pool_contributions" FOR SELECT TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."coin_purchases" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."coinback_log" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."court_box_members" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."court_sessions" FOR SELECT TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."court_summons" FOR SELECT TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."daily_giveaways" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."daily_rewards" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."earnings" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."economy_abuse_flags" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."error_logs" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."executive_reports" FOR SELECT TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."family_lounge_messages" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."gift_bonus_tracker" FOR SELECT TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."gifts" FOR SELECT TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."gifts_owned" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."group_chats" FOR SELECT TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."home_feature_spend" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."hr_employees" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."hr_notes" FOR SELECT TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."identity_reward_logs" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."interview_sessions" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."job_applications" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."mai_incidents" FOR SELECT TO "authenticated" USING (("host_user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."mai_overrides" FOR SELECT TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."mai_user_memory" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."message_requests" FOR SELECT TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."messages" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."moderation_notes" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."notifications" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."officer_applications" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."officer_badges" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."officer_chat" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."officer_chat_messages" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."officer_quiz_attempts" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."onboarding_events" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."onboarding_progress" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."owc_transactions" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."payment_methods" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."payment_transactions" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."payout_requests" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."payout_reviews" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."payout_settings" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."payouts" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."platform_fees" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."post_gifts" FOR SELECT TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."posts" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."punishment_transactions" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."punishments" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."referrals" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."report_cases" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."revenue_ledger" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."scheduled_announcements" FOR SELECT TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."security_events" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."shifts" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."shop_partners" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."shop_transactions" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."shops" FOR SELECT TO "authenticated" USING (("owner_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."staff_applications" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."staff_profiles" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."stream_entrances" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."stream_entries" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."stream_events" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."stream_gifts" FOR SELECT TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."stream_join_requests" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."stream_likes" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."stream_messages" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."stream_participants" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."stream_presets" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."stream_reactions" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."stream_snack_purchases" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."streams" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."streams_participants" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."support_tickets" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."task_completions" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."task_history" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."tax_report_status" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."transactions" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_battle_gifts" FOR SELECT TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_dna_events" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_dna_profiles" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_drops" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_drops_log" FOR SELECT TO "authenticated" USING (("broadcaster_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_family_members" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_family_messages" FOR SELECT TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_officer_applications" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_officers" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_post_comments" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_post_gifts" FOR SELECT TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_post_reactions" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_post_views" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_posts" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_stream_messages" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_streams" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_wall_likes" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."troll_wall_posts" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."trollcity_shops" FOR SELECT TO "authenticated" USING (("owner_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."trollmond_ledger" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."trolls_night_applications" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."trollstown_properties" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."trollstown_property_upgrades" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."trolltract_contracts" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."tromody_queue" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."tromody_sessions" FOR SELECT TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."trophies" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."typing_statuses" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."user_active_items" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."user_agreements" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."user_balances" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."user_bans" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."user_devices" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."user_entrances" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."user_insurance" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."user_inventory" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."user_ip_tracking" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."user_levels" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."user_payment_methods" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."user_payout_settings" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."user_roles" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."user_wallets" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."verification_requests" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."verification_transactions" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_select_own" ON "public"."wall_posts" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."activity_log" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."activity_logs" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."admin_coin_revenue" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."admin_flags" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."admin_tax_reviews" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."admin_top_buyers" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."ai_action_logs" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."applications" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."balance_ledger" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."battle_gifts" FOR UPDATE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."battle_history" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."battle_rewards" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."broadcast_cycle_stats" FOR UPDATE TO "authenticated" USING (("broadcaster_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("broadcaster_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."broadcast_seats" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."broadcast_tokens" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."broadcaster_applications" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."broadcaster_metrics" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."call_history" FOR UPDATE TO "authenticated" USING (("receiver_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("receiver_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."call_minutes" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."call_sessions" FOR UPDATE TO "authenticated" USING (("receiver_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("receiver_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."call_transactions" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."cashout_requests" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."coin_ledger" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."coin_pool_contributions" FOR UPDATE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."coin_purchases" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."coin_transactions" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."coinback_log" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."court_box_members" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."court_sessions" FOR UPDATE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."court_summons" FOR UPDATE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."daily_giveaways" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."daily_rewards" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."earnings" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."economy_abuse_flags" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."empire_applications" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."error_logs" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."executive_reports" FOR UPDATE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."family_lounge_messages" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."gift_bonus_tracker" FOR UPDATE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."gifts" FOR UPDATE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."gifts_owned" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."group_chats" FOR UPDATE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."home_feature_spend" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."hr_employees" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."hr_notes" FOR UPDATE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."identity_reward_logs" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."interview_sessions" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."job_applications" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."lucky_coin_events" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."mai_incidents" FOR UPDATE TO "authenticated" USING (("host_user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("host_user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."mai_overrides" FOR UPDATE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."mai_user_memory" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."message_requests" FOR UPDATE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."messages" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid"))) WITH CHECK (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."moderation_notes" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."notifications" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."officer_applications" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."officer_badges" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."officer_chat" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."officer_chat_messages" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."officer_quiz_attempts" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."onboarding_events" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."onboarding_progress" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."owc_transactions" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."payment_methods" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."payment_transactions" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."payout_requests" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid"))) WITH CHECK (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."payout_reviews" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."payout_settings" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."payouts" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."platform_fees" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."post_gifts" FOR UPDATE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."posts" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."promo_code_uses" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."punishment_transactions" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."punishments" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."referrals" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."report_cases" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."revenue_ledger" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."scheduled_announcements" FOR UPDATE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."security_events" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."shifts" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."shop_partners" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."shop_transactions" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."shops" FOR UPDATE TO "authenticated" USING (("owner_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("owner_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."staff_applications" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."staff_profiles" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."stream_entrances" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."stream_entries" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."stream_events" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."stream_gifts" FOR UPDATE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."stream_join_requests" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."stream_likes" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."stream_messages" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."stream_participants" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."stream_presets" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."stream_reactions" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."stream_snack_purchases" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."streams" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."streams_participants" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."support_tickets" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."task_completions" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."task_history" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."tax_report_status" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."transactions" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_battle_gifts" FOR UPDATE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_dna_events" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_dna_profiles" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_drops" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_drops_log" FOR UPDATE TO "authenticated" USING (("broadcaster_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("broadcaster_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_family_members" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_family_messages" FOR UPDATE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_officer_applications" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_officers" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_post_comments" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_post_gifts" FOR UPDATE TO "authenticated" USING (("sender_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("sender_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_post_reactions" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_post_views" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_posts" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_stream_messages" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_streams" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_wall_likes" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."troll_wall_posts" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."trollcity_shops" FOR UPDATE TO "authenticated" USING (("owner_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("owner_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."trollmond_ledger" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."trolls_night_applications" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."trollstown_properties" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."trollstown_property_upgrades" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."trolltract_contracts" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid"))) WITH CHECK (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."tromody_queue" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."tromody_sessions" FOR UPDATE TO "authenticated" USING (("created_by" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("created_by" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."trophies" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."typing_statuses" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."user_active_items" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."user_agreements" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."user_balances" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."user_bans" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."user_devices" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."user_entrances" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."user_insurance" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."user_inventory" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."user_ip_tracking" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."user_levels" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."user_payment_methods" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."user_payout_settings" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."user_roles" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."user_wallets" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."verification_requests" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."verification_transactions" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "auth_update_own" ON "public"."wall_posts" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "authenticated can update stream likes" ON "public"."streams" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "owner_id")) WITH CHECK (("auth"."uid"() = "owner_id"));



CREATE POLICY "authenticated_users_can_insert_messages" ON "public"."messages" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "sender_id"));



CREATE POLICY "authenticated_users_can_insert_streams" ON "public"."streams" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "owner_id"));



CREATE POLICY "authenticated_users_can_view_messages" ON "public"."messages" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."badge_definitions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."balance_ledger" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."battle_gifts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."battle_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."battle_rewards" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."battle_sessions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."blocked_users" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."broadcast_background_themes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."broadcast_cycle_stats" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."broadcast_seats" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "broadcast_seats_paid_delete" ON "public"."broadcast_seats" FOR DELETE TO "authenticated" USING ("public"."is_paid_user"("auth"."uid"()));



CREATE POLICY "broadcast_seats_paid_insert" ON "public"."broadcast_seats" FOR INSERT TO "authenticated" WITH CHECK ("public"."is_paid_user"("auth"."uid"()));



CREATE POLICY "broadcast_seats_paid_update" ON "public"."broadcast_seats" FOR UPDATE TO "authenticated" USING ("public"."is_paid_user"("auth"."uid"())) WITH CHECK ("public"."is_paid_user"("auth"."uid"()));



CREATE POLICY "broadcast_theme_catalog_admin_write" ON "public"."broadcast_background_themes" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true)))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "broadcast_theme_catalog_read" ON "public"."broadcast_background_themes" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "broadcast_theme_purchases_insert" ON "public"."user_broadcast_theme_purchases" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "broadcast_theme_purchases_read" ON "public"."user_broadcast_theme_purchases" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "broadcast_theme_state_insert" ON "public"."user_broadcast_theme_state" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "broadcast_theme_state_read" ON "public"."user_broadcast_theme_state" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "broadcast_theme_state_update" ON "public"."user_broadcast_theme_state" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."broadcast_tokens" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."broadcaster_applications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."broadcaster_earnings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."broadcaster_metrics" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "broadcasters_and_admins_can_delete_streams" ON "public"."streams" FOR DELETE TO "authenticated" USING ((("broadcaster_id" = ( SELECT "auth"."uid"() AS "uid")) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true)))))));



CREATE POLICY "broadcasters_and_admins_can_update_streams" ON "public"."streams" FOR UPDATE TO "authenticated" USING ((("broadcaster_id" = ( SELECT "auth"."uid"() AS "uid")) OR (EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true)))))));



CREATE POLICY "buyers can request transfer to self" ON "public"."deed_transfers" FOR INSERT TO "authenticated" WITH CHECK (("to_user_id" = "auth"."uid"()));



ALTER TABLE "public"."call_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "call_history_admin_view_all" ON "public"."call_history" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = "auth"."uid"()) AND (("up"."role" = 'admin'::"text") OR ("up"."is_admin" = true) OR ("up"."role" = 'lead_troll_officer'::"text") OR ("up"."is_lead_officer" = true))))));



COMMENT ON POLICY "call_history_admin_view_all" ON "public"."call_history" IS 'Admins and lead officers can view all calls';



CREATE POLICY "call_history_insert_own" ON "public"."call_history" FOR INSERT TO "authenticated" WITH CHECK ((("caller_id" = ( SELECT "auth"."uid"() AS "uid")) OR ("receiver_id" = ( SELECT "auth"."uid"() AS "uid"))));



CREATE POLICY "call_history_select_own" ON "public"."call_history" FOR SELECT TO "authenticated" USING ((("caller_id" = ( SELECT "auth"."uid"() AS "uid")) OR ("receiver_id" = ( SELECT "auth"."uid"() AS "uid"))));



ALTER TABLE "public"."call_minutes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."call_sessions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."call_sound_catalog" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "call_sound_catalog_admin_write" ON "public"."call_sound_catalog" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true)))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = "auth"."uid"()) AND (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true))))));



CREATE POLICY "call_sound_catalog_read" ON "public"."call_sound_catalog" FOR SELECT USING (true);



ALTER TABLE "public"."call_transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."case_audit_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."case_evidence" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."case_participants" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."case_templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."cashout_requests" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."cashout_tiers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."city_districts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."city_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."clan_rewards" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."clan_vault" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."coin_ledger" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."coin_packages" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "coin_packages_admin_only" ON "public"."coin_packages" FOR INSERT WITH CHECK (("auth"."uid"() IN ( SELECT "user_profiles"."id"
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true)))));



CREATE POLICY "coin_packages_admin_update" ON "public"."coin_packages" FOR UPDATE USING (("auth"."uid"() IN ( SELECT "user_profiles"."id"
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."role" = 'admin'::"text") OR ("user_profiles"."is_admin" = true)))));



CREATE POLICY "coin_packages_public_read" ON "public"."coin_packages" FOR SELECT USING (("is_active" = true));



ALTER TABLE "public"."coin_pool_contributions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."coin_purchases" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."coin_reward_pool" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."coin_transactions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "coin_transactions_service_insert" ON "public"."coin_transactions" FOR INSERT WITH CHECK ((( SELECT "count"(*) AS "count"
   FROM "information_schema"."tables") > 0));



CREATE POLICY "coin_transactions_update_owner" ON "public"."coin_transactions" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id")) WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "coin_transactions_user_read" ON "public"."coin_transactions" FOR SELECT USING (("user_id" = "auth"."uid"()));



ALTER TABLE "public"."coinback_log" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."config" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."content" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."conversation_members" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."conversation_messages" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "conversation_messages_insert_sender_is_member" ON "public"."conversation_messages" FOR INSERT WITH CHECK ((("sender_id" = "auth"."uid"()) AND (EXISTS ( SELECT 1
   FROM "public"."conversation_members" "cm"
  WHERE (("cm"."conversation_id" = "conversation_messages"."conversation_id") AND ("cm"."user_id" = "auth"."uid"()))))));



CREATE POLICY "conversation_messages_select_member" ON "public"."conversation_messages" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."conversation_members" "cm"
  WHERE (("cm"."conversation_id" = "conversation_messages"."conversation_id") AND ("cm"."user_id" = "auth"."uid"())))));



ALTER TABLE "public"."conversations" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "conversations_select_member" ON "public"."conversations" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."conversation_members" "cm"
  WHERE (("cm"."conversation_id" = "conversations"."id") AND ("cm"."user_id" = "auth"."uid"())))));



ALTER TABLE "public"."court_box_members" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "court_box_members_select" ON "public"."court_box_members" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."court_cases" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."court_docket" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."court_rulings_archive" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."court_schedules" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."court_sessions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "court_sessions_delete_judge" ON "public"."court_sessions" FOR DELETE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "judge_id"));



CREATE POLICY "court_sessions_insert_allowed" ON "public"."court_sessions" FOR INSERT TO "authenticated" WITH CHECK (((( SELECT "auth"."uid"() AS "uid") = "accuser_id") OR (( SELECT "auth"."uid"() AS "uid") = "judge_id")));



CREATE POLICY "court_sessions_select_participants" ON "public"."court_sessions" FOR SELECT TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "accuser_id") OR (( SELECT "auth"."uid"() AS "uid") = "defendant_id") OR (( SELECT "auth"."uid"() AS "uid") = "judge_id")));



CREATE POLICY "court_sessions_update_judge" ON "public"."court_sessions" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "judge_id")) WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "judge_id"));



ALTER TABLE "public"."court_summons" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "court_summons_delete_accuser" ON "public"."court_summons" FOR DELETE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "accuser_id"));



CREATE POLICY "court_summons_insert_accuser" ON "public"."court_summons" FOR INSERT TO "authenticated" WITH CHECK (((( SELECT "auth"."uid"() AS "uid") = "accuser_id") OR (( SELECT "auth"."uid"() AS "uid") = "judge_id")));



CREATE POLICY "court_summons_select_participants" ON "public"."court_summons" FOR SELECT TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "accuser_id") OR (( SELECT "auth"."uid"() AS "uid") = "defendant_id") OR (( SELECT "auth"."uid"() AS "uid") = "judge_id")));



CREATE POLICY "court_summons_update_participants" ON "public"."court_summons" FOR UPDATE TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "accuser_id") OR (( SELECT "auth"."uid"() AS "uid") = "defendant_id") OR (( SELECT "auth"."uid"() AS "uid") = "judge_id"))) WITH CHECK (((( SELECT "auth"."uid"() AS "uid") = "accuser_id") OR (( SELECT "auth"."uid"() AS "uid") = "defendant_id") OR (( SELECT "auth"."uid"() AS "uid") = "judge_id")));



CREATE POLICY "creator update session" ON "public"."tromody_sessions" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "created_by"));



ALTER TABLE "public"."creator_applications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."creator_migration_claims" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."creators_over_600" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."critical_alerts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."daily_giveaways" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."daily_rewards" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."declined_transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."deed_transfers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."deeds" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "deeds insert own" ON "public"."deeds" FOR INSERT TO "authenticated" WITH CHECK ((("owner_user_id" = "auth"."uid"()) AND ("current_owner_user_id" = "auth"."uid"())));



CREATE POLICY "deeds insert when owned" ON "public"."deeds" FOR INSERT TO "authenticated" WITH CHECK ((("owner_user_id" = "auth"."uid"()) AND ("current_owner_user_id" = "auth"."uid"())));



CREATE POLICY "deeds select own" ON "public"."deeds" FOR SELECT TO "authenticated" USING (("owner_user_id" = "auth"."uid"()));



CREATE POLICY "deeds update own" ON "public"."deeds" FOR UPDATE TO "authenticated" USING (("owner_user_id" = "auth"."uid"())) WITH CHECK (("owner_user_id" = "auth"."uid"()));



CREATE POLICY "deny_all" ON "public"."abuse_reports" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."admin_adjustments" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."admin_broadcasts" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."app_settings" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."app_updates" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."battle_sessions" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."blocked_users" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."cashout_tiers" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."clan_rewards" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."clan_vault" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."coin_reward_pool" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."config" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."content" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."court_cases" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."court_schedules" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."creators_over_600" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."critical_alerts" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."empire_partner_rewards" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."empire_referrals" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."empire_rewards" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."escalation_reports" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."executive_intake" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."family_invites" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."family_tasks_new" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."family_wars" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."follows" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."ghost_presence_logs" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."gift_catalog" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."gift_items" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."gift_transactions" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."giftcard_fulfillments" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."hire_fire_actions" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."hire_limits" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."home_feature_cycles" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."hr_events" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."incidents" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."insurance" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."insurance_packages" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."insurance_plans" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."inventory_items" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."ip_bans" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."kick_logs" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."mai_appeals" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."mai_timeline_events" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."marketplace_items" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."moderation_actions" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."moderation_events" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."moderation_fee_settings" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."moderation_reports" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."observer_ratings" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."officer_activity" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."officer_availability" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."officer_hours" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."officer_live_assignments" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."officer_logs" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."officer_mission_logs" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."officer_quiz_questions" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."officer_quiz_results" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."officer_shift_logs" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."officer_shift_slots" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."officer_shifts" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."officer_strikes" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."officer_training_sessions" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."officer_weekly_reports" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."officer_work_sessions" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."payment_fees" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."platform_wallet" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."profiles" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."promo_codes" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."provider_costs" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."referral_monthly_bonus" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."role_change_log" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."role_privileges" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."roles" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."secretary_assignments" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."shadow_bans" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."shop_items" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."special_gift_earnings" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."store_items" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."stream_momentum" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."stream_mute_counts" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."stream_reports" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."stream_sessions" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."stream_vods" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."task_templates" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."training_scenarios" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."troll_ai_avatars" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."troll_battles" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."troll_court_cases" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."troll_dna_traits" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."troll_family_wars" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."troll_gift_items" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."trollcity_orders" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."trollcity_products" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."trollmonds_pools" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."trollstown_upgrade_config" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."trolltract_weekly_rewards" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."tromody_gifts" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."tromody_matches" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."user_follows" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."users" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."vendor_invoices" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."videos" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."war_results" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."wars" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."weekly_officer_reports" USING (false) WITH CHECK (false);



CREATE POLICY "deny_all" ON "public"."weekly_reports" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."battle_gifts" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."broadcast_cycle_stats" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."economy_abuse_flags" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."mai_incidents" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."messages" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."notifications" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."platform_fees" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."stream_entries" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."stream_events" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."stream_gifts" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."stream_likes" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."stream_messages" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."stream_participants" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."stream_reactions" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."stream_snack_purchases" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."streams" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."troll_drops" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."troll_post_comments" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."troll_wall_likes" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."troll_wall_posts" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."trollmond_ledger" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."tromody_sessions" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."user_ip_tracking" USING (false) WITH CHECK (false);



CREATE POLICY "deny_public_all" ON "public"."wall_posts" USING (false) WITH CHECK (false);



ALTER TABLE "public"."district_announcements" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."district_features" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "dna_traits_select_all" ON "public"."troll_dna_traits" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "dna_update_self" ON "public"."troll_dna_profiles" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



ALTER TABLE "public"."earnings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."economy_abuse_flags" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."empire_applications" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "empire_applications_insert_own" ON "public"."empire_applications" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "empire_applications_select_own" ON "public"."empire_applications" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "empire_applications_update_own" ON "public"."empire_applications" FOR UPDATE USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "empire_apps_delete_self_pending" ON "public"."empire_applications" FOR DELETE TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "user_id") AND ("status" = 'pending'::"text")));



CREATE POLICY "empire_apps_insert_self" ON "public"."empire_applications" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "applicant_id"));



CREATE POLICY "empire_apps_select_self" ON "public"."empire_applications" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "applicant_id"));



CREATE POLICY "empire_apps_update_self_pending" ON "public"."empire_applications" FOR UPDATE TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "user_id") AND ("status" = 'pending'::"text"))) WITH CHECK (((( SELECT "auth"."uid"() AS "uid") = "user_id") AND ("status" = 'pending'::"text")));



ALTER TABLE "public"."empire_partner_rewards" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."empire_partners" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."empire_referrals" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."empire_rewards" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."entrance_effects" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "entrance_insert" ON "public"."user_entrance_effects" FOR INSERT WITH CHECK ((("auth"."uid"() = "user_id") OR ("auth"."role"() = 'service_role'::"text")));



ALTER TABLE "public"."error_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."escalation_matrix" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."escalation_reports" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."event_participants" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."executive_intake" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."executive_reports" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."families" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_activity_log" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_badges_earned" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_boosts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_invites" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_lounge_messages" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_members" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_seasons" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_shop_items" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_shop_purchases" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_stats" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_tasks" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_tasks_new" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_war_stats" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."family_wars" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "family_wars_insert_auth" ON "public"."family_wars" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "family_wars_select_all" ON "public"."family_wars" FOR SELECT USING (true);



CREATE POLICY "family_wars_update_auth" ON "public"."family_wars" FOR UPDATE USING (("auth"."role"() = 'authenticated'::"text"));



ALTER TABLE "public"."follows" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "follows_delete_self" ON "public"."follows" FOR DELETE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "follower_id"));



CREATE POLICY "follows_insert_self" ON "public"."follows" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "follower_id"));



CREATE POLICY "follows_insert_self" ON "public"."user_follows" FOR INSERT TO "authenticated" WITH CHECK (("follower_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "follows_select" ON "public"."user_follows" FOR SELECT TO "authenticated" USING ((("follower_id" = ( SELECT "auth"."uid"() AS "uid")) OR ("following_id" = ( SELECT "auth"."uid"() AS "uid"))));



ALTER TABLE "public"."ghost_presence_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_bonus_tracker" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_card_redemptions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_cards" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_catalog" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_items" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_leaderboard_entries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_leaderboards" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."gift_xp_stats" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."giftcard_fulfillments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."gifts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."gifts_owned" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "gifts_select" ON "public"."gifts" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."group_chats" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."hire_fire_actions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."hire_limits" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."home_feature_cycles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."home_feature_spend" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."honorary_family_members" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."hr_employees" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."hr_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."hr_notes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."identity_reward_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."incidents" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "insert own gift" ON "public"."tromody_gifts" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "from_user_id"));



CREATE POLICY "insert own session" ON "public"."tromody_sessions" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "created_by"));



ALTER TABLE "public"."insurance" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "insurance_insert" ON "public"."user_insurances" FOR INSERT WITH CHECK ((("auth"."uid"() = "user_id") OR ("auth"."role"() = 'service_role'::"text")));



ALTER TABLE "public"."insurance_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."insurance_options" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."insurance_packages" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."insurance_plans" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."interview_sessions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."inventory_items" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "inventory_items_delete_policy" ON "public"."inventory_items" FOR DELETE TO "authenticated" USING ((( SELECT "auth"."role"() AS "role") = 'service_role'::"text"));



CREATE POLICY "inventory_items_insert_policy" ON "public"."inventory_items" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."role"() AS "role") = 'service_role'::"text"));



CREATE POLICY "inventory_items_select_policy" ON "public"."inventory_items" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."role"() AS "role") = 'authenticated'::"text"));



CREATE POLICY "inventory_items_update_policy" ON "public"."inventory_items" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."role"() AS "role") = 'service_role'::"text"));



ALTER TABLE "public"."ip_bans" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."job_applications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."kick_logs" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "lounge_messages_select" ON "public"."family_lounge_messages" FOR SELECT TO "authenticated" USING (("family_id" IN ( SELECT "family_members"."family_id"
   FROM "public"."family_members"
  WHERE ("family_members"."user_id" = ( SELECT "auth"."uid"() AS "uid")))));



ALTER TABLE "public"."lucky_coin_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mai_appeals" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mai_incidents" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mai_overrides" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mai_timeline_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mai_user_memory" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."marketplace_items" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "members_select_member" ON "public"."conversation_members" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."conversation_members" "cm"
  WHERE (("cm"."conversation_id" = "conversation_members"."conversation_id") AND ("cm"."user_id" = "auth"."uid"())))));



ALTER TABLE "public"."message_receipts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."message_requests" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "message_requests_insert_own" ON "public"."message_requests" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "sender_id"));



CREATE POLICY "message_requests_select_own" ON "public"."message_requests" FOR SELECT TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "sender_id") OR (( SELECT "auth"."uid"() AS "uid") = "receiver_id")));



CREATE POLICY "message_requests_update_own" ON "public"."message_requests" FOR UPDATE TO "authenticated" USING (((( SELECT "auth"."uid"() AS "uid") = "sender_id") OR (( SELECT "auth"."uid"() AS "uid") = "receiver_id")));



ALTER TABLE "public"."messages" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "messages_insert_own" ON "public"."messages" FOR INSERT TO "authenticated" WITH CHECK ((("sender_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")) OR (("sender_id" IS NULL) AND ("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")))));



CREATE POLICY "messages_insert_self" ON "public"."messages" FOR INSERT TO "authenticated" WITH CHECK ((("sender_id" = "auth"."uid"()) OR ("user_id" = "auth"."uid"()) OR (("sender_id" IS NULL) AND ("user_id" = "auth"."uid"()))));



COMMENT ON POLICY "messages_insert_self" ON "public"."messages" IS 'Users can insert messages where they are the sender (sender_id) or the user (user_id)';



CREATE POLICY "messages_insert_sender" ON "public"."messages" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid") = "sender_id"));



CREATE POLICY "messages_paid_insert" ON "public"."messages" FOR INSERT WITH CHECK ("public"."is_paid_user"("auth"."uid"()));



CREATE POLICY "messages_select_own" ON "public"."messages" FOR SELECT TO "authenticated" USING ((("sender_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")) OR ("receiver_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")) OR ("stream_id" IS NOT NULL) OR (( SELECT ( SELECT "auth"."role"() AS "role") AS "role") = 'service_role'::"text")));



CREATE POLICY "messages_update_own" ON "public"."messages" FOR UPDATE TO "authenticated" USING (("receiver_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid"))) WITH CHECK (("receiver_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "messages_update_receiver" ON "public"."messages" FOR UPDATE TO "authenticated" USING ((( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid") = "receiver_id")) WITH CHECK ((( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid") = "receiver_id"));



ALTER TABLE "public"."millionaire_hall_of_fame" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."moderation_actions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."moderation_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."moderation_fee_settings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."moderation_notes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."moderation_reports" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."notifications" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "notifications insert admin" ON "public"."notifications" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."jwt"() ->> 'email'::"text") = 'trollcity2025@gmail.com'::"text"));



CREATE POLICY "notifications read own" ON "public"."user_notifications" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "notifications_select_own" ON "public"."notifications" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "notifications_service_insert" ON "public"."notifications" FOR INSERT TO "service_role" WITH CHECK (true);



ALTER TABLE "public"."observer_ratings" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "officer admin update" ON "public"."tromody_sessions" FOR UPDATE TO "authenticated" USING ("public"."is_officer_or_admin"());



ALTER TABLE "public"."officer_actions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_activity" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_applications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_availability" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_badges" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_chat" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "officer_chat_insert" ON "public"."officer_chat" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."role"() AS "role") = 'authenticated'::"text"));



CREATE POLICY "officer_chat_insert" ON "public"."officer_chat_messages" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") IN ( SELECT "user_profiles"."id"
   FROM "public"."user_profiles"
  WHERE ("user_profiles"."role" = ANY (ARRAY['troll_officer'::"text", 'admin'::"text"])))));



ALTER TABLE "public"."officer_chat_messages" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "officer_chat_read" ON "public"."officer_chat" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."role"() AS "role") = 'authenticated'::"text"));



ALTER TABLE "public"."officer_earnings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_hours" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_live_assignments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_mission_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_orientation_results" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_orientations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_payouts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_performance" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_quiz_attempts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_quiz_questions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_quiz_results" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_shift_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_shift_slots" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "officer_shift_slots_insert_admin" ON "public"."officer_shift_slots" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_profiles" "up"
  WHERE (("up"."id" = "auth"."uid"()) AND (("up"."is_admin" = true) OR ("up"."is_lead_officer" = true))))));



ALTER TABLE "public"."officer_shifts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_stream_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_strikes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_training_sessions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_weekly_reports" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."officer_work_sessions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."onboarding_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."onboarding_progress" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."owc_transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payment_fees" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payment_holds" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payment_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payment_methods" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payment_transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payout_audit_log" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payout_requests" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "payout_requests_insert_own" ON "public"."payout_requests" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "payout_requests_select_own" ON "public"."payout_requests" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "payout_requests_service" ON "public"."payout_requests" TO "authenticated" USING ((( SELECT ( SELECT "auth"."role"() AS "role") AS "role") = 'service_role'::"text"));



ALTER TABLE "public"."payout_reviews" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payout_settings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payouts" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "payouts_insert_self" ON "public"."payout_requests" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "payouts_select" ON "public"."payout_requests" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT ( SELECT "auth"."uid"() AS "uid") AS "uid")));



CREATE POLICY "payouts_self_insert" ON "public"."payouts" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



ALTER TABLE "public"."perks" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "perks_insert" ON "public"."user_perks" FOR INSERT WITH CHECK ((("auth"."uid"() = "user_id") OR ("auth"."role"() = 'service_role'::"text")));



ALTER TABLE "public"."platform_fees" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "platform_fees_select_on_auth" ON "public"."platform_fees" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."platform_wallet" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."post_gifts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."posts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "profiles insert own" ON "public"."profiles" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "profiles select own" ON "public"."profiles" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "profiles update own" ON "public"."profiles" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



ALTER TABLE "public"."promo_code_uses" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."promo_codes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."provider_costs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."punishment_transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."punishments" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "read own notifications" ON "public"."notifications" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "read streams staff or streamer" ON "public"."streams" FOR SELECT TO "authenticated" USING (("public"."is_staff"() OR ("streamer_id" = ( SELECT "auth"."uid"() AS "uid"))));



CREATE POLICY "read_authenticated" ON "public"."badge_definitions" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "read_authenticated" ON "public"."gift_leaderboard_entries" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "read_authenticated" ON "public"."gift_leaderboards" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "read_authenticated" ON "public"."millionaire_hall_of_fame" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "receipts_select_own" ON "public"."message_receipts" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "receipts_select_sender" ON "public"."message_receipts" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."conversation_messages" "m"
  WHERE (("m"."id" = "message_receipts"."message_id") AND ("m"."sender_id" = "auth"."uid"())))));



CREATE POLICY "receipts_update_own" ON "public"."message_receipts" FOR UPDATE USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



ALTER TABLE "public"."referral_claims" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."referral_monthly_bonus" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."referrals" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."report_cases" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."reputation_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."revenue_ledger" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."revenue_settings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."risk_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."role_change_log" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."role_privileges" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."roles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."royal_family_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."royal_family_perks" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."royal_family_titles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."scheduled_announcements" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."secretary_assignments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."security_events" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "select_own_tax_info" ON "public"."user_tax_info" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



ALTER TABLE "public"."seller_reliability" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "service_role_delete" ON "public"."gift_leaderboard_entries" FOR DELETE TO "authenticated" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "service_role_insert" ON "public"."gift_leaderboard_entries" FOR INSERT TO "authenticated" WITH CHECK (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "service_role_only" ON "public"."system_settings" TO "authenticated" USING (("auth"."role"() = 'service_role'::"text")) WITH CHECK (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "service_role_update" ON "public"."gift_leaderboard_entries" FOR UPDATE TO "authenticated" USING (("auth"."role"() = 'service_role'::"text")) WITH CHECK (("auth"."role"() = 'service_role'::"text"));



ALTER TABLE "public"."shadow_bans" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."shifts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."shop_items" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."shop_partners" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."shop_transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."shops" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."special_gift_earnings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."square_events" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "staff can read moderation_actions" ON "public"."moderation_actions" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_profiles"
  WHERE (("user_profiles"."id" = ( SELECT "auth"."uid"() AS "uid")) AND (("user_profiles"."role" = ANY (ARRAY['admin'::"text", 'lead_troll_officer'::"text", 'troll_officer'::"text", 'secretary'::"text"])) OR ("user_profiles"."is_admin" = true) OR ("user_profiles"."is_lead_officer" = true) OR ("user_profiles"."is_troll_officer" = true))))));



ALTER TABLE "public"."staff_applications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."staff_profiles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."store_items" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stores" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_discovery_prefs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_entrances" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_entries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_gifts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_join_requests" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_likes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_messages" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_momentum" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "stream_momentum_insert" ON "public"."stream_momentum" FOR INSERT TO "authenticated" WITH CHECK (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "stream_momentum_read" ON "public"."stream_momentum" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "stream_momentum_update" ON "public"."stream_momentum" FOR UPDATE TO "authenticated" USING (("auth"."role"() = 'service_role'::"text")) WITH CHECK (("auth"."role"() = 'service_role'::"text"));



ALTER TABLE "public"."stream_mute_counts" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "stream_mute_counts_insert" ON "public"."stream_mute_counts" FOR INSERT TO "authenticated" WITH CHECK (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "stream_mute_counts_select" ON "public"."stream_mute_counts" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "stream_mute_counts_update" ON "public"."stream_mute_counts" FOR UPDATE TO "authenticated" USING (("auth"."role"() = 'service_role'::"text")) WITH CHECK (("auth"."role"() = 'service_role'::"text"));



ALTER TABLE "public"."stream_participants" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_passwords" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "stream_passwords_owner_delete" ON "public"."stream_passwords" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM "public"."streams" "s"
  WHERE (("s"."id" = "stream_passwords"."stream_id") AND ("s"."broadcaster_id" = "auth"."uid"())))));



CREATE POLICY "stream_passwords_owner_insert" ON "public"."stream_passwords" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."streams" "s"
  WHERE (("s"."id" = "stream_passwords"."stream_id") AND ("s"."broadcaster_id" = "auth"."uid"())))));



CREATE POLICY "stream_passwords_owner_select" ON "public"."stream_passwords" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."streams" "s"
  WHERE (("s"."id" = "stream_passwords"."stream_id") AND ("s"."broadcaster_id" = "auth"."uid"())))));



CREATE POLICY "stream_passwords_owner_update" ON "public"."stream_passwords" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."streams" "s"
  WHERE (("s"."id" = "stream_passwords"."stream_id") AND ("s"."broadcaster_id" = "auth"."uid"()))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."streams" "s"
  WHERE (("s"."id" = "stream_passwords"."stream_id") AND ("s"."broadcaster_id" = "auth"."uid"())))));



ALTER TABLE "public"."stream_presets" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_ranking" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_reactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_reports" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "stream_reports_insert_self" ON "public"."stream_reports" FOR INSERT TO "authenticated" WITH CHECK (("reporter_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "stream_reports_select" ON "public"."stream_reports" FOR SELECT TO "authenticated" USING (("reporter_id" = ( SELECT "auth"."uid"() AS "uid")));



ALTER TABLE "public"."stream_sessions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_snack_purchases" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stream_vods" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "streamer_entitlements_read_own" ON "public"."user_streamer_entitlements" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "streamer_entitlements_update_own" ON "public"."user_streamer_entitlements" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "streamer_entitlements_upsert_own" ON "public"."user_streamer_entitlements" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



ALTER TABLE "public"."streams" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "streams_insert_own" ON "public"."streams" FOR INSERT WITH CHECK (("broadcaster_id" = "auth"."uid"()));



ALTER TABLE "public"."streams_participants" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "streams_select" ON "public"."streams" FOR SELECT USING (true);



CREATE POLICY "streams_update_own" ON "public"."streams" FOR UPDATE USING (("broadcaster_id" = "auth"."uid"())) WITH CHECK (("broadcaster_id" = "auth"."uid"()));



ALTER TABLE "public"."support_tickets" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."system_alerts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."system_errors" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."system_settings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."task_completions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."task_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."task_templates" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "tasks_select" ON "public"."family_tasks_new" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."tax_report_status" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "theme_purchases_insert_own" ON "public"."user_broadcast_theme_purchases" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "theme_purchases_read_own" ON "public"."user_broadcast_theme_purchases" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "theme_state_read_own" ON "public"."user_broadcast_theme_state" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "theme_state_update_own" ON "public"."user_broadcast_theme_state" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "theme_state_upsert_own" ON "public"."user_broadcast_theme_state" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "themes_read_all" ON "public"."broadcast_background_themes" FOR SELECT TO "authenticated" USING (("is_active" = true));



ALTER TABLE "public"."ticket_messages" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."training_scenarios" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_ai_avatars" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_battle_gifts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_battles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_court_cases" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_dna_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_dna_profiles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_dna_traits" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_drops" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_drops_log" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_event_claims" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_families" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_family_members" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "troll_family_members_select" ON "public"."troll_family_members" FOR SELECT TO "authenticated" USING ((("user_id" = ( SELECT "auth"."uid"() AS "uid")) OR ("family_id" IN ( SELECT "troll_family_members_1"."family_id"
   FROM "public"."troll_family_members" "troll_family_members_1"
  WHERE ("troll_family_members_1"."user_id" = ( SELECT "auth"."uid"() AS "uid"))))));



ALTER TABLE "public"."troll_family_memberships" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_family_messages" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_family_wars" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_gift_items" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_officer_applications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_officers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_post_comments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_post_gifts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_post_reactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_post_views" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_posts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_stream_messages" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_streams" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_wall_gifts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_wall_likes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_wall_posts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."troll_wall_reactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollcity_orders" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollcity_products" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollcity_shops" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollmond_ledger" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollmonds_pools" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."trolls_night_applications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollstown_properties" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollstown_property_upgrades" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."trollstown_upgrade_config" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."trolltract_contracts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."trolltract_weekly_rewards" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tromody_battles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tromody_gifts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tromody_matches" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tromody_queue" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tromody_sessions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."trophies" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."typing_statuses" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "ul_update_self" ON "public"."user_levels" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "update streams staff only" ON "public"."streams" FOR UPDATE TO "authenticated" USING ("public"."is_staff"());



CREATE POLICY "update_own_tax_info" ON "public"."user_tax_info" FOR UPDATE TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid"))) WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "upsert_own_tax_info" ON "public"."user_tax_info" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



ALTER TABLE "public"."user_active_items" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_agreements" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_badges_earned" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_balances" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_bans" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_boosts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_broadcast_theme_purchases" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_broadcast_theme_state" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_call_sounds" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "user_call_sounds_read" ON "public"."user_call_sounds" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "user_call_sounds_write" ON "public"."user_call_sounds" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."user_devices" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_district_progress" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_entrance_effects" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_entrances" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_follows" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_insurance" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_insurances" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_inventory" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "user_inventory_delete_policy" ON "public"."user_inventory" FOR DELETE TO "authenticated" USING ((( SELECT "auth"."role"() AS "role") = 'service_role'::"text"));



CREATE POLICY "user_inventory_insert" ON "public"."user_inventory" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "user_inventory_select" ON "public"."user_inventory" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "user_inventory_service" ON "public"."user_inventory" TO "authenticated" USING ((( SELECT "auth"."role"() AS "role") = 'service_role'::"text"));



CREATE POLICY "user_inventory_update" ON "public"."user_inventory" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



ALTER TABLE "public"."user_ip_tracking" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_levels" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_notifications" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "user_own_all" ON "public"."user_badges_earned" TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "user_own_all" ON "public"."user_boosts" TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



ALTER TABLE "public"."user_payment_methods" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_payout_settings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_perks" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_profiles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_reputation" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_risk_profile" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_roles" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "user_roles_select_own" ON "public"."user_roles" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



ALTER TABLE "public"."user_streamer_entitlements" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_tax_info" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_wallets" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."users" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "users insert own gifts" ON "public"."stream_gifts" FOR INSERT WITH CHECK (("sender_id" = "auth"."uid"()));



CREATE POLICY "users insert own messages" ON "public"."stream_messages" FOR INSERT WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "users insert own payouts" ON "public"."payout_requests" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "users read own notifications" ON "public"."notifications" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "users select own messages" ON "public"."messages" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "users select own payouts" ON "public"."payout_requests" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "users select own streams" ON "public"."streams" FOR SELECT TO "authenticated" USING (("broadcaster_id" = "auth"."uid"()));



CREATE POLICY "users update own payouts" ON "public"."payout_requests" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "users_can_view_own_payments" ON "public"."payment_logs" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."vendor_invoices" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."verification_requests" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."verification_transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."videos" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "view stream gifts" ON "public"."stream_gifts" FOR SELECT USING (true);



CREATE POLICY "view stream messages" ON "public"."stream_messages" FOR SELECT USING (true);



CREATE POLICY "view stream participants" ON "public"."stream_participants" FOR SELECT USING (true);



CREATE POLICY "visa redemption insert own" ON "public"."visa_redemptions" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "visa redemption read own" ON "public"."visa_redemptions" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."visa_redemptions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."wall_posts" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "war results readable" ON "public"."war_results" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."war_results" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."wars" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "wars readable" ON "public"."wars" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."web_push_subscriptions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."weekly_officer_reports" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."weekly_reports" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."wheel_spins" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";






ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."abuse_reports";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."admin_broadcasts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."admin_flags";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."admin_tax_reviews";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."app_settings";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."app_updates";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."applications";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."balance_ledger";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."battle_gifts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."battle_history";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."battle_rewards";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."battle_sessions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."blocked_users";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."broadcaster_applications";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."broadcaster_metrics";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."call_history";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."call_minutes";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."call_sessions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."call_transactions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."case_participants";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."cashout_requests";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."cashout_tiers";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."coin_ledger";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."coin_purchases";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."coin_transactions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."court_schedules";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."court_sessions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."daily_rewards";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."earnings";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."empire_applications";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."empire_referrals";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."empire_rewards";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."error_logs";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."event_participants";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."families";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."family_invites";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."family_lounge_messages";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."family_members";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."family_tasks_new";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."family_wars";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."follows";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."ghost_presence_logs";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."gift_bonus_tracker";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."gift_card_redemptions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."gift_items";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."gift_transactions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."gifts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."gifts_owned";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."group_chats";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."hire_fire_actions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."home_feature_cycles";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."home_feature_spend";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."incidents";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."insurance_packages";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."insurance_plans";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."ip_bans";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."kick_logs";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."lucky_coin_events";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."messages";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."moderation_actions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."moderation_events";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."moderation_notes";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."moderation_reports";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."notifications";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."observer_ratings";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_activity";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_applications";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_availability";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_chat";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_chat_messages";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_hours";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_live_assignments";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_logs";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_mission_logs";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_orientation_results";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_quiz_attempts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_quiz_questions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_quiz_results";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_shift_logs";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_shift_slots";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_shifts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_strikes";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_training_sessions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_weekly_reports";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."officer_work_sessions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."onboarding_events";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."onboarding_progress";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."owc_transactions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."payment_methods";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."payment_transactions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."payout_requests";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."payout_reviews";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."payout_settings";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."payouts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."platform_fees";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."platform_wallet";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."post_gifts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."posts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."provider_costs";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."punishment_transactions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."punishments";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."referral_monthly_bonus";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."referrals";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."report_cases";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."roles";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."scheduled_announcements";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."security_events";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."shadow_bans";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."shifts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."shop_items";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."shop_partners";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."special_gift_earnings";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."staff_profiles";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."store_items";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."stream_entrances";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."stream_entries";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."stream_events";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."stream_gifts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."stream_messages";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."stream_participants";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."stream_presets";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."stream_reactions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."stream_reports";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."stream_sessions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."stream_vods";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."streams";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."streams_participants";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."support_tickets";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."task_completions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."task_templates";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."tax_report_status";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."training_scenarios";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."transactions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_ai_avatars";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_battle_gifts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_battles";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_court_cases";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_dna_profiles";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_drops";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_families";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_family_members";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_family_messages";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_family_wars";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_gift_items";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_officer_applications";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_post_comments";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_post_gifts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_post_reactions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_post_views";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_posts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_stream_messages";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_streams";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_wall_likes";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."troll_wall_posts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."trollcity_orders";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."trollcity_products";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."trollcity_shops";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."trollmond_ledger";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."trollstown_properties";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."trollstown_property_upgrades";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."trollstown_upgrade_config";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."trolltract_contracts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."trolltract_weekly_rewards";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."tromody_gifts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."tromody_queue";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."tromody_sessions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."trophies";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."typing_statuses";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_active_items";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_balances";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_devices";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_entrances";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_follows";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_insurance";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_ip_tracking";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_levels";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_notifications";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_payment_methods";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_payout_settings";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_profiles";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_wallets";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."users";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."verification_requests";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."verification_transactions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."wall_posts";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."web_push_subscriptions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."weekly_officer_reports";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."weekly_reports";






GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

















































































































































































REVOKE ALL ON FUNCTION "public"."_is_court_admin"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."_is_court_admin"() TO "service_role";
GRANT ALL ON FUNCTION "public"."_is_court_admin"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."_mai_block_mutations"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."_mai_block_mutations"() TO "service_role";
GRANT ALL ON FUNCTION "public"."_mai_block_mutations"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."_mai_gift_abuse_trigger"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."_mai_gift_abuse_trigger"() TO "service_role";
GRANT ALL ON FUNCTION "public"."_mai_gift_abuse_trigger"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."activate_entrance_effect"("p_user_id" "uuid", "p_effect_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."activate_entrance_effect"("p_user_id" "uuid", "p_effect_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."activate_entrance_effect"("p_user_id" "uuid", "p_effect_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."activate_item"("p_user_id" "uuid", "p_item_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."activate_item"("p_user_id" "uuid", "p_item_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."activate_item"("p_user_id" "uuid", "p_item_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."activate_perk"("p_user_id" "uuid", "p_perk_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."activate_perk"("p_user_id" "uuid", "p_perk_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."activate_perk"("p_user_id" "uuid", "p_perk_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."activate_perk"("p_user_id" "uuid", "p_perk_id" "text", "p_duration_minutes" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."activate_perk"("p_user_id" "uuid", "p_perk_id" "text", "p_duration_minutes" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."activate_perk"("p_user_id" "uuid", "p_perk_id" "text", "p_duration_minutes" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."activate_store_item"("p_user_id" "uuid", "p_item_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."activate_store_item"("p_user_id" "uuid", "p_item_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."activate_store_item"("p_user_id" "uuid", "p_item_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."add_call_minutes"("p_user_id" "uuid", "p_minutes" integer, "p_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."add_call_minutes"("p_user_id" "uuid", "p_minutes" integer, "p_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_call_minutes"("p_user_id" "uuid", "p_minutes" integer, "p_type" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."add_earned_coins"("user_id" "uuid", "coins" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."add_earned_coins"("user_id" "uuid", "coins" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."add_earned_coins"("user_id" "uuid", "coins" integer) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."add_free_coins"("p_user_id" "uuid", "p_amount" bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."add_free_coins"("p_user_id" "uuid", "p_amount" bigint) TO "service_role";
GRANT ALL ON FUNCTION "public"."add_free_coins"("p_user_id" "uuid", "p_amount" bigint) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."add_paid_coins"("user_id_input" "uuid", "coins_to_add" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."add_paid_coins"("user_id_input" "uuid", "coins_to_add" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."add_paid_coins"("user_id_input" "uuid", "coins_to_add" integer) TO "authenticated";



GRANT ALL ON FUNCTION "public"."add_stream_xp"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."add_stream_xp"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_stream_xp"("p_user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."add_troll_coins"("user_id_input" "uuid", "coins_to_add" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."add_troll_coins"("user_id_input" "uuid", "coins_to_add" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."add_troll_coins"("user_id_input" "uuid", "coins_to_add" integer) TO "authenticated";



GRANT ALL ON FUNCTION "public"."add_watch_xp"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."add_watch_xp"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_watch_xp"("p_user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."add_xp"("p_user_id" "uuid", "p_amount" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."add_xp"("p_user_id" "uuid", "p_amount" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."add_xp"("p_user_id" "uuid", "p_amount" integer) TO "authenticated";



GRANT ALL ON FUNCTION "public"."add_xp"("p_user_id" "uuid", "p_amount" integer, "p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."add_xp"("p_user_id" "uuid", "p_amount" integer, "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_xp"("p_user_id" "uuid", "p_amount" integer, "p_reason" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."adjust_balance"("p_user_id" "uuid", "p_currency" "text", "p_amount" bigint, "p_event" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."adjust_balance"("p_user_id" "uuid", "p_currency" "text", "p_amount" bigint, "p_event" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."adjust_balance"("p_user_id" "uuid", "p_currency" "text", "p_amount" bigint, "p_event" "text") TO "authenticated";



GRANT ALL ON TABLE "public"."payout_requests" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."payout_requests" TO "authenticated";



REVOKE ALL ON FUNCTION "public"."admin_approve_payout"("p_payout_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."admin_approve_payout"("p_payout_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."admin_approve_payout"("p_payout_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."admin_end_shift"("p_shift_id" "uuid", "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."admin_end_shift"("p_shift_id" "uuid", "p_reason" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."admin_end_shift"("p_shift_id" "uuid", "p_reason" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."admin_execute_action"("p_action" "text", "p_target_user" "uuid", "p_amount" integer, "p_admin_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."admin_execute_action"("p_action" "text", "p_target_user" "uuid", "p_amount" integer, "p_admin_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."admin_execute_action"("p_action" "text", "p_target_user" "uuid", "p_amount" integer, "p_admin_id" "uuid") TO "authenticated";



GRANT ALL ON TABLE "public"."officer_shift_logs" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_shift_logs" TO "authenticated";



GRANT ALL ON TABLE "public"."user_profiles" TO "service_role";
GRANT SELECT,INSERT,UPDATE ON TABLE "public"."user_profiles" TO "authenticated";
GRANT SELECT ON TABLE "public"."user_profiles" TO "anon";



GRANT ALL ON TABLE "public"."officer_shift_logs_view" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_shift_logs_view" TO "authenticated";



REVOKE ALL ON FUNCTION "public"."admin_get_officer_shift_logs"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."admin_get_officer_shift_logs"() TO "service_role";
GRANT ALL ON FUNCTION "public"."admin_get_officer_shift_logs"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."admin_grant_coins"("p_user_id" "uuid", "p_amount" integer, "p_admin_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."admin_grant_coins"("p_user_id" "uuid", "p_amount" integer, "p_admin_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."admin_grant_coins"("p_user_id" "uuid", "p_amount" integer, "p_admin_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."admin_grant_troll_coin"("p_user_id" "uuid", "p_amount" integer, "p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_grant_troll_coin"("p_user_id" "uuid", "p_amount" integer, "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_grant_troll_coin"("p_user_id" "uuid", "p_amount" integer, "p_reason" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."admin_mark_cashout_completed"("p_cashout_id" "uuid", "p_payment_reference" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."admin_mark_cashout_completed"("p_cashout_id" "uuid", "p_payment_reference" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."admin_mark_cashout_completed"("p_cashout_id" "uuid", "p_payment_reference" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."admin_mark_cashout_paid"("p_cashout_id" "uuid", "p_payment_reference" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."admin_mark_cashout_paid"("p_cashout_id" "uuid", "p_payment_reference" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."admin_mark_cashout_paid"("p_cashout_id" "uuid", "p_payment_reference" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."admin_update_payout_status"("p_payout_id" "uuid", "p_admin_id" "uuid", "p_new_status" "text", "p_admin_note" "text", "p_rejection_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."admin_update_payout_status"("p_payout_id" "uuid", "p_admin_id" "uuid", "p_new_status" "text", "p_admin_note" "text", "p_rejection_reason" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."admin_update_payout_status"("p_payout_id" "uuid", "p_admin_id" "uuid", "p_new_status" "text", "p_admin_note" "text", "p_rejection_reason" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."admin_update_payout_status"("p_payout_id" "uuid", "p_admin_id" "uuid", "p_new_status" "text", "p_rejection_reason" "text", "p_payment_reference" "text", "p_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_update_payout_status"("p_payout_id" "uuid", "p_admin_id" "uuid", "p_new_status" "text", "p_rejection_reason" "text", "p_payment_reference" "text", "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_update_payout_status"("p_payout_id" "uuid", "p_admin_id" "uuid", "p_new_status" "text", "p_rejection_reason" "text", "p_payment_reference" "text", "p_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_update_user_profile"("p_target_user_id" "uuid", "p_troll_coins" integer, "p_free_coin_balance" integer, "p_level" integer, "p_role" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_update_user_profile"("p_target_user_id" "uuid", "p_troll_coins" integer, "p_free_coin_balance" integer, "p_level" integer, "p_role" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_update_user_profile"("p_target_user_id" "uuid", "p_troll_coins" integer, "p_free_coin_balance" integer, "p_level" integer, "p_role" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."apply_family_war_winner_boosts"() TO "anon";
GRANT ALL ON FUNCTION "public"."apply_family_war_winner_boosts"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."apply_family_war_winner_boosts"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."apply_stream_momentum_decay"("p_stream_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."apply_stream_momentum_decay"("p_stream_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."apply_stream_momentum_decay"("p_stream_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."apply_top_gifter_boosts"("p_leaderboard_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."apply_top_gifter_boosts"("p_leaderboard_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."apply_top_gifter_boosts"("p_leaderboard_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."apply_town_update"("p_user_id" "uuid", "p_cost" integer, "p_update_type" "text", "p_payload" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."apply_town_update"("p_user_id" "uuid", "p_cost" integer, "p_update_type" "text", "p_payload" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."apply_town_update"("p_user_id" "uuid", "p_cost" integer, "p_update_type" "text", "p_payload" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."apply_troll_pass_bundle"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."apply_troll_pass_bundle"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."apply_troll_pass_bundle"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."apply_trollstown_upgrade"("p_user_id" "uuid", "p_property_type" "text", "p_upgrade_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."apply_trollstown_upgrade"("p_user_id" "uuid", "p_property_type" "text", "p_upgrade_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."apply_trollstown_upgrade"("p_user_id" "uuid", "p_property_type" "text", "p_upgrade_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."apply_violation_consequence"("p_user_id" "uuid", "p_violation_type" character varying, "p_severity_level" integer, "p_officer_id" "uuid", "p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."apply_violation_consequence"("p_user_id" "uuid", "p_violation_type" character varying, "p_severity_level" integer, "p_officer_id" "uuid", "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."apply_violation_consequence"("p_user_id" "uuid", "p_violation_type" character varying, "p_severity_level" integer, "p_officer_id" "uuid", "p_reason" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."approve_application"("p_application_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."approve_application"("p_application_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."approve_application"("p_application_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."approve_application"("p_app_id" "uuid", "p_reviewer_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."approve_application"("p_app_id" "uuid", "p_reviewer_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."approve_application"("p_app_id" "uuid", "p_reviewer_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."approve_broadcaster"("p_application_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."approve_broadcaster"("p_application_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."approve_broadcaster"("p_application_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."approve_broadcaster"("p_application_id" "uuid", "p_reviewer_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."approve_broadcaster"("p_application_id" "uuid", "p_reviewer_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."approve_broadcaster"("p_application_id" "uuid", "p_reviewer_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."approve_empire_application"("p_application_id" "uuid", "p_reviewer_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."approve_empire_application"("p_application_id" "uuid", "p_reviewer_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."approve_empire_application"("p_application_id" "uuid", "p_reviewer_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."approve_empire_partner"("p_application_id" "uuid", "p_reviewer_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."approve_empire_partner"("p_application_id" "uuid", "p_reviewer_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."approve_empire_partner"("p_application_id" "uuid", "p_reviewer_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."approve_lead_officer_application"("p_application_id" "uuid", "p_reviewer_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."approve_lead_officer_application"("p_application_id" "uuid", "p_reviewer_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."approve_lead_officer_application"("p_application_id" "uuid", "p_reviewer_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."approve_officer_application"("app_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."approve_officer_application"("app_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."approve_officer_application"("app_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."approve_payout"("p_payout_id" "uuid", "p_start_processing" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."approve_payout"("p_payout_id" "uuid", "p_start_processing" boolean) TO "service_role";
GRANT ALL ON FUNCTION "public"."approve_payout"("p_payout_id" "uuid", "p_start_processing" boolean) TO "authenticated";



GRANT ALL ON FUNCTION "public"."approve_visa_redemption"("p_redemption_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."approve_visa_redemption"("p_redemption_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."approve_visa_redemption"("p_redemption_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."approve_visa_redemption"("p_redemption_id" "uuid", "p_staff_note" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."approve_visa_redemption"("p_redemption_id" "uuid", "p_staff_note" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."approve_visa_redemption"("p_redemption_id" "uuid", "p_staff_note" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."archive_court_ruling"("p_court_session_id" "uuid", "p_ruling" character varying, "p_consequence_applied" character varying, "p_duration_applied" character varying, "p_reasoning_summary" "text", "p_precedent_citation" "text", "p_judge_notes" "text", "p_is_public" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."archive_court_ruling"("p_court_session_id" "uuid", "p_ruling" character varying, "p_consequence_applied" character varying, "p_duration_applied" character varying, "p_reasoning_summary" "text", "p_precedent_citation" "text", "p_judge_notes" "text", "p_is_public" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."archive_court_ruling"("p_court_session_id" "uuid", "p_ruling" character varying, "p_consequence_applied" character varying, "p_duration_applied" character varying, "p_reasoning_summary" "text", "p_precedent_citation" "text", "p_judge_notes" "text", "p_is_public" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."assign_officer_orientation"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."assign_officer_orientation"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."assign_officer_orientation"("p_user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."assign_og_user"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."assign_og_user"() TO "service_role";
GRANT ALL ON FUNCTION "public"."assign_og_user"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."auto_approve_troller"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."auto_approve_troller"() TO "service_role";
GRANT ALL ON FUNCTION "public"."auto_approve_troller"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."auto_grant_admin_officer_status"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."auto_grant_admin_officer_status"() TO "service_role";
GRANT ALL ON FUNCTION "public"."auto_grant_admin_officer_status"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."auto_post_badge_earned"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."auto_post_badge_earned"() TO "service_role";
GRANT ALL ON FUNCTION "public"."auto_post_badge_earned"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."auto_post_battle_result"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."auto_post_battle_result"() TO "service_role";
GRANT ALL ON FUNCTION "public"."auto_post_battle_result"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."auto_post_stream_live"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."auto_post_stream_live"() TO "service_role";
GRANT ALL ON FUNCTION "public"."auto_post_stream_live"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."auto_remove_verification_on_ban"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."auto_remove_verification_on_ban"() TO "service_role";
GRANT ALL ON FUNCTION "public"."auto_remove_verification_on_ban"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."auto_start_court_with_docket"("p_authority_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."auto_start_court_with_docket"("p_authority_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_start_court_with_docket"("p_authority_user_id" "uuid") TO "service_role";



GRANT ALL ON TABLE "public"."system_settings" TO "anon";
GRANT ALL ON TABLE "public"."system_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."system_settings" TO "service_role";



GRANT ALL ON FUNCTION "public"."auto_unlock_payouts"() TO "anon";
GRANT ALL ON FUNCTION "public"."auto_unlock_payouts"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_unlock_payouts"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."auto_upgrade_influencer_tier"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."auto_upgrade_influencer_tier"() TO "service_role";
GRANT ALL ON FUNCTION "public"."auto_upgrade_influencer_tier"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."award_birthday_bonus"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."award_birthday_bonus"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."award_birthday_bonus"("p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."award_birthday_coins_if_eligible"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."award_birthday_coins_if_eligible"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."award_birthday_coins_if_eligible"("p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."award_empire_reward"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."award_empire_reward"() TO "service_role";
GRANT ALL ON FUNCTION "public"."award_empire_reward"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."award_family_badge"("p_family_id" "uuid", "p_badge_type" "text", "p_level" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."award_family_badge"("p_family_id" "uuid", "p_badge_type" "text", "p_level" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."award_family_badge"("p_family_id" "uuid", "p_badge_type" "text", "p_level" integer) TO "service_role";



REVOKE ALL ON FUNCTION "public"."award_owc_for_session"("p_session_id" "uuid", "p_user_id" "uuid", "p_hours_worked" numeric, "p_officer_level" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."award_owc_for_session"("p_session_id" "uuid", "p_user_id" "uuid", "p_hours_worked" numeric, "p_officer_level" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."award_owc_for_session"("p_session_id" "uuid", "p_user_id" "uuid", "p_hours_worked" numeric, "p_officer_level" integer) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."award_troll_coins"("user_id" "uuid", "stream_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."award_troll_coins"("user_id" "uuid", "stream_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."award_troll_coins"("user_id" "uuid", "stream_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."award_user_badge"("p_user_id" "uuid", "p_badge_type" "text", "p_level" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."award_user_badge"("p_user_id" "uuid", "p_badge_type" "text", "p_level" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."award_user_badge"("p_user_id" "uuid", "p_badge_type" "text", "p_level" integer) TO "service_role";



REVOKE ALL ON FUNCTION "public"."ban_ip_address"("p_ip_address" "inet", "p_ban_reason" "text", "p_officer_id" "uuid", "p_ban_details" "text", "p_banned_until" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."ban_ip_address"("p_ip_address" "inet", "p_ban_reason" "text", "p_officer_id" "uuid", "p_ban_details" "text", "p_banned_until" timestamp with time zone) TO "service_role";
GRANT ALL ON FUNCTION "public"."ban_ip_address"("p_ip_address" "inet", "p_ban_reason" "text", "p_officer_id" "uuid", "p_ban_details" "text", "p_banned_until" timestamp with time zone) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."ban_officer"("p_user_id" "uuid", "p_reason" "text", "p_expires_at" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."ban_officer"("p_user_id" "uuid", "p_reason" "text", "p_expires_at" timestamp with time zone) TO "service_role";
GRANT ALL ON FUNCTION "public"."ban_officer"("p_user_id" "uuid", "p_reason" "text", "p_expires_at" timestamp with time zone) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."ban_user"("p_user_id" "uuid", "p_until" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."ban_user"("p_user_id" "uuid", "p_until" timestamp with time zone) TO "service_role";
GRANT ALL ON FUNCTION "public"."ban_user"("p_user_id" "uuid", "p_until" timestamp with time zone) TO "authenticated";



GRANT ALL ON FUNCTION "public"."ban_user"("target" "uuid", "minutes" integer, "reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."ban_user"("target" "uuid", "minutes" integer, "reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."ban_user"("target" "uuid", "minutes" integer, "reason" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."block_cashouts_when_locked"() TO "anon";
GRANT ALL ON FUNCTION "public"."block_cashouts_when_locked"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."block_cashouts_when_locked"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."broadcast_seats_updated_at"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."broadcast_seats_updated_at"() TO "service_role";
GRANT ALL ON FUNCTION "public"."broadcast_seats_updated_at"() TO "authenticated";



GRANT ALL ON TABLE "public"."streams" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."streams" TO "authenticated";



REVOKE ALL ON FUNCTION "public"."build_recording_path"("stream_record" "public"."streams") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."build_recording_path"("stream_record" "public"."streams") TO "service_role";
GRANT ALL ON FUNCTION "public"."build_recording_path"("stream_record" "public"."streams") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."buy_broadcast_theme"("p_theme_slug" "text", "p_set_active" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."buy_broadcast_theme"("p_theme_slug" "text", "p_set_active" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."buy_broadcast_theme"("p_theme_slug" "text", "p_set_active" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."buy_broadcast_theme"("p_theme_slug" "text", "p_set_active" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."buy_entrance_effect"("effect_uuid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."buy_entrance_effect"("effect_uuid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."buy_entrance_effect"("effect_uuid" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."buy_live_snack"("p_stream_id" "uuid", "p_snack_key" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."buy_live_snack"("p_stream_id" "uuid", "p_snack_key" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."buy_live_snack"("p_stream_id" "uuid", "p_snack_key" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."buy_troll_pass"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."buy_troll_pass"() TO "service_role";
GRANT ALL ON FUNCTION "public"."buy_troll_pass"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."calculate_eviction_risk"("p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."calculate_eviction_risk"("p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."calculate_eviction_risk"("p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) TO "authenticated";



GRANT ALL ON FUNCTION "public"."calculate_level"("xp" bigint) TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_level"("xp" bigint) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_level"("xp" bigint) TO "service_role";



REVOKE ALL ON FUNCTION "public"."calculate_lucky_multiplier"("spent_coins" bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."calculate_lucky_multiplier"("spent_coins" bigint) TO "service_role";
GRANT ALL ON FUNCTION "public"."calculate_lucky_multiplier"("spent_coins" bigint) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."calculate_property_value"("p_base_value" integer, "p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."calculate_property_value"("p_base_value" integer, "p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."calculate_property_value"("p_base_value" integer, "p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."calculate_rent"("p_base_rent" integer, "p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."calculate_rent"("p_base_rent" integer, "p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."calculate_rent"("p_base_rent" integer, "p_materials_level" integer, "p_furniture_level" integer, "p_appliances_level" integer, "p_security_level" integer) TO "authenticated";



GRANT ALL ON FUNCTION "public"."calculate_stream_ranking"("p_stream_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_stream_ranking"("p_stream_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_stream_ranking"("p_stream_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."can_ban"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."can_ban"() TO "service_role";
GRANT ALL ON FUNCTION "public"."can_ban"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."cancel_cashout_request"("p_request_id" "uuid", "p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."cancel_cashout_request"("p_request_id" "uuid", "p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."cancel_cashout_request"("p_request_id" "uuid", "p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_concurrent_login"("p_user_id" "uuid", "p_current_session_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."check_concurrent_login"("p_user_id" "uuid", "p_current_session_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_concurrent_login"("p_user_id" "uuid", "p_current_session_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_daily_login"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."check_daily_login"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_daily_login"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_family_admin"("check_family_id" "uuid", "check_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."check_family_admin"("check_family_id" "uuid", "check_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_family_admin"("check_family_id" "uuid", "check_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_family_membership"("check_family_id" "uuid", "check_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."check_family_membership"("check_family_id" "uuid", "check_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_family_membership"("check_family_id" "uuid", "check_user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."check_influencer_eligibility"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."check_influencer_eligibility"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."check_influencer_eligibility"("p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."check_insurance_expiry"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."check_insurance_expiry"() TO "service_role";
GRANT ALL ON FUNCTION "public"."check_insurance_expiry"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."check_missed_court_appearances"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_missed_court_appearances"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_missed_court_appearances"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."check_perk_expiry"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."check_perk_expiry"() TO "service_role";
GRANT ALL ON FUNCTION "public"."check_perk_expiry"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."check_user_liked_post"("p_post_id" "uuid", "p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."check_user_liked_post"("p_post_id" "uuid", "p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."check_user_liked_post"("p_post_id" "uuid", "p_user_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."check_violation_escalation"("p_user_id" "uuid", "p_violation_type" character varying, "p_severity_level" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."check_violation_escalation"("p_user_id" "uuid", "p_violation_type" character varying, "p_severity_level" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_violation_escalation"("p_user_id" "uuid", "p_violation_type" character varying, "p_severity_level" integer) TO "service_role";



REVOKE ALL ON FUNCTION "public"."claim_broadcast_seat"("p_room" "text", "p_seat_index" integer, "p_user_id" "uuid", "p_username" "text", "p_avatar_url" "text", "p_role" "text", "p_metadata" "jsonb") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."claim_broadcast_seat"("p_room" "text", "p_seat_index" integer, "p_user_id" "uuid", "p_username" "text", "p_avatar_url" "text", "p_role" "text", "p_metadata" "jsonb") TO "service_role";
GRANT ALL ON FUNCTION "public"."claim_broadcast_seat"("p_room" "text", "p_seat_index" integer, "p_user_id" "uuid", "p_username" "text", "p_avatar_url" "text", "p_role" "text", "p_metadata" "jsonb") TO "authenticated";



GRANT ALL ON FUNCTION "public"."claim_troll_event"("p_event_id" "uuid", "p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."claim_troll_event"("p_event_id" "uuid", "p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."claim_troll_event"("p_event_id" "uuid", "p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_inactive_sessions"() TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_inactive_sessions"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_inactive_sessions"() TO "service_role";



GRANT ALL ON FUNCTION "public"."clear_expired_username_effects"() TO "anon";
GRANT ALL ON FUNCTION "public"."clear_expired_username_effects"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."clear_expired_username_effects"() TO "service_role";



GRANT ALL ON FUNCTION "public"."clear_top_streams"() TO "anon";
GRANT ALL ON FUNCTION "public"."clear_top_streams"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."clear_top_streams"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."clock_in_from_slot"("p_slot_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."clock_in_from_slot"("p_slot_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."clock_in_from_slot"("p_slot_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."clock_in_from_slot"("p_officer_id" "uuid", "p_slot_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."clock_in_from_slot"("p_officer_id" "uuid", "p_slot_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."clock_in_from_slot"("p_officer_id" "uuid", "p_slot_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."clock_out_and_complete_slot"("p_slot_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."clock_out_and_complete_slot"("p_slot_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."clock_out_and_complete_slot"("p_slot_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."complete_court_case"("p_docket_id" "uuid", "p_verdict" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."complete_court_case"("p_docket_id" "uuid", "p_verdict" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."complete_court_case"("p_docket_id" "uuid", "p_verdict" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."complete_orientation"("p_user_id" "uuid", "p_passed" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."complete_orientation"("p_user_id" "uuid", "p_passed" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."complete_orientation"("p_user_id" "uuid", "p_passed" boolean) TO "service_role";



REVOKE ALL ON FUNCTION "public"."confirm_coin_purchase"("p_tx_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."confirm_coin_purchase"("p_tx_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."confirm_coin_purchase"("p_tx_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."contribute_trollmonds_pool"("p_stream_id" "uuid", "p_sender_id" "uuid", "p_base_paid_coins" bigint, "p_gift_id" "uuid", "p_metadata" "jsonb") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."contribute_trollmonds_pool"("p_stream_id" "uuid", "p_sender_id" "uuid", "p_base_paid_coins" bigint, "p_gift_id" "uuid", "p_metadata" "jsonb") TO "service_role";
GRANT ALL ON FUNCTION "public"."contribute_trollmonds_pool"("p_stream_id" "uuid", "p_sender_id" "uuid", "p_base_paid_coins" bigint, "p_gift_id" "uuid", "p_metadata" "jsonb") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."convert_free_to_trollmonds"("p_user" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."convert_free_to_trollmonds"("p_user" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."convert_free_to_trollmonds"("p_user" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."convert_owc_to_paid"("p_user_id" "uuid", "p_owc_amount" bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."convert_owc_to_paid"("p_user_id" "uuid", "p_owc_amount" bigint) TO "service_role";
GRANT ALL ON FUNCTION "public"."convert_owc_to_paid"("p_user_id" "uuid", "p_owc_amount" bigint) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."convert_owc_to_paid_coins"("p_owc" bigint, "p_level" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."convert_owc_to_paid_coins"("p_owc" bigint, "p_level" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."convert_owc_to_paid_coins"("p_owc" bigint, "p_level" integer) TO "authenticated";



GRANT ALL ON FUNCTION "public"."convert_owc_to_troll_coins"("p_owc" bigint, "p_level" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."convert_owc_to_troll_coins"("p_owc" bigint, "p_level" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."convert_owc_to_troll_coins"("p_owc" bigint, "p_level" integer) TO "service_role";



REVOKE ALL ON FUNCTION "public"."convert_paid_coins_to_trollmonds"("p_user_id" "uuid", "p_paid_coins" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."convert_paid_coins_to_trollmonds"("p_user_id" "uuid", "p_paid_coins" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."convert_paid_coins_to_trollmonds"("p_user_id" "uuid", "p_paid_coins" integer) TO "authenticated";



GRANT ALL ON FUNCTION "public"."create_appeal_docket"("p_user_id" "uuid", "p_appeal_reason" "text", "p_appeal_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_appeal_docket"("p_user_id" "uuid", "p_appeal_reason" "text", "p_appeal_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_appeal_docket"("p_user_id" "uuid", "p_appeal_reason" "text", "p_appeal_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_city_event"("p_event_type" character varying, "p_title" character varying, "p_description" "text", "p_start_time" timestamp with time zone, "p_end_time" timestamp with time zone, "p_global_announcement" boolean, "p_event_config" "jsonb", "p_rewards_config" "jsonb", "p_created_by" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_city_event"("p_event_type" character varying, "p_title" character varying, "p_description" "text", "p_start_time" timestamp with time zone, "p_end_time" timestamp with time zone, "p_global_announcement" boolean, "p_event_config" "jsonb", "p_rewards_config" "jsonb", "p_created_by" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_city_event"("p_event_type" character varying, "p_title" character varying, "p_description" "text", "p_start_time" timestamp with time zone, "p_end_time" timestamp with time zone, "p_global_announcement" boolean, "p_event_config" "jsonb", "p_rewards_config" "jsonb", "p_created_by" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_court_case"("p_case_type" "text", "p_plaintiff_id" "uuid", "p_defendant_id" "uuid", "p_description" "text", "p_court_session_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_court_case"("p_case_type" "text", "p_plaintiff_id" "uuid", "p_defendant_id" "uuid", "p_description" "text", "p_court_session_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_court_case"("p_case_type" "text", "p_plaintiff_id" "uuid", "p_defendant_id" "uuid", "p_description" "text", "p_court_session_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_family_stats_row"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_family_stats_row"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_family_stats_row"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_family_tasks"("p_family_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_family_tasks"("p_family_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_family_tasks"("p_family_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_gifter_leaderboard_snapshot"("p_type" "text", "p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."create_gifter_leaderboard_snapshot"("p_type" "text", "p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_gifter_leaderboard_snapshot"("p_type" "text", "p_start" "date", "p_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_message_receipts"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_message_receipts"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_message_receipts"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_notification"("recipient" "uuid", "message" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_notification"("recipient" "uuid", "message" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_notification"("recipient" "uuid", "message" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."create_notification"("p_user_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_metadata" "jsonb") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."create_notification"("p_user_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_metadata" "jsonb") TO "service_role";
GRANT ALL ON FUNCTION "public"."create_notification"("p_user_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_metadata" "jsonb") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."create_profile_for_new_user"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."create_profile_for_new_user"() TO "service_role";
GRANT ALL ON FUNCTION "public"."create_profile_for_new_user"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."create_tromody_session"("p_creator" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."create_tromody_session"("p_creator" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."create_tromody_session"("p_creator" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."create_violation_docket"("p_user_id" "uuid", "p_case_type" "text", "p_notes" "text", "p_delay_hours" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."create_violation_docket"("p_user_id" "uuid", "p_case_type" "text", "p_notes" "text", "p_delay_hours" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_violation_docket"("p_user_id" "uuid", "p_case_type" "text", "p_notes" "text", "p_delay_hours" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."create_wall_post_reply"("p_original_post_id" "uuid", "p_content" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_wall_post_reply"("p_original_post_id" "uuid", "p_content" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_wall_post_reply"("p_original_post_id" "uuid", "p_content" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_wall_post_reply"("p_original_post_id" "uuid", "p_user_id" "uuid", "p_content" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_wall_post_reply"("p_original_post_id" "uuid", "p_user_id" "uuid", "p_content" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_wall_post_reply"("p_original_post_id" "uuid", "p_user_id" "uuid", "p_content" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."create_wallet_for_user"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."create_wallet_for_user"() TO "service_role";
GRANT ALL ON FUNCTION "public"."create_wallet_for_user"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."credit_coinback_bonus"("p_user_id" "uuid", "p_base_paid_coins" bigint, "p_source" "text", "p_related_gift_id" "uuid", "p_related_external_id" "text", "p_metadata" "jsonb") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."credit_coinback_bonus"("p_user_id" "uuid", "p_base_paid_coins" bigint, "p_source" "text", "p_related_gift_id" "uuid", "p_related_external_id" "text", "p_metadata" "jsonb") TO "service_role";
GRANT ALL ON FUNCTION "public"."credit_coinback_bonus"("p_user_id" "uuid", "p_base_paid_coins" bigint, "p_source" "text", "p_related_gift_id" "uuid", "p_related_external_id" "text", "p_metadata" "jsonb") TO "authenticated";



GRANT ALL ON FUNCTION "public"."credit_coins"("p_user_id" "uuid", "p_coins" integer, "p_paypal_capture_id" "text", "p_paypal_order_id" "text", "p_package_id" "uuid", "p_amount_usd" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."credit_coins"("p_user_id" "uuid", "p_coins" integer, "p_paypal_capture_id" "text", "p_paypal_order_id" "text", "p_package_id" "uuid", "p_amount_usd" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."credit_coins"("p_user_id" "uuid", "p_coins" integer, "p_paypal_capture_id" "text", "p_paypal_order_id" "text", "p_package_id" "uuid", "p_amount_usd" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."deactivate_expired_perks"() TO "anon";
GRANT ALL ON FUNCTION "public"."deactivate_expired_perks"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."deactivate_expired_perks"() TO "service_role";



GRANT ALL ON FUNCTION "public"."deduct_call_minutes"("p_user_id" "uuid", "p_minutes" integer, "p_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."deduct_call_minutes"("p_user_id" "uuid", "p_minutes" integer, "p_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."deduct_call_minutes"("p_user_id" "uuid", "p_minutes" integer, "p_type" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."deduct_coins"("p_user_id" "uuid", "p_amount" bigint, "p_coin_type" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."deduct_coins"("p_user_id" "uuid", "p_amount" bigint, "p_coin_type" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."deduct_coins"("p_user_id" "uuid", "p_amount" bigint, "p_coin_type" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."deduct_troll_coins"("p_user_id" "uuid", "p_amount" bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."deduct_troll_coins"("p_user_id" "uuid", "p_amount" bigint) TO "service_role";
GRANT ALL ON FUNCTION "public"."deduct_troll_coins"("p_user_id" "uuid", "p_amount" bigint) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."deduct_user_coins"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text", "p_appeal_id" "uuid", "p_verdict" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."deduct_user_coins"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text", "p_appeal_id" "uuid", "p_verdict" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."deduct_user_coins"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text", "p_appeal_id" "uuid", "p_verdict" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."deduct_user_paid_coins"("p_user_id" "uuid", "p_amount" bigint, "p_coin_type" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."deduct_user_paid_coins"("p_user_id" "uuid", "p_amount" bigint, "p_coin_type" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."deduct_user_paid_coins"("p_user_id" "uuid", "p_amount" bigint, "p_coin_type" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."deduct_user_troll_coins"("p_user_id" "uuid", "p_amount" bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."deduct_user_troll_coins"("p_user_id" "uuid", "p_amount" bigint) TO "service_role";
GRANT ALL ON FUNCTION "public"."deduct_user_troll_coins"("p_user_id" "uuid", "p_amount" bigint) TO "authenticated";



GRANT ALL ON FUNCTION "public"."deduct_user_troll_coins"("p_user_id" "uuid", "p_amount" bigint, "p_coin_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."deduct_user_troll_coins"("p_user_id" "uuid", "p_amount" bigint, "p_coin_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."deduct_user_troll_coins"("p_user_id" "uuid", "p_amount" bigint, "p_coin_type" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."delete_payout_request"("p_payout_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."delete_payout_request"("p_payout_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."delete_payout_request"("p_payout_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."delete_user_account"("p_user_id" "uuid", "p_pay_early_fee" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."delete_user_account"("p_user_id" "uuid", "p_pay_early_fee" boolean) TO "service_role";
GRANT ALL ON FUNCTION "public"."delete_user_account"("p_user_id" "uuid", "p_pay_early_fee" boolean) TO "authenticated";



GRANT ALL ON FUNCTION "public"."delete_user_as_admin"("target_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."delete_user_as_admin"("target_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."delete_user_as_admin"("target_user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."deny_application"("p_app_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."deny_application"("p_app_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."deny_application"("p_app_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."deny_application"("p_app_id" "uuid", "p_reviewer_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."deny_application"("p_app_id" "uuid", "p_reviewer_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."deny_application"("p_app_id" "uuid", "p_reviewer_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."deny_application"("p_app_id" "uuid", "p_reviewer_id" "uuid", "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."deny_application"("p_app_id" "uuid", "p_reviewer_id" "uuid", "p_reason" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."deny_application"("p_app_id" "uuid", "p_reviewer_id" "uuid", "p_reason" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."detect_ghost_inactivity"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."detect_ghost_inactivity"() TO "service_role";
GRANT ALL ON FUNCTION "public"."detect_ghost_inactivity"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."economy_summary"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."economy_summary"() TO "service_role";
GRANT ALL ON FUNCTION "public"."economy_summary"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."end_court_session"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."end_court_session"() TO "service_role";
GRANT ALL ON FUNCTION "public"."end_court_session"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."end_court_session"("p_session_id" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."end_court_session"("p_session_id" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."end_court_session"("p_session_id" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."end_home_feature_cycle"("p_cycle_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."end_home_feature_cycle"("p_cycle_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."end_home_feature_cycle"("p_cycle_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."end_stream"("p_stream_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."end_stream"("p_stream_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."end_stream"("p_stream_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."end_trial_early"() TO "anon";
GRANT ALL ON FUNCTION "public"."end_trial_early"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."end_trial_early"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."end_tromody_session"("p_session" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."end_tromody_session"("p_session" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."end_tromody_session"("p_session" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."enforce_two_secretaries_max"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."enforce_two_secretaries_max"() TO "service_role";
GRANT ALL ON FUNCTION "public"."enforce_two_secretaries_max"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."ensure_payout_not_locked"() TO "anon";
GRANT ALL ON FUNCTION "public"."ensure_payout_not_locked"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."ensure_payout_not_locked"() TO "service_role";



GRANT ALL ON FUNCTION "public"."ensure_payout_window_open"() TO "anon";
GRANT ALL ON FUNCTION "public"."ensure_payout_window_open"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."ensure_payout_window_open"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."ensure_stream_momentum"("p_stream_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."ensure_stream_momentum"("p_stream_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."ensure_stream_momentum"("p_stream_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."escalate_to_admin"("p_report_id" "uuid", "p_officer_id" "uuid", "p_reason" "text", "p_description" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."escalate_to_admin"("p_report_id" "uuid", "p_officer_id" "uuid", "p_reason" "text", "p_description" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."escalate_to_admin"("p_report_id" "uuid", "p_officer_id" "uuid", "p_reason" "text", "p_description" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."escalate_to_officer"("p_report_id" "uuid", "p_escalator_id" "uuid", "p_reason" "text", "p_description" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."escalate_to_officer"("p_report_id" "uuid", "p_escalator_id" "uuid", "p_reason" "text", "p_description" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."escalate_to_officer"("p_report_id" "uuid", "p_escalator_id" "uuid", "p_reason" "text", "p_description" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."exec_sql"("sql" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."exec_sql"("sql" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."exec_sql"("sql" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."execute_sql"("sql" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."execute_sql"("sql" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."execute_sql"("sql" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."expire_active_items"() TO "anon";
GRANT ALL ON FUNCTION "public"."expire_active_items"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."expire_active_items"() TO "service_role";



GRANT ALL ON FUNCTION "public"."expire_perks"() TO "anon";
GRANT ALL ON FUNCTION "public"."expire_perks"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."expire_perks"() TO "service_role";



GRANT ALL ON FUNCTION "public"."expire_user_items"() TO "anon";
GRANT ALL ON FUNCTION "public"."expire_user_items"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."expire_user_items"() TO "service_role";



GRANT ALL ON FUNCTION "public"."family_purchase_item"("p_family_id" "uuid", "p_item_id" "uuid", "p_quantity" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."family_purchase_item"("p_family_id" "uuid", "p_item_id" "uuid", "p_quantity" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."family_purchase_item"("p_family_id" "uuid", "p_item_id" "uuid", "p_quantity" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."finalize_redemption_on_sent"() TO "anon";
GRANT ALL ON FUNCTION "public"."finalize_redemption_on_sent"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."finalize_redemption_on_sent"() TO "service_role";



GRANT ALL ON FUNCTION "public"."finalize_redemption_status"() TO "anon";
GRANT ALL ON FUNCTION "public"."finalize_redemption_status"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."finalize_redemption_status"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."find_tromody_match"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."find_tromody_match"() TO "service_role";
GRANT ALL ON FUNCTION "public"."find_tromody_match"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."fire_officer"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."fire_officer"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."fire_officer"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."fn_apply_coin_ledger"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."fn_apply_coin_ledger"() TO "service_role";
GRANT ALL ON FUNCTION "public"."fn_apply_coin_ledger"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."fn_ensure_wallet"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."fn_ensure_wallet"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."fn_ensure_wallet"("p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."fn_touch_updated_at"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."fn_touch_updated_at"() TO "service_role";
GRANT ALL ON FUNCTION "public"."fn_touch_updated_at"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."force_end_all_court_sessions"() TO "anon";
GRANT ALL ON FUNCTION "public"."force_end_all_court_sessions"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."force_end_all_court_sessions"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fulfill_cashout_request"("p_request_id" "uuid", "p_admin_id" "uuid", "p_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."fulfill_cashout_request"("p_request_id" "uuid", "p_admin_id" "uuid", "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."fulfill_cashout_request"("p_request_id" "uuid", "p_admin_id" "uuid", "p_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."fulfill_visa_redemption"("p_redemption_id" "uuid", "p_giftcard_code" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."fulfill_visa_redemption"("p_redemption_id" "uuid", "p_giftcard_code" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."fulfill_visa_redemption"("p_redemption_id" "uuid", "p_giftcard_code" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_active_perks"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_active_perks"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_active_perks"("p_user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_admin_finance_dashboard"("p_range" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_admin_finance_dashboard"("p_range" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."get_admin_finance_dashboard"("p_range" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."get_all_docket_entries"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_all_docket_entries"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_all_docket_entries"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_battle_and_net_earnings"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_battle_and_net_earnings"() TO "service_role";
GRANT ALL ON FUNCTION "public"."get_battle_and_net_earnings"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_cached_home_rankings_30m"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_cached_home_rankings_30m"() TO "service_role";
GRANT ALL ON FUNCTION "public"."get_cached_home_rankings_30m"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."get_call_balances"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_call_balances"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_call_balances"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_case_details"("p_case_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_case_details"("p_case_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_case_details"("p_case_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_config_bool"("p_key" "text", "p_default" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_config_bool"("p_key" "text", "p_default" boolean) TO "service_role";
GRANT ALL ON FUNCTION "public"."get_config_bool"("p_key" "text", "p_default" boolean) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_config_int"("p_key" "text", "p_default" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_config_int"("p_key" "text", "p_default" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."get_config_int"("p_key" "text", "p_default" integer) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_creator_earnings"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_creator_earnings"() TO "service_role";
GRANT ALL ON FUNCTION "public"."get_creator_earnings"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_creator_stats"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_creator_stats"() TO "service_role";
GRANT ALL ON FUNCTION "public"."get_creator_stats"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_cycle_end_30m"("p_now" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_cycle_end_30m"("p_now" timestamp with time zone) TO "service_role";
GRANT ALL ON FUNCTION "public"."get_cycle_end_30m"("p_now" timestamp with time zone) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_cycle_window_30m"("p_now" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_cycle_window_30m"("p_now" timestamp with time zone) TO "service_role";
GRANT ALL ON FUNCTION "public"."get_cycle_window_30m"("p_now" timestamp with time zone) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_daily_earnings_series"("days_back" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_daily_earnings_series"("days_back" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."get_daily_earnings_series"("days_back" integer) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_daily_giveaway_stats"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_daily_giveaway_stats"() TO "service_role";
GRANT ALL ON FUNCTION "public"."get_daily_giveaway_stats"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."get_district_onboarding_tour"("p_district_name" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."get_district_onboarding_tour"("p_district_name" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_district_onboarding_tour"("p_district_name" character varying) TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_earnings_overview"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_earnings_overview"() TO "service_role";
GRANT ALL ON FUNCTION "public"."get_earnings_overview"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_earnings_overview"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_earnings_overview"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."get_earnings_overview"("p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_effective_privileges"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_effective_privileges"() TO "service_role";
GRANT ALL ON FUNCTION "public"."get_effective_privileges"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_family_members_with_family"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_family_members_with_family"() TO "service_role";
GRANT ALL ON FUNCTION "public"."get_family_members_with_family"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_hourly_activity"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_hourly_activity"() TO "service_role";
GRANT ALL ON FUNCTION "public"."get_hourly_activity"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_hourly_activity"("hours_back" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_hourly_activity"("hours_back" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."get_hourly_activity"("hours_back" integer) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_ip_ban_history"("p_ip_address" "inet", "p_officer_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_ip_ban_history"("p_ip_address" "inet", "p_officer_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."get_ip_ban_history"("p_ip_address" "inet", "p_officer_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_lucky_stats"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_lucky_stats"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."get_lucky_stats"("p_user_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."get_monthly_earnings"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_monthly_earnings"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_monthly_earnings"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_monthly_earnings"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_monthly_earnings"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_monthly_earnings"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON TABLE "public"."officer_weekly_reports" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_weekly_reports" TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_my_weekly_reports"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_my_weekly_reports"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."get_my_weekly_reports"("p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_officer_actions"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_officer_actions"() TO "service_role";
GRANT ALL ON FUNCTION "public"."get_officer_actions"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_officer_applicants"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_officer_applicants"() TO "service_role";
GRANT ALL ON FUNCTION "public"."get_officer_applicants"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."get_officer_cashout_history"("p_officer_id" "uuid", "p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_officer_cashout_history"("p_officer_id" "uuid", "p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_officer_cashout_history"("p_officer_id" "uuid", "p_limit" integer) TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_officer_orientation_result"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_officer_orientation_result"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."get_officer_orientation_result"("p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_officer_orientation_status"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_officer_orientation_status"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."get_officer_orientation_status"("p_user_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."get_officer_performance_summary"("p_officer_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_officer_performance_summary"("p_officer_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_officer_performance_summary"("p_officer_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_officer_quiz_questions"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_officer_quiz_questions"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_officer_quiz_questions"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_officers"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_officers"() TO "service_role";
GRANT ALL ON FUNCTION "public"."get_officers"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_or_create_active_cycle"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_or_create_active_cycle"() TO "service_role";
GRANT ALL ON FUNCTION "public"."get_or_create_active_cycle"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_owc_conversion_rate"("p_level" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_owc_conversion_rate"("p_level" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."get_owc_conversion_rate"("p_level" integer) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_owc_per_hour"("p_level" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_owc_per_hour"("p_level" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."get_owc_per_hour"("p_level" integer) TO "authenticated";



GRANT ALL ON FUNCTION "public"."get_public_docket_board"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_public_docket_board"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_public_docket_board"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_recent_users"("limit_count" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_recent_users"("limit_count" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."get_recent_users"("limit_count" integer) TO "authenticated";



GRANT ALL ON FUNCTION "public"."get_royal_family_status"("p_admin_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_royal_family_status"("p_admin_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_royal_family_status"("p_admin_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_seller_reliability_summary"("p_seller_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_seller_reliability_summary"("p_seller_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_seller_reliability_summary"("p_seller_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_staff_role"("uid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_staff_role"("uid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_staff_role"("uid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_stream_recommendations"("p_user_id" "uuid", "p_limit" integer, "p_algorithm" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."get_stream_recommendations"("p_user_id" "uuid", "p_limit" integer, "p_algorithm" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_stream_recommendations"("p_user_id" "uuid", "p_limit" integer, "p_algorithm" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_system_settings"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_system_settings"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_system_settings"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_top_broadcasters_paid_24h"("limit_count" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_top_broadcasters_paid_24h"("limit_count" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."get_top_broadcasters_paid_24h"("limit_count" integer) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_top_gifters"("limit_count" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_top_gifters"("limit_count" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."get_top_gifters"("limit_count" integer) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_unread_notification_count"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_unread_notification_count"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."get_unread_notification_count"("p_user_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."get_user_accessible_districts"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_accessible_districts"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_accessible_districts"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_docket"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_docket"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_docket"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_gift_recipients"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_gift_recipients"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_gift_recipients"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_gifters"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_gifters"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_gifters"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON TABLE "public"."creator_applications" TO "anon";
GRANT ALL ON TABLE "public"."creator_applications" TO "authenticated";
GRANT ALL ON TABLE "public"."creator_applications" TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_latest_application"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_latest_application"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_latest_application"("p_user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_user_monthly_coins_earned"("p_user_id" "uuid", "p_month" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_user_monthly_coins_earned"("p_user_id" "uuid", "p_month" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."get_user_monthly_coins_earned"("p_user_id" "uuid", "p_month" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."get_user_reputation_summary"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_reputation_summary"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_reputation_summary"("p_user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_weekly_family_task_counts"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_weekly_family_task_counts"() TO "service_role";
GRANT ALL ON FUNCTION "public"."get_weekly_family_task_counts"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."get_weekly_reports_for_admin"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_weekly_reports_for_admin"() TO "service_role";
GRANT ALL ON FUNCTION "public"."get_weekly_reports_for_admin"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."grant_entrance_effect"("p_user_id" "uuid", "p_effect_id" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."grant_entrance_effect"("p_user_id" "uuid", "p_effect_id" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."grant_entrance_effect"("p_user_id" "uuid", "p_effect_id" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."grant_family_crown"("p_family_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."grant_family_crown"("p_family_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."grant_family_crown"("p_family_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."grant_og_badge"() TO "anon";
GRANT ALL ON FUNCTION "public"."grant_og_badge"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."grant_og_badge"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."handle_battle_gift"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."handle_battle_gift"() TO "service_role";
GRANT ALL ON FUNCTION "public"."handle_battle_gift"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."handle_chargeback_ban"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."handle_chargeback_ban"() TO "service_role";
GRANT ALL ON FUNCTION "public"."handle_chargeback_ban"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."handle_gift_bonus"("p_sender_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."handle_gift_bonus"("p_sender_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_gift_bonus"("p_sender_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."handle_new_user"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "service_role";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."handle_new_user_profile"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."handle_new_user_profile"() TO "service_role";
GRANT ALL ON FUNCTION "public"."handle_new_user_profile"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."handle_new_user_troll_coins"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."handle_new_user_troll_coins"() TO "service_role";
GRANT ALL ON FUNCTION "public"."handle_new_user_troll_coins"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."handle_user_signup"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."handle_user_signup"() TO "service_role";
GRANT ALL ON FUNCTION "public"."handle_user_signup"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."has_accepted_agreement"("p_user_id" "uuid", "p_agreement_version" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."has_accepted_agreement"("p_user_id" "uuid", "p_agreement_version" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."has_accepted_agreement"("p_user_id" "uuid", "p_agreement_version" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."has_active_perk"("p_user_id" "uuid", "p_perk_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."has_active_perk"("p_user_id" "uuid", "p_perk_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."has_active_perk"("p_user_id" "uuid", "p_perk_id" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."has_daily_giveaway_run_today"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."has_daily_giveaway_run_today"() TO "service_role";
GRANT ALL ON FUNCTION "public"."has_daily_giveaway_run_today"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."healthcheck"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."healthcheck"() TO "service_role";
GRANT ALL ON FUNCTION "public"."healthcheck"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."healthcheck"() TO "anon";



REVOKE ALL ON FUNCTION "public"."hire_officer"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."hire_officer"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."hire_officer"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."increment_paid_balance"("userid" "uuid", "coin_amount" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."increment_paid_balance"("userid" "uuid", "coin_amount" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."increment_paid_balance"("userid" "uuid", "coin_amount" integer) TO "authenticated";



GRANT ALL ON FUNCTION "public"."increment_stream_likes"("stream_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."increment_stream_likes"("stream_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."increment_stream_likes"("stream_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."increment_stream_mute_count"("p_stream_id" "uuid", "p_target_user_id" "uuid", "p_muted_by" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."increment_stream_mute_count"("p_stream_id" "uuid", "p_target_user_id" "uuid", "p_muted_by" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."increment_stream_mute_count"("p_stream_id" "uuid", "p_target_user_id" "uuid", "p_muted_by" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."increment_stream_viewers"("stream_id_input" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."increment_stream_viewers"("stream_id_input" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."increment_stream_viewers"("stream_id_input" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."increment_trollmonds"("p_user_id" "uuid", "p_amount" bigint) TO "anon";
GRANT ALL ON FUNCTION "public"."increment_trollmonds"("p_user_id" "uuid", "p_amount" bigint) TO "authenticated";
GRANT ALL ON FUNCTION "public"."increment_trollmonds"("p_user_id" "uuid", "p_amount" bigint) TO "service_role";



REVOKE ALL ON FUNCTION "public"."is_admin"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."is_admin"() TO "service_role";
GRANT ALL ON FUNCTION "public"."is_admin"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."is_admin"("uid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_admin"("uid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_admin"("uid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_admin_or_secretary"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_admin_or_secretary"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_admin_or_secretary"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."is_admin_user"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."is_admin_user"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."is_admin_user"("p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."is_court_admin"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."is_court_admin"() TO "service_role";
GRANT ALL ON FUNCTION "public"."is_court_admin"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."is_ip_banned"("p_ip_address" "inet") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."is_ip_banned"("p_ip_address" "inet") TO "service_role";
GRANT ALL ON FUNCTION "public"."is_ip_banned"("p_ip_address" "inet") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."is_lead"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."is_lead"() TO "service_role";
GRANT ALL ON FUNCTION "public"."is_lead"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."is_lead_officer"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."is_lead_officer"() TO "service_role";
GRANT ALL ON FUNCTION "public"."is_lead_officer"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."is_lead_officer_position_filled"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."is_lead_officer_position_filled"() TO "service_role";
GRANT ALL ON FUNCTION "public"."is_lead_officer_position_filled"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."is_officer_or_admin"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."is_officer_or_admin"() TO "service_role";
GRANT ALL ON FUNCTION "public"."is_officer_or_admin"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."is_og_period_active"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_og_period_active"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_og_period_active"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_paid_user"("uid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_paid_user"("uid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_paid_user"("uid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_payout_locked"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_payout_locked"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_payout_locked"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_payout_window_open"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_payout_window_open"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_payout_window_open"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."is_secretary"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."is_secretary"() TO "service_role";
GRANT ALL ON FUNCTION "public"."is_secretary"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."is_staff"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."is_staff"() TO "service_role";
GRANT ALL ON FUNCTION "public"."is_staff"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."is_staff"("p_uid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_staff"("p_uid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_staff"("p_uid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."join_city_event"("p_event_id" "uuid", "p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."join_city_event"("p_event_id" "uuid", "p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."join_city_event"("p_event_id" "uuid", "p_user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."join_tromody_queue"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."join_tromody_queue"() TO "service_role";
GRANT ALL ON FUNCTION "public"."join_tromody_queue"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."join_tromody_side"("p_session" "uuid", "p_user" "uuid", "p_side" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."join_tromody_side"("p_session" "uuid", "p_user" "uuid", "p_side" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."join_tromody_side"("p_session" "uuid", "p_user" "uuid", "p_side" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."jwt_role"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."jwt_role"() TO "service_role";
GRANT ALL ON FUNCTION "public"."jwt_role"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."kick_tromody_user"("p_session" "uuid", "p_side" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."kick_tromody_user"("p_session" "uuid", "p_side" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."kick_tromody_user"("p_session" "uuid", "p_side" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."kick_user"("p_target_user_id" "uuid", "p_kicker_user_id" "uuid", "p_stream_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."kick_user"("p_target_user_id" "uuid", "p_kicker_user_id" "uuid", "p_stream_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."kick_user"("p_target_user_id" "uuid", "p_kicker_user_id" "uuid", "p_stream_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."kick_user_from_stream"("target_user" "uuid", "stream_id" "uuid", "reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."kick_user_from_stream"("target_user" "uuid", "stream_id" "uuid", "reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."kick_user_from_stream"("target_user" "uuid", "stream_id" "uuid", "reason" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."log_admin_action"("p_action_type" "text", "p_target_id" "uuid", "p_details" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."log_admin_action"("p_action_type" "text", "p_target_id" "uuid", "p_details" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_admin_action"("p_action_type" "text", "p_target_id" "uuid", "p_details" "jsonb") TO "service_role";



REVOKE ALL ON FUNCTION "public"."log_coin_gift"("receiver_id" "uuid", "gift_amount" numeric) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."log_coin_gift"("receiver_id" "uuid", "gift_amount" numeric) TO "service_role";
GRANT ALL ON FUNCTION "public"."log_coin_gift"("receiver_id" "uuid", "gift_amount" numeric) TO "authenticated";



GRANT ALL ON FUNCTION "public"."log_payout_status_change"() TO "anon";
GRANT ALL ON FUNCTION "public"."log_payout_status_change"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_payout_status_change"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."log_security_event"("p_url" "text", "p_user_agent" "text", "p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."log_security_event"("p_url" "text", "p_user_agent" "text", "p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."log_security_event"("p_url" "text", "p_user_agent" "text", "p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."log_security_event"("p_ip" "text", "p_url" "text", "p_user_agent" "text", "p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."log_security_event"("p_ip" "text", "p_url" "text", "p_user_agent" "text", "p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."log_security_event"("p_ip" "text", "p_url" "text", "p_user_agent" "text", "p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."log_security_event"("p_url" "text", "p_user_agent" "text", "p_user_id" "uuid", "p_ip" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."log_security_event"("p_url" "text", "p_user_agent" "text", "p_user_id" "uuid", "p_ip" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."log_security_event"("p_url" "text", "p_user_agent" "text", "p_user_id" "uuid", "p_ip" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."log_security_event"("p_event" "text", "p_ip" "text", "p_url" "text", "p_user_agent" "text", "p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."log_security_event"("p_event" "text", "p_ip" "text", "p_url" "text", "p_user_agent" "text", "p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."log_security_event"("p_event" "text", "p_ip" "text", "p_url" "text", "p_user_agent" "text", "p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."log_security_event"("p_ip" "text", "p_url" "text", "p_user_agent" "text", "p_user_id" "uuid", "p_event" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."log_security_event"("p_ip" "text", "p_url" "text", "p_user_agent" "text", "p_user_id" "uuid", "p_event" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."log_security_event"("p_ip" "text", "p_url" "text", "p_user_agent" "text", "p_user_id" "uuid", "p_event" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."log_user_moderation"() TO "anon";
GRANT ALL ON FUNCTION "public"."log_user_moderation"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_user_moderation"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."mai_append_event"("p_event_type" "text", "p_target_user_id" "uuid", "p_stream_id" "uuid", "p_metadata" "jsonb", "p_sensitive_hash" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."mai_append_event"("p_event_type" "text", "p_target_user_id" "uuid", "p_stream_id" "uuid", "p_metadata" "jsonb", "p_sensitive_hash" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."mai_append_event"("p_event_type" "text", "p_target_user_id" "uuid", "p_stream_id" "uuid", "p_metadata" "jsonb", "p_sensitive_hash" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."manage_honorary_family_member"("p_user_id" "uuid", "p_admin_id" "uuid", "p_action" character varying, "p_title" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."manage_honorary_family_member"("p_user_id" "uuid", "p_admin_id" "uuid", "p_action" character varying, "p_title" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."manage_honorary_family_member"("p_user_id" "uuid", "p_admin_id" "uuid", "p_action" character varying, "p_title" character varying) TO "service_role";



REVOKE ALL ON FUNCTION "public"."mark_all_notifications_read"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."mark_all_notifications_read"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."mark_all_notifications_read"("p_user_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."mark_conversation_read"("p_conversation_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."mark_conversation_read"("p_conversation_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_conversation_read"("p_conversation_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."mark_expired_referrals_failed"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."mark_expired_referrals_failed"() TO "service_role";
GRANT ALL ON FUNCTION "public"."mark_expired_referrals_failed"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."mark_message_delivered"("p_message_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."mark_message_delivered"("p_message_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_message_delivered"("p_message_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."mark_message_read"("p_message_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."mark_message_read"("p_message_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_message_read"("p_message_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."mark_stream_gift"("p_stream_id" "uuid", "p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."mark_stream_gift"("p_stream_id" "uuid", "p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."mark_stream_gift"("p_stream_id" "uuid", "p_user_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."mark_user_paid"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."mark_user_paid"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_user_paid"("p_user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."marketplace_items_sync_title"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."marketplace_items_sync_title"() TO "service_role";
GRANT ALL ON FUNCTION "public"."marketplace_items_sync_title"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."mute_user"("target" "uuid", "minutes" integer, "reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."mute_user"("target" "uuid", "minutes" integer, "reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."mute_user"("target" "uuid", "minutes" integer, "reason" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_all_users"("p_title" "text", "p_message" "text", "p_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."notify_all_users"("p_title" "text", "p_message" "text", "p_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_all_users"("p_title" "text", "p_message" "text", "p_type" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."notify_badge_unlocked"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."notify_badge_unlocked"() TO "service_role";
GRANT ALL ON FUNCTION "public"."notify_badge_unlocked"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."notify_gift_received"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."notify_gift_received"() TO "service_role";
GRANT ALL ON FUNCTION "public"."notify_gift_received"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."notify_moderation_action"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."notify_moderation_action"() TO "service_role";
GRANT ALL ON FUNCTION "public"."notify_moderation_action"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."notify_payout_status"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."notify_payout_status"() TO "service_role";
GRANT ALL ON FUNCTION "public"."notify_payout_status"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."notify_user_rpc"("p_target_user_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_metadata" "jsonb", "p_is_read" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."notify_user_rpc"("p_target_user_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_metadata" "jsonb", "p_is_read" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_user_rpc"("p_target_user_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_metadata" "jsonb", "p_is_read" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."officer_cashout_after_shift"("p_shift_log_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."officer_cashout_after_shift"("p_shift_log_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."officer_cashout_after_shift"("p_shift_log_id" "uuid") TO "service_role";



GRANT ALL ON TABLE "public"."officer_chat_messages" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_chat_messages" TO "authenticated";



REVOKE ALL ON FUNCTION "public"."officer_send_message"("p_message" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."officer_send_message"("p_message" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."officer_send_message"("p_message" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."on_giftcard_failure_alert"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."on_giftcard_failure_alert"() TO "service_role";
GRANT ALL ON FUNCTION "public"."on_giftcard_failure_alert"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."pay_ban_restoration_fee"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."pay_ban_restoration_fee"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."pay_ban_restoration_fee"("p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."pay_for_message"("p_sender_id" "uuid", "p_recipient_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."pay_for_message"("p_sender_id" "uuid", "p_recipient_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."pay_for_message"("p_sender_id" "uuid", "p_recipient_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."pay_for_profile_view"("p_viewer_id" "uuid", "p_profile_owner_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."pay_for_profile_view"("p_viewer_id" "uuid", "p_profile_owner_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."pay_for_profile_view"("p_viewer_id" "uuid", "p_profile_owner_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."pay_kick_reentry_fee"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."pay_kick_reentry_fee"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."pay_kick_reentry_fee"("p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."payout_trigger"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."payout_trigger"() TO "service_role";
GRANT ALL ON FUNCTION "public"."payout_trigger"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."perform_daily_trollmond_giveaway"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."perform_daily_trollmond_giveaway"() TO "service_role";
GRANT ALL ON FUNCTION "public"."perform_daily_trollmond_giveaway"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."place_payment_hold"("target" "uuid", "hold_type" "text", "reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."place_payment_hold"("target" "uuid", "hold_type" "text", "reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."place_payment_hold"("target" "uuid", "hold_type" "text", "reason" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."prestige_user"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."prestige_user"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."prestige_user"("p_user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."prevent_hr_field_changes"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."prevent_hr_field_changes"() TO "service_role";
GRANT ALL ON FUNCTION "public"."prevent_hr_field_changes"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."prevent_negative_paid_coins"() TO "anon";
GRANT ALL ON FUNCTION "public"."prevent_negative_paid_coins"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."prevent_negative_paid_coins"() TO "service_role";



GRANT ALL ON FUNCTION "public"."prevent_negative_troll_coins"() TO "anon";
GRANT ALL ON FUNCTION "public"."prevent_negative_troll_coins"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."prevent_negative_troll_coins"() TO "service_role";



GRANT ALL ON FUNCTION "public"."prevent_over_reservation"() TO "anon";
GRANT ALL ON FUNCTION "public"."prevent_over_reservation"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."prevent_over_reservation"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."prevent_profile_privilege_escalation"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."prevent_profile_privilege_escalation"() TO "service_role";
GRANT ALL ON FUNCTION "public"."prevent_profile_privilege_escalation"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."prevent_protected_profile_changes"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."prevent_protected_profile_changes"() TO "service_role";
GRANT ALL ON FUNCTION "public"."prevent_protected_profile_changes"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."prevent_redemption_tier_changes"() TO "anon";
GRANT ALL ON FUNCTION "public"."prevent_redemption_tier_changes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."prevent_redemption_tier_changes"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."prevent_role_change"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."prevent_role_change"() TO "service_role";
GRANT ALL ON FUNCTION "public"."prevent_role_change"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."process_admin_gift"("p_gifter_id" "uuid", "p_admin_id" "uuid", "p_troll_coins" bigint) TO "anon";
GRANT ALL ON FUNCTION "public"."process_admin_gift"("p_gifter_id" "uuid", "p_admin_id" "uuid", "p_troll_coins" bigint) TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_admin_gift"("p_gifter_id" "uuid", "p_admin_id" "uuid", "p_troll_coins" bigint) TO "service_role";



GRANT ALL ON FUNCTION "public"."process_cashout_refund"("p_request_id" "uuid", "p_admin_id" "uuid", "p_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."process_cashout_refund"("p_request_id" "uuid", "p_admin_id" "uuid", "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_cashout_refund"("p_request_id" "uuid", "p_admin_id" "uuid", "p_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."process_gift"("p_sender_id" "uuid", "p_streamer_id" "uuid", "p_stream_id" "uuid", "p_gift_id" "text", "p_gift_name" "text", "p_coins_spent" integer, "p_gift_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."process_gift"("p_sender_id" "uuid", "p_streamer_id" "uuid", "p_stream_id" "uuid", "p_gift_id" "text", "p_gift_name" "text", "p_coins_spent" integer, "p_gift_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_gift"("p_sender_id" "uuid", "p_streamer_id" "uuid", "p_stream_id" "uuid", "p_gift_id" "text", "p_gift_name" "text", "p_coins_spent" integer, "p_gift_type" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."process_gift"("p_sender_id" "uuid", "p_streamer_id" "uuid", "p_stream_id" "uuid", "p_gift_id" "text", "p_gift_name" "text", "p_coins_spent" bigint, "p_gift_type" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."process_gift"("p_sender_id" "uuid", "p_streamer_id" "uuid", "p_stream_id" "uuid", "p_gift_id" "text", "p_gift_name" "text", "p_coins_spent" bigint, "p_gift_type" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."process_gift"("p_sender_id" "uuid", "p_streamer_id" "uuid", "p_stream_id" "uuid", "p_gift_id" "text", "p_gift_name" "text", "p_coins_spent" bigint, "p_gift_type" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."process_gift_transaction"() TO "anon";
GRANT ALL ON FUNCTION "public"."process_gift_transaction"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_gift_transaction"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."process_gift_with_lucky"("p_sender_id" "uuid", "p_receiver_id" "uuid", "p_paid_coins" bigint, "p_gift_type" character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."process_gift_with_lucky"("p_sender_id" "uuid", "p_receiver_id" "uuid", "p_paid_coins" bigint, "p_gift_type" character varying) TO "service_role";
GRANT ALL ON FUNCTION "public"."process_gift_with_lucky"("p_sender_id" "uuid", "p_receiver_id" "uuid", "p_paid_coins" bigint, "p_gift_type" character varying) TO "authenticated";



GRANT ALL ON FUNCTION "public"."process_missed_court"("p_docket_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."process_missed_court"("p_docket_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_missed_court"("p_docket_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."process_payout"("p_payout_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."process_payout"("p_payout_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."process_payout"("p_payout_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."process_payout_request"("p_request_id" "uuid", "p_requested_coins" bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."process_payout_request"("p_request_id" "uuid", "p_requested_coins" bigint) TO "service_role";
GRANT ALL ON FUNCTION "public"."process_payout_request"("p_request_id" "uuid", "p_requested_coins" bigint) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."process_referral_rewards"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."process_referral_rewards"() TO "service_role";
GRANT ALL ON FUNCTION "public"."process_referral_rewards"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."process_trolltract_weekly_payout"("p_week_start" timestamp with time zone, "p_week_end" timestamp with time zone, "p_threshold" bigint, "p_reward" bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."process_trolltract_weekly_payout"("p_week_start" timestamp with time zone, "p_week_end" timestamp with time zone, "p_threshold" bigint, "p_reward" bigint) TO "service_role";
GRANT ALL ON FUNCTION "public"."process_trolltract_weekly_payout"("p_week_start" timestamp with time zone, "p_week_end" timestamp with time zone, "p_threshold" bigint, "p_reward" bigint) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."promote_to_lead"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."promote_to_lead"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."promote_to_lead"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."purchase_broadcast_theme"("p_theme_id" "uuid", "p_set_active" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."purchase_broadcast_theme"("p_theme_id" "uuid", "p_set_active" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."purchase_broadcast_theme"("p_theme_id" "uuid", "p_set_active" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."purchase_broadcast_theme"("p_theme_id" "uuid", "p_set_active" boolean) TO "service_role";



REVOKE ALL ON FUNCTION "public"."purchase_broadcast_theme"("p_set_active" boolean, "p_theme_id" "uuid", "p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."purchase_broadcast_theme"("p_set_active" boolean, "p_theme_id" "uuid", "p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."purchase_broadcast_theme"("p_set_active" boolean, "p_theme_id" "uuid", "p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."purchase_broadcast_theme"("p_set_active" boolean, "p_theme_id" "uuid", "p_user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."purchase_call_sound"("p_sound_id" "uuid", "p_set_active" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."purchase_call_sound"("p_sound_id" "uuid", "p_set_active" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."purchase_call_sound"("p_sound_id" "uuid", "p_set_active" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."purchase_call_sound"("p_sound_id" "uuid", "p_set_active" boolean) TO "service_role";



REVOKE ALL ON FUNCTION "public"."purchase_coins"("p_user_id" "uuid", "p_package_id" "text", "p_coins" bigint, "p_amount" numeric, "p_square_tx_id" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."purchase_coins"("p_user_id" "uuid", "p_package_id" "text", "p_coins" bigint, "p_amount" numeric, "p_square_tx_id" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."purchase_coins"("p_user_id" "uuid", "p_package_id" "text", "p_coins" bigint, "p_amount" numeric, "p_square_tx_id" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."purchase_entrance_effect"("p_user_id" "uuid", "p_effect_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."purchase_entrance_effect"("p_user_id" "uuid", "p_effect_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."purchase_entrance_effect"("p_user_id" "uuid", "p_effect_id" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."purchase_inventory_item"("p_user_id" "uuid", "p_item_id" "uuid", "p_quantity" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."purchase_inventory_item"("p_user_id" "uuid", "p_item_id" "uuid", "p_quantity" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."purchase_inventory_item"("p_user_id" "uuid", "p_item_id" "uuid", "p_quantity" integer) TO "authenticated";



GRANT ALL ON FUNCTION "public"."purchase_perk"("p_perk_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."purchase_perk"("p_perk_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."purchase_perk"("p_perk_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."purchase_trolltract"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."purchase_trolltract"() TO "service_role";
GRANT ALL ON FUNCTION "public"."purchase_trolltract"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."record_agreement_acceptance"("p_user_id" "uuid", "p_agreement_version" "text", "p_ip_address" "text", "p_user_agent" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."record_agreement_acceptance"("p_user_id" "uuid", "p_agreement_version" "text", "p_ip_address" "text", "p_user_agent" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."record_agreement_acceptance"("p_user_id" "uuid", "p_agreement_version" "text", "p_ip_address" "text", "p_user_agent" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."record_dna_event"("p_user_id" "uuid", "p_event_type" "text", "p_event_data" "jsonb") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."record_dna_event"("p_user_id" "uuid", "p_event_type" "text", "p_event_data" "jsonb") TO "service_role";
GRANT ALL ON FUNCTION "public"."record_dna_event"("p_user_id" "uuid", "p_event_type" "text", "p_event_data" "jsonb") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."record_home_feature_spend"("p_coins_spent" bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."record_home_feature_spend"("p_coins_spent" bigint) TO "service_role";
GRANT ALL ON FUNCTION "public"."record_home_feature_spend"("p_coins_spent" bigint) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."record_home_feature_spend"("p_user_id" "uuid", "p_coins_spent" bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."record_home_feature_spend"("p_user_id" "uuid", "p_coins_spent" bigint) TO "service_role";
GRANT ALL ON FUNCTION "public"."record_home_feature_spend"("p_user_id" "uuid", "p_coins_spent" bigint) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."record_post_view"("p_post_id" "uuid", "p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."record_post_view"("p_post_id" "uuid", "p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."record_post_view"("p_post_id" "uuid", "p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."record_promo_code_use"("p_promo_code_id" "uuid", "p_user_id" "uuid", "p_discount_applied" numeric, "p_original_price" numeric, "p_final_price" numeric, "p_transaction_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."record_promo_code_use"("p_promo_code_id" "uuid", "p_user_id" "uuid", "p_discount_applied" numeric, "p_original_price" numeric, "p_final_price" numeric, "p_transaction_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."record_promo_code_use"("p_promo_code_id" "uuid", "p_user_id" "uuid", "p_discount_applied" numeric, "p_original_price" numeric, "p_final_price" numeric, "p_transaction_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."record_tromody_gift"("p_session" "uuid", "p_from_user" "uuid", "p_side" "text", "p_coin_amount" bigint, "p_usd_amount" numeric, "p_coin_type" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."record_tromody_gift"("p_session" "uuid", "p_from_user" "uuid", "p_side" "text", "p_coin_amount" bigint, "p_usd_amount" numeric, "p_coin_type" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."record_tromody_gift"("p_session" "uuid", "p_from_user" "uuid", "p_side" "text", "p_coin_amount" bigint, "p_usd_amount" numeric, "p_coin_type" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."refresh_probation_status"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."refresh_probation_status"() TO "service_role";
GRANT ALL ON FUNCTION "public"."refresh_probation_status"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."refund_payout_coins"("refund_user_id" "uuid", "refund_amount" bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."refund_payout_coins"("refund_user_id" "uuid", "refund_amount" bigint) TO "service_role";
GRANT ALL ON FUNCTION "public"."refund_payout_coins"("refund_user_id" "uuid", "refund_amount" bigint) TO "authenticated";



GRANT ALL ON FUNCTION "public"."register_session"("p_user_id" "uuid", "p_session_id" "uuid", "p_device_info" "jsonb", "p_ip_address" "text", "p_user_agent" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."register_session"("p_user_id" "uuid", "p_session_id" "uuid", "p_device_info" "jsonb", "p_ip_address" "text", "p_user_agent" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."register_session"("p_user_id" "uuid", "p_session_id" "uuid", "p_device_info" "jsonb", "p_ip_address" "text", "p_user_agent" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."reject_empire_partner"("p_application_id" "uuid", "p_reviewer_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."reject_empire_partner"("p_application_id" "uuid", "p_reviewer_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."reject_empire_partner"("p_application_id" "uuid", "p_reviewer_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."reject_payout"("p_payout_id" "uuid", "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."reject_payout"("p_payout_id" "uuid", "p_reason" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."reject_payout"("p_payout_id" "uuid", "p_reason" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."reject_visa_redemption"("p_redemption_id" "uuid", "p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."reject_visa_redemption"("p_redemption_id" "uuid", "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."reject_visa_redemption"("p_redemption_id" "uuid", "p_reason" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."release_broadcast_seat"("p_room" "text", "p_seat_index" integer, "p_user_id" "uuid", "p_force" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."release_broadcast_seat"("p_room" "text", "p_seat_index" integer, "p_user_id" "uuid", "p_force" boolean) TO "service_role";
GRANT ALL ON FUNCTION "public"."release_broadcast_seat"("p_room" "text", "p_seat_index" integer, "p_user_id" "uuid", "p_force" boolean) TO "authenticated";



GRANT ALL ON FUNCTION "public"."release_payment_hold"("hold_id" "uuid", "reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."release_payment_hold"("hold_id" "uuid", "reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."release_payment_hold"("hold_id" "uuid", "reason" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."relock_payouts"("p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."relock_payouts"("p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."relock_payouts"("p_reason" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."remove_og_status_after_period"() TO "anon";
GRANT ALL ON FUNCTION "public"."remove_og_status_after_period"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."remove_og_status_after_period"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."remove_verification"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."remove_verification"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."remove_verification"("p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."request_cashout"("p_amount" bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."request_cashout"("p_amount" bigint) TO "service_role";
GRANT ALL ON FUNCTION "public"."request_cashout"("p_amount" bigint) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."request_court_box"("p_session_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."request_court_box"("p_session_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."request_court_box"("p_session_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_amount_troll_coins" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_amount_troll_coins" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_amount_troll_coins" integer) TO "service_role";



REVOKE ALL ON FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_coins_to_redeem" bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_coins_to_redeem" bigint) TO "service_role";
GRANT ALL ON FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_coins_to_redeem" bigint) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_coins_to_redeem" bigint, "p_idempotency_key" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_coins_to_redeem" bigint, "p_idempotency_key" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_coins_to_redeem" bigint, "p_idempotency_key" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_coin_amount" integer, "p_cash_amount" numeric, "p_fee_amount" numeric, "p_provider_type" "text", "p_provider_username" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_coin_amount" integer, "p_cash_amount" numeric, "p_fee_amount" numeric, "p_provider_type" "text", "p_provider_username" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."request_payout"("p_user_id" "uuid", "p_coin_amount" integer, "p_cash_amount" numeric, "p_fee_amount" numeric, "p_provider_type" "text", "p_provider_username" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."request_visa_redemption"("p_user_id" "uuid", "p_coins" bigint, "p_usd" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."request_visa_redemption"("p_user_id" "uuid", "p_coins" bigint, "p_usd" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."request_visa_redemption"("p_user_id" "uuid", "p_coins" bigint, "p_usd" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."reserve_paid_coins_on_redemption"() TO "anon";
GRANT ALL ON FUNCTION "public"."reserve_paid_coins_on_redemption"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."reserve_paid_coins_on_redemption"() TO "service_role";



GRANT ALL ON FUNCTION "public"."reserve_troll_coins_on_redemption"() TO "anon";
GRANT ALL ON FUNCTION "public"."reserve_troll_coins_on_redemption"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."reserve_troll_coins_on_redemption"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."reset_app_for_launch"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."reset_app_for_launch"() TO "service_role";
GRANT ALL ON FUNCTION "public"."reset_app_for_launch"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."reset_user_coins"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."reset_user_coins"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."reset_user_coins"("p_user_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."reset_weekly_family_war_points"() TO "anon";
GRANT ALL ON FUNCTION "public"."reset_weekly_family_war_points"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."reset_weekly_family_war_points"() TO "service_role";



GRANT ALL ON FUNCTION "public"."review_seller_appeal"("p_application_id" "uuid", "p_action" "text", "p_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."review_seller_appeal"("p_application_id" "uuid", "p_action" "text", "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."review_seller_appeal"("p_application_id" "uuid", "p_action" "text", "p_notes" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."revoke_lead"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."revoke_lead"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."revoke_lead"("p_user_id" "uuid", "p_acted_by" "uuid", "p_reason" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."rpc_buy_property_insurance"("p_user_id" "uuid", "p_property_id" "uuid", "p_cost" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."rpc_buy_property_insurance"("p_user_id" "uuid", "p_property_id" "uuid", "p_cost" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."rpc_buy_property_insurance"("p_user_id" "uuid", "p_property_id" "uuid", "p_cost" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."rpc_deduct_troll_coins"("p_amount" bigint, "p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."rpc_deduct_troll_coins"("p_amount" bigint, "p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."rpc_deduct_troll_coins"("p_amount" bigint, "p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."rpc_raid_property"("p_raider_id" "uuid", "p_property_id" "uuid", "p_raid_fee" integer, "p_max_reward" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."rpc_raid_property"("p_raider_id" "uuid", "p_property_id" "uuid", "p_raid_fee" integer, "p_max_reward" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."rpc_raid_property"("p_raider_id" "uuid", "p_property_id" "uuid", "p_raid_fee" integer, "p_max_reward" integer) TO "service_role";



REVOKE ALL ON FUNCTION "public"."run_broadcast_cycle"("p_now" timestamp with time zone, "p_max_winners" integer, "p_drop_amount_paid_coins" bigint, "p_pool_key" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."run_broadcast_cycle"("p_now" timestamp with time zone, "p_max_winners" integer, "p_drop_amount_paid_coins" bigint, "p_pool_key" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."run_broadcast_cycle"("p_now" timestamp with time zone, "p_max_winners" integer, "p_drop_amount_paid_coins" bigint, "p_pool_key" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."run_daily_gift_leaderboards"() TO "anon";
GRANT ALL ON FUNCTION "public"."run_daily_gift_leaderboards"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."run_daily_gift_leaderboards"() TO "service_role";



GRANT ALL ON FUNCTION "public"."run_monthly_gift_leaderboards"() TO "anon";
GRANT ALL ON FUNCTION "public"."run_monthly_gift_leaderboards"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."run_monthly_gift_leaderboards"() TO "service_role";



GRANT ALL ON FUNCTION "public"."run_weekly_gift_leaderboards"() TO "anon";
GRANT ALL ON FUNCTION "public"."run_weekly_gift_leaderboards"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."run_weekly_gift_leaderboards"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."send_inventory_gift"("p_sender_id" "uuid", "p_item_id" "uuid", "p_target_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."send_inventory_gift"("p_sender_id" "uuid", "p_item_id" "uuid", "p_target_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."send_inventory_gift"("p_sender_id" "uuid", "p_item_id" "uuid", "p_target_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."send_wall_post_gift"("p_post_id" "uuid", "p_gift_type" "text", "p_quantity" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."send_wall_post_gift"("p_post_id" "uuid", "p_gift_type" "text", "p_quantity" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."send_wall_post_gift"("p_post_id" "uuid", "p_gift_type" "text", "p_quantity" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."set_action_logs_created_day"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_action_logs_created_day"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_action_logs_created_day"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."set_active_broadcast_theme"("p_theme_slug" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."set_active_broadcast_theme"("p_theme_slug" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."set_active_broadcast_theme"("p_theme_slug" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_active_broadcast_theme"("p_theme_slug" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."set_active_broadcast_theme"("p_theme_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."set_active_broadcast_theme"("p_theme_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_active_broadcast_theme"("p_theme_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."set_active_broadcast_theme"("p_user_id" "uuid", "p_theme_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."set_active_broadcast_theme"("p_user_id" "uuid", "p_theme_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_active_broadcast_theme"("p_user_id" "uuid", "p_theme_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."set_active_call_sound"("p_sound_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."set_active_call_sound"("p_sound_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."set_active_call_sound"("p_sound_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_active_call_sound"("p_sound_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."set_active_entrance_effect"("p_effect_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."set_active_entrance_effect"("p_effect_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_active_entrance_effect"("p_effect_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."set_active_entrance_effect"("p_effect_id" "text", "p_item_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."set_active_entrance_effect"("p_effect_id" "text", "p_item_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_active_entrance_effect"("p_effect_id" "text", "p_item_type" "text") TO "service_role";



GRANT ALL ON TABLE "public"."court_sessions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."court_sessions" TO "authenticated";



REVOKE ALL ON FUNCTION "public"."set_court_boxes"("p_session_id" "text", "p_max_boxes" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."set_court_boxes"("p_session_id" "text", "p_max_boxes" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."set_court_boxes"("p_session_id" "text", "p_max_boxes" integer) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."set_court_session_started_by"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."set_court_session_started_by"() TO "service_role";
GRANT ALL ON FUNCTION "public"."set_court_session_started_by"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."set_default_troll_coins"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."set_default_troll_coins"() TO "service_role";
GRANT ALL ON FUNCTION "public"."set_default_troll_coins"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."set_lead_officer_status"("p_user_id" "uuid", "p_make_lead" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."set_lead_officer_status"("p_user_id" "uuid", "p_make_lead" boolean) TO "service_role";
GRANT ALL ON FUNCTION "public"."set_lead_officer_status"("p_user_id" "uuid", "p_make_lead" boolean) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."set_officer_status"("target_user" "uuid", "new_status" "text", "reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."set_officer_status"("target_user" "uuid", "new_status" "text", "reason" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."set_officer_status"("target_user" "uuid", "new_status" "text", "reason" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."set_og_badge"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_og_badge"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_og_badge"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_og_status_for_new_users"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_og_status_for_new_users"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_og_status_for_new_users"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."set_referral_deadline"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."set_referral_deadline"() TO "service_role";
GRANT ALL ON FUNCTION "public"."set_referral_deadline"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."set_trollstown_coins_on_insert"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_trollstown_coins_on_insert"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_trollstown_coins_on_insert"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."set_updated_at"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "service_role";
GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."set_user_role"("target_user" "uuid", "new_role" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."set_user_role"("target_user" "uuid", "new_role" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."set_user_role"("target_user" "uuid", "new_role" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."set_user_role"("target_user" "uuid", "new_role" "text", "reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."set_user_role"("target_user" "uuid", "new_role" "text", "reason" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."set_user_role"("target_user" "uuid", "new_role" "text", "reason" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."some_function"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."some_function"() TO "service_role";
GRANT ALL ON FUNCTION "public"."some_function"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."something"("a" integer, "b" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."something"("a" integer, "b" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."something"("a" integer, "b" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."spawn_troll_event"("p_troll_type" "text", "p_reward_amount" integer, "p_duration_minutes" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."spawn_troll_event"("p_troll_type" "text", "p_reward_amount" integer, "p_duration_minutes" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."spawn_troll_event"("p_troll_type" "text", "p_reward_amount" integer, "p_duration_minutes" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."spend_coins"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text", "p_metadata" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."spend_coins"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text", "p_metadata" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."spend_coins"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text", "p_metadata" "jsonb") TO "service_role";



REVOKE ALL ON FUNCTION "public"."spend_coins"("p_sender_id" "uuid", "p_receiver_id" "uuid", "p_coin_amount" bigint, "p_source" "text", "p_item" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."spend_coins"("p_sender_id" "uuid", "p_receiver_id" "uuid", "p_coin_amount" bigint, "p_source" "text", "p_item" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."spend_coins"("p_sender_id" "uuid", "p_receiver_id" "uuid", "p_coin_amount" bigint, "p_source" "text", "p_item" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."spend_free_coins"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."spend_free_coins"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."spend_free_coins"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."spend_troll_coins"("p_receiver_id" "uuid", "p_amount" bigint, "p_source" "text", "p_item" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."spend_troll_coins"("p_receiver_id" "uuid", "p_amount" bigint, "p_source" "text", "p_item" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."spend_troll_coins"("p_receiver_id" "uuid", "p_amount" bigint, "p_source" "text", "p_item" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."spend_trollmonds"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."spend_trollmonds"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."spend_trollmonds"("p_user_id" "uuid", "p_amount" bigint, "p_reason" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."spend_trollmonds"("p_receiver_id" "uuid", "p_amount" bigint, "p_source" "text", "p_item" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."spend_trollmonds"("p_receiver_id" "uuid", "p_amount" bigint, "p_source" "text", "p_item" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."spend_trollmonds"("p_receiver_id" "uuid", "p_amount" bigint, "p_source" "text", "p_item" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."spin_wheel"("user_id" "uuid", "cost" integer, "prize_amount" integer, "prize_type" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."spin_wheel"("user_id" "uuid", "cost" integer, "prize_amount" integer, "prize_type" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."spin_wheel"("user_id" "uuid", "cost" integer, "prize_amount" integer, "prize_type" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."start_court_session"("p_room_name" "text", "p_session_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."start_court_session"("p_room_name" "text", "p_session_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."start_court_session"("p_room_name" "text", "p_session_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."start_court_session"("p_session_id" "uuid", "p_max_boxes" integer, "p_room_name" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."start_court_session"("p_session_id" "uuid", "p_max_boxes" integer, "p_room_name" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."start_court_session"("p_session_id" "uuid", "p_max_boxes" integer, "p_room_name" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."start_launch_trial"("p_admin_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."start_launch_trial"("p_admin_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."start_launch_trial"("p_admin_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."start_officer_orientation"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."start_officer_orientation"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."start_officer_orientation"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."submit_cashout_request"("p_user_id" "uuid", "p_amount_coins" integer, "p_usd_value" numeric, "p_provider" "text", "p_delivery_method" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."submit_cashout_request"("p_user_id" "uuid", "p_amount_coins" integer, "p_usd_value" numeric, "p_provider" "text", "p_delivery_method" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."submit_cashout_request"("p_user_id" "uuid", "p_amount_coins" integer, "p_usd_value" numeric, "p_provider" "text", "p_delivery_method" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."submit_id_verification"("p_user_id" "uuid", "p_id_photo_url" "text", "p_id_photo_hash" "text", "p_source" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."submit_id_verification"("p_user_id" "uuid", "p_id_photo_url" "text", "p_id_photo_hash" "text", "p_source" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."submit_id_verification"("p_user_id" "uuid", "p_id_photo_url" "text", "p_id_photo_hash" "text", "p_source" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."submit_officer_quiz"("p_answers" "jsonb", "p_time_taken_seconds" integer, "p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."submit_officer_quiz"("p_answers" "jsonb", "p_time_taken_seconds" integer, "p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."submit_officer_quiz"("p_answers" "jsonb", "p_time_taken_seconds" integer, "p_user_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."submit_officer_quiz"("p_user_id" "uuid", "p_answers" "jsonb", "p_time_taken_seconds" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."submit_officer_quiz"("p_user_id" "uuid", "p_answers" "jsonb", "p_time_taken_seconds" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."submit_officer_quiz"("p_user_id" "uuid", "p_answers" "jsonb", "p_time_taken_seconds" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."submit_seller_appeal"("p_application_id" "uuid", "p_appeal_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."submit_seller_appeal"("p_application_id" "uuid", "p_appeal_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."submit_seller_appeal"("p_application_id" "uuid", "p_appeal_reason" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."submit_weekly_report"("p_lead_officer_id" "uuid", "p_week_start" "date", "p_week_end" "date", "p_title" "text", "p_body" "text", "p_incidents" "jsonb") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."submit_weekly_report"("p_lead_officer_id" "uuid", "p_week_start" "date", "p_week_end" "date", "p_title" "text", "p_body" "text", "p_incidents" "jsonb") TO "service_role";
GRANT ALL ON FUNCTION "public"."submit_weekly_report"("p_lead_officer_id" "uuid", "p_week_start" "date", "p_week_end" "date", "p_title" "text", "p_body" "text", "p_incidents" "jsonb") TO "authenticated";



GRANT ALL ON TABLE "public"."court_summons" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."court_summons" TO "authenticated";



REVOKE ALL ON FUNCTION "public"."summon_to_court"("p_summoned_user_id" "uuid", "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."summon_to_court"("p_summoned_user_id" "uuid", "p_reason" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."summon_to_court"("p_summoned_user_id" "uuid", "p_reason" "text") TO "authenticated";



GRANT ALL ON FUNCTION "public"."sync_action_type"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_action_type"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_action_type"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."sync_badge_from_role"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."sync_badge_from_role"() TO "service_role";
GRANT ALL ON FUNCTION "public"."sync_badge_from_role"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."sync_empire_applicant_id"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."sync_empire_applicant_id"() TO "service_role";
GRANT ALL ON FUNCTION "public"."sync_empire_applicant_id"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."sync_family_coins"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_family_coins"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_family_coins"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."sync_key_columns"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."sync_key_columns"() TO "service_role";
GRANT ALL ON FUNCTION "public"."sync_key_columns"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."sync_troll_battle_broadcasters"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."sync_troll_battle_broadcasters"() TO "service_role";
GRANT ALL ON FUNCTION "public"."sync_troll_battle_broadcasters"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."sync_troll_role"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_troll_role"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_troll_role"() TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_trollstown_coins_from_profiles"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_trollstown_coins_from_profiles"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_trollstown_coins_from_profiles"() TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_user_entrance_effects_cache"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_user_entrance_effects_cache"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_user_entrance_effects_cache"() TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_vault_tokens"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_vault_tokens"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_vault_tokens"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."sync_wallet_balance_to_profile"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."sync_wallet_balance_to_profile"() TO "service_role";
GRANT ALL ON FUNCTION "public"."sync_wallet_balance_to_profile"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."toggle_anti_hack_system"("p_admin_id" "uuid", "p_code" "text", "p_enabled" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."toggle_anti_hack_system"("p_admin_id" "uuid", "p_code" "text", "p_enabled" boolean) TO "service_role";
GRANT ALL ON FUNCTION "public"."toggle_anti_hack_system"("p_admin_id" "uuid", "p_code" "text", "p_enabled" boolean) TO "authenticated";



GRANT ALL ON FUNCTION "public"."toggle_entrance_effect"("p_user_id" "uuid", "p_item_id" "uuid", "p_active" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."toggle_entrance_effect"("p_user_id" "uuid", "p_item_id" "uuid", "p_active" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."toggle_entrance_effect"("p_user_id" "uuid", "p_item_id" "uuid", "p_active" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."toggle_follow"("target_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."toggle_follow"("target_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."toggle_follow"("target_user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."toggle_wall_post_like"("p_post_id" "uuid", "p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."toggle_wall_post_like"("p_post_id" "uuid", "p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."toggle_wall_post_like"("p_post_id" "uuid", "p_user_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."toggle_wall_post_reaction"("p_post_id" "uuid", "p_reaction_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."toggle_wall_post_reaction"("p_post_id" "uuid", "p_reaction_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."toggle_wall_post_reaction"("p_post_id" "uuid", "p_reaction_type" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."toggle_wall_post_reaction"("p_post_id" "uuid", "p_user_id" "uuid", "p_reaction_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."toggle_wall_post_reaction"("p_post_id" "uuid", "p_user_id" "uuid", "p_reaction_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."toggle_wall_post_reaction"("p_post_id" "uuid", "p_user_id" "uuid", "p_reaction_type" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."touch_updated_at"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."touch_updated_at"() TO "service_role";
GRANT ALL ON FUNCTION "public"."touch_updated_at"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."track_broadcaster_earnings"() TO "anon";
GRANT ALL ON FUNCTION "public"."track_broadcaster_earnings"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."track_broadcaster_earnings"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_revoke_property_insurance_on_transfer"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_revoke_property_insurance_on_transfer"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_revoke_property_insurance_on_transfer"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_award_streamer_xp"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_award_streamer_xp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_award_streamer_xp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_cleanup_sessions"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_cleanup_sessions"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_cleanup_sessions"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."trollstown_compute_stage"("p_population" bigint, "p_properties" bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."trollstown_compute_stage"("p_population" bigint, "p_properties" bigint) TO "service_role";
GRANT ALL ON FUNCTION "public"."trollstown_compute_stage"("p_population" bigint, "p_properties" bigint) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."trollstown_process_rent_cycle"("p_cycle_start" timestamp with time zone, "p_cycle_end" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."trollstown_process_rent_cycle"("p_cycle_start" timestamp with time zone, "p_cycle_end" timestamp with time zone) TO "service_role";
GRANT ALL ON FUNCTION "public"."trollstown_process_rent_cycle"("p_cycle_start" timestamp with time zone, "p_cycle_end" timestamp with time zone) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."trollstown_refresh_city_state"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."trollstown_refresh_city_state"() TO "service_role";
GRANT ALL ON FUNCTION "public"."trollstown_refresh_city_state"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."unban_ip_address"("p_ip_address" "inet", "p_officer_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."unban_ip_address"("p_ip_address" "inet", "p_officer_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."unban_ip_address"("p_ip_address" "inet", "p_officer_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."unban_officer"("p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."unban_officer"("p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."unban_officer"("p_user_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."update_abuse_reports_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_abuse_reports_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_abuse_reports_updated_at"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."update_admin_tax_reviews_timestamp"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_admin_tax_reviews_timestamp"() TO "service_role";
GRANT ALL ON FUNCTION "public"."update_admin_tax_reviews_timestamp"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."update_battle_coins"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_battle_coins"() TO "service_role";
GRANT ALL ON FUNCTION "public"."update_battle_coins"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."update_court_docket_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_court_docket_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_court_docket_updated_at"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."update_court_judge"("p_session_id" "text", "p_judge_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_court_judge"("p_session_id" "text", "p_judge_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."update_court_judge"("p_session_id" "text", "p_judge_id" "uuid") TO "authenticated";



GRANT ALL ON FUNCTION "public"."update_creator_applications_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_creator_applications_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_creator_applications_updated_at"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."update_creator_earnings"("p_user_id" "uuid", "p_amount_cents" integer, "p_year" integer, "p_month" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_creator_earnings"("p_user_id" "uuid", "p_amount_cents" integer, "p_year" integer, "p_month" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."update_creator_earnings"("p_user_id" "uuid", "p_amount_cents" integer, "p_year" integer, "p_month" integer) TO "authenticated";



GRANT ALL ON FUNCTION "public"."update_district_progress"("p_user_id" "uuid", "p_district_id" "uuid", "p_onboarding_completed" boolean, "p_feature_explored" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."update_district_progress"("p_user_id" "uuid", "p_district_id" "uuid", "p_onboarding_completed" boolean, "p_feature_explored" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_district_progress"("p_user_id" "uuid", "p_district_id" "uuid", "p_onboarding_completed" boolean, "p_feature_explored" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."update_empire_applications_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_empire_applications_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_empire_applications_updated_at"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."update_hr_employees_updated_at"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_hr_employees_updated_at"() TO "service_role";
GRANT ALL ON FUNCTION "public"."update_hr_employees_updated_at"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."update_interview_sessions_updated_at"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_interview_sessions_updated_at"() TO "service_role";
GRANT ALL ON FUNCTION "public"."update_interview_sessions_updated_at"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."update_job_applications_updated_at"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_job_applications_updated_at"() TO "service_role";
GRANT ALL ON FUNCTION "public"."update_job_applications_updated_at"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."update_officer_live_assignments_updated_at"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_officer_live_assignments_updated_at"() TO "service_role";
GRANT ALL ON FUNCTION "public"."update_officer_live_assignments_updated_at"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."update_officer_orientation_results_updated_at"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_officer_orientation_results_updated_at"() TO "service_role";
GRANT ALL ON FUNCTION "public"."update_officer_orientation_results_updated_at"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."update_officer_performance"("p_officer_id" "uuid", "p_score_change" integer, "p_event_type" character varying, "p_reason" "text", "p_triggered_by" "uuid", "p_metadata" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."update_officer_performance"("p_officer_id" "uuid", "p_score_change" integer, "p_event_type" character varying, "p_reason" "text", "p_triggered_by" "uuid", "p_metadata" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_officer_performance"("p_officer_id" "uuid", "p_score_change" integer, "p_event_type" character varying, "p_reason" "text", "p_triggered_by" "uuid", "p_metadata" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_officer_promotion"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."update_officer_promotion"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_officer_promotion"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_officer_shift_logs_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_officer_shift_logs_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_officer_shift_logs_updated_at"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."update_officer_tier_badge"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_officer_tier_badge"() TO "service_role";
GRANT ALL ON FUNCTION "public"."update_officer_tier_badge"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."update_officer_work_sessions_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_officer_work_sessions_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_officer_work_sessions_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_payment_logs_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_payment_logs_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_payment_logs_updated_at"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."update_payout_requests_updated_at"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_payout_requests_updated_at"() TO "service_role";
GRANT ALL ON FUNCTION "public"."update_payout_requests_updated_at"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."update_platform_revenue_on_payment"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_platform_revenue_on_payment"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_platform_revenue_on_payment"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_post_engagement_counts"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_post_engagement_counts"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_post_engagement_counts"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."update_provider_costs_updated_at"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_provider_costs_updated_at"() TO "service_role";
GRANT ALL ON FUNCTION "public"."update_provider_costs_updated_at"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."update_royal_family_duration"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_royal_family_duration"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_royal_family_duration"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_seller_reliability"("p_seller_id" "uuid", "p_score_change" integer, "p_event_type" character varying, "p_reason" "text", "p_triggered_by" "uuid", "p_metadata" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."update_seller_reliability"("p_seller_id" "uuid", "p_score_change" integer, "p_event_type" character varying, "p_reason" "text", "p_triggered_by" "uuid", "p_metadata" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_seller_reliability"("p_seller_id" "uuid", "p_score_change" integer, "p_event_type" character varying, "p_reason" "text", "p_triggered_by" "uuid", "p_metadata" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_stores_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_stores_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_stores_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_stream_coins_from_gift"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_stream_coins_from_gift"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_stream_coins_from_gift"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."update_tax_status"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_tax_status"() TO "service_role";
GRANT ALL ON FUNCTION "public"."update_tax_status"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."update_timestamp"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_timestamp"() TO "service_role";
GRANT ALL ON FUNCTION "public"."update_timestamp"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."update_updated_at_column"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";



GRANT ALL ON FUNCTION "public"."update_user_reputation"("p_user_id" "uuid", "p_score_change" integer, "p_event_type" character varying, "p_reason" "text", "p_triggered_by" "uuid", "p_metadata" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."update_user_reputation"("p_user_id" "uuid", "p_score_change" integer, "p_event_type" character varying, "p_reason" "text", "p_triggered_by" "uuid", "p_metadata" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_user_reputation"("p_user_id" "uuid", "p_score_change" integer, "p_event_type" character varying, "p_reason" "text", "p_triggered_by" "uuid", "p_metadata" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_viewer_count"("p_stream_id" "uuid", "p_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."update_viewer_count"("p_stream_id" "uuid", "p_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_viewer_count"("p_stream_id" "uuid", "p_count" integer) TO "service_role";



REVOKE ALL ON FUNCTION "public"."update_wallet_balance"("p_user_id" "uuid", "p_currency" "text", "p_amount" bigint, "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_wallet_balance"("p_user_id" "uuid", "p_currency" "text", "p_amount" bigint, "p_reason" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."update_wallet_balance"("p_user_id" "uuid", "p_currency" "text", "p_amount" bigint, "p_reason" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."update_weekly_reports_updated_at"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_weekly_reports_updated_at"() TO "service_role";
GRANT ALL ON FUNCTION "public"."update_weekly_reports_updated_at"() TO "authenticated";



REVOKE ALL ON FUNCTION "public"."upgrade_property_slot"("p_property_id" "uuid", "p_upgrade_type" "text", "p_target_level" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."upgrade_property_slot"("p_property_id" "uuid", "p_upgrade_type" "text", "p_target_level" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."upgrade_property_slot"("p_property_id" "uuid", "p_upgrade_type" "text", "p_target_level" integer) TO "authenticated";



GRANT ALL ON FUNCTION "public"."user_has_approved_trolltract"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."user_has_approved_trolltract"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."user_has_approved_trolltract"("p_user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."validate_promo_code"("p_code" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."validate_promo_code"("p_code" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."validate_promo_code"("p_code" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."validate_promo_code"("p_user_id" "uuid", "p_code" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."validate_promo_code"("p_user_id" "uuid", "p_code" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."validate_promo_code"("p_user_id" "uuid", "p_code" "text") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."validate_promo_code"("p_code" "text", "p_original_price" numeric, "p_user_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."validate_promo_code"("p_code" "text", "p_original_price" numeric, "p_user_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."validate_promo_code"("p_code" "text", "p_original_price" numeric, "p_user_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."validate_promo_code"("p_code" "text", "p_user_id" "uuid", "p_original_price" numeric) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."validate_promo_code"("p_code" "text", "p_user_id" "uuid", "p_original_price" numeric) TO "service_role";
GRANT ALL ON FUNCTION "public"."validate_promo_code"("p_code" "text", "p_user_id" "uuid", "p_original_price" numeric) TO "authenticated";



REVOKE ALL ON FUNCTION "public"."verify_user"("p_user_id" "uuid", "p_payment_method" "text", "p_amount" numeric, "p_payment_reference" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."verify_user"("p_user_id" "uuid", "p_payment_method" "text", "p_amount" numeric, "p_payment_reference" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."verify_user"("p_user_id" "uuid", "p_payment_method" "text", "p_amount" numeric, "p_payment_reference" "text") TO "authenticated";
























GRANT ALL ON TABLE "public"."abuse_reports" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."abuse_reports" TO "authenticated";



GRANT ALL ON TABLE "public"."action_logs" TO "anon";
GRANT ALL ON TABLE "public"."action_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."action_logs" TO "service_role";



GRANT ALL ON TABLE "public"."active_sessions" TO "anon";
GRANT ALL ON TABLE "public"."active_sessions" TO "authenticated";
GRANT ALL ON TABLE "public"."active_sessions" TO "service_role";



GRANT ALL ON TABLE "public"."activity_log" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."activity_log" TO "authenticated";



GRANT ALL ON TABLE "public"."activity_logs" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."activity_logs" TO "authenticated";



GRANT ALL ON TABLE "public"."admin_adjustments" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."admin_adjustments" TO "authenticated";



GRANT ALL ON TABLE "public"."admin_broadcasts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."admin_broadcasts" TO "authenticated";



GRANT ALL ON TABLE "public"."admin_coin_pool" TO "anon";
GRANT ALL ON TABLE "public"."admin_coin_pool" TO "authenticated";
GRANT ALL ON TABLE "public"."admin_coin_pool" TO "service_role";



GRANT ALL ON TABLE "public"."admin_coin_revenue" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."admin_coin_revenue" TO "authenticated";



GRANT ALL ON TABLE "public"."admin_flags" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."admin_flags" TO "authenticated";



GRANT ALL ON TABLE "public"."admin_gift_totals" TO "anon";
GRANT ALL ON TABLE "public"."admin_gift_totals" TO "authenticated";
GRANT ALL ON TABLE "public"."admin_gift_totals" TO "service_role";



GRANT ALL ON TABLE "public"."admin_pool" TO "anon";
GRANT ALL ON TABLE "public"."admin_pool" TO "authenticated";
GRANT ALL ON TABLE "public"."admin_pool" TO "service_role";



GRANT ALL ON TABLE "public"."admin_tax_reviews" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."admin_tax_reviews" TO "authenticated";



GRANT ALL ON TABLE "public"."admin_top_buyers" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."admin_top_buyers" TO "authenticated";



GRANT ALL ON TABLE "public"."user_agreements" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user_agreements" TO "authenticated";



GRANT ALL ON TABLE "public"."agreement_stats" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."agreement_stats" TO "authenticated";



GRANT ALL ON TABLE "public"."ai_action_logs" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."ai_action_logs" TO "authenticated";



GRANT ALL ON TABLE "public"."app_settings" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."app_settings" TO "authenticated";



GRANT ALL ON TABLE "public"."app_updates" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."app_updates" TO "authenticated";



GRANT ALL ON TABLE "public"."applications" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."applications" TO "authenticated";



GRANT ALL ON TABLE "public"."badge_definitions" TO "anon";
GRANT ALL ON TABLE "public"."badge_definitions" TO "authenticated";
GRANT ALL ON TABLE "public"."badge_definitions" TO "service_role";



GRANT ALL ON TABLE "public"."balance_ledger" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."balance_ledger" TO "authenticated";



GRANT ALL ON TABLE "public"."stream_participants" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_participants" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_battles" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_battles" TO "authenticated";



GRANT ALL ON TABLE "public"."battle_arena_view" TO "anon";
GRANT ALL ON TABLE "public"."battle_arena_view" TO "authenticated";
GRANT ALL ON TABLE "public"."battle_arena_view" TO "service_role";



GRANT ALL ON TABLE "public"."battle_gifts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."battle_gifts" TO "authenticated";



GRANT ALL ON TABLE "public"."battle_history" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."battle_history" TO "authenticated";



GRANT ALL ON TABLE "public"."battle_rewards" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."battle_rewards" TO "authenticated";



GRANT ALL ON TABLE "public"."battle_sessions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."battle_sessions" TO "authenticated";



GRANT ALL ON TABLE "public"."blocked_users" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."blocked_users" TO "authenticated";



GRANT ALL ON TABLE "public"."broadcast_background_themes" TO "anon";
GRANT ALL ON TABLE "public"."broadcast_background_themes" TO "authenticated";
GRANT ALL ON TABLE "public"."broadcast_background_themes" TO "service_role";



GRANT ALL ON TABLE "public"."broadcast_cycle_stats" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."broadcast_cycle_stats" TO "authenticated";



GRANT ALL ON TABLE "public"."broadcast_seats" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."broadcast_seats" TO "authenticated";



GRANT ALL ON TABLE "public"."broadcast_seat_bans" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."broadcast_seat_bans" TO "authenticated";



GRANT ALL ON TABLE "public"."broadcast_theme_events" TO "anon";
GRANT ALL ON TABLE "public"."broadcast_theme_events" TO "authenticated";
GRANT ALL ON TABLE "public"."broadcast_theme_events" TO "service_role";



GRANT ALL ON TABLE "public"."broadcast_tokens" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."broadcast_tokens" TO "authenticated";



GRANT ALL ON TABLE "public"."broadcaster_applications" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."broadcaster_applications" TO "authenticated";



GRANT ALL ON TABLE "public"."broadcaster_earnings" TO "anon";
GRANT ALL ON TABLE "public"."broadcaster_earnings" TO "authenticated";
GRANT ALL ON TABLE "public"."broadcaster_earnings" TO "service_role";



GRANT ALL ON TABLE "public"."broadcaster_metrics" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."broadcaster_metrics" TO "authenticated";



GRANT ALL ON TABLE "public"."call_history" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."call_history" TO "authenticated";



GRANT ALL ON TABLE "public"."call_minutes" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."call_minutes" TO "authenticated";



GRANT ALL ON TABLE "public"."call_sessions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."call_sessions" TO "authenticated";



GRANT ALL ON TABLE "public"."call_sound_catalog" TO "anon";
GRANT ALL ON TABLE "public"."call_sound_catalog" TO "authenticated";
GRANT ALL ON TABLE "public"."call_sound_catalog" TO "service_role";



GRANT ALL ON TABLE "public"."call_transactions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."call_transactions" TO "authenticated";



GRANT ALL ON TABLE "public"."case_audit_logs" TO "anon";
GRANT ALL ON TABLE "public"."case_audit_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."case_audit_logs" TO "service_role";



GRANT ALL ON TABLE "public"."case_evidence" TO "anon";
GRANT ALL ON TABLE "public"."case_evidence" TO "authenticated";
GRANT ALL ON TABLE "public"."case_evidence" TO "service_role";



GRANT ALL ON TABLE "public"."case_participants" TO "anon";
GRANT ALL ON TABLE "public"."case_participants" TO "authenticated";
GRANT ALL ON TABLE "public"."case_participants" TO "service_role";



GRANT ALL ON TABLE "public"."case_templates" TO "anon";
GRANT ALL ON TABLE "public"."case_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."case_templates" TO "service_role";



GRANT ALL ON TABLE "public"."cashout_requests" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."cashout_requests" TO "authenticated";



GRANT ALL ON TABLE "public"."cashout_tiers" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."cashout_tiers" TO "authenticated";



GRANT ALL ON TABLE "public"."city_districts" TO "anon";
GRANT ALL ON TABLE "public"."city_districts" TO "authenticated";
GRANT ALL ON TABLE "public"."city_districts" TO "service_role";



GRANT ALL ON TABLE "public"."city_events" TO "anon";
GRANT ALL ON TABLE "public"."city_events" TO "authenticated";
GRANT ALL ON TABLE "public"."city_events" TO "service_role";



GRANT ALL ON TABLE "public"."clan_rewards" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."clan_rewards" TO "authenticated";



GRANT ALL ON TABLE "public"."clan_vault" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."clan_vault" TO "authenticated";



GRANT ALL ON TABLE "public"."coin_audit_log" TO "anon";
GRANT ALL ON TABLE "public"."coin_audit_log" TO "authenticated";
GRANT ALL ON TABLE "public"."coin_audit_log" TO "service_role";



GRANT ALL ON TABLE "public"."coin_ledger" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."coin_ledger" TO "authenticated";



GRANT ALL ON TABLE "public"."coin_packages" TO "anon";
GRANT ALL ON TABLE "public"."coin_packages" TO "authenticated";
GRANT ALL ON TABLE "public"."coin_packages" TO "service_role";



GRANT ALL ON TABLE "public"."coin_pool_contributions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."coin_pool_contributions" TO "authenticated";



GRANT ALL ON TABLE "public"."coin_purchases" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."coin_purchases" TO "authenticated";



GRANT ALL ON TABLE "public"."coin_reward_pool" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."coin_reward_pool" TO "authenticated";



GRANT ALL ON TABLE "public"."coin_transactions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."coin_transactions" TO "authenticated";



GRANT ALL ON TABLE "public"."coinback_log" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."coinback_log" TO "authenticated";



GRANT ALL ON TABLE "public"."config" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."config" TO "authenticated";



GRANT ALL ON TABLE "public"."content" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."content" TO "authenticated";



GRANT ALL ON TABLE "public"."conversation_members" TO "anon";
GRANT ALL ON TABLE "public"."conversation_members" TO "authenticated";
GRANT ALL ON TABLE "public"."conversation_members" TO "service_role";



GRANT ALL ON TABLE "public"."conversation_messages" TO "anon";
GRANT ALL ON TABLE "public"."conversation_messages" TO "authenticated";
GRANT ALL ON TABLE "public"."conversation_messages" TO "service_role";



GRANT ALL ON TABLE "public"."conversations" TO "anon";
GRANT ALL ON TABLE "public"."conversations" TO "authenticated";
GRANT ALL ON TABLE "public"."conversations" TO "service_role";



GRANT ALL ON TABLE "public"."court_ai_messages" TO "anon";
GRANT ALL ON TABLE "public"."court_ai_messages" TO "authenticated";
GRANT ALL ON TABLE "public"."court_ai_messages" TO "service_role";



GRANT ALL ON TABLE "public"."court_box_members" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."court_box_members" TO "authenticated";



GRANT ALL ON TABLE "public"."court_cases" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."court_cases" TO "authenticated";



GRANT ALL ON TABLE "public"."court_docket" TO "anon";
GRANT ALL ON TABLE "public"."court_docket" TO "authenticated";
GRANT ALL ON TABLE "public"."court_docket" TO "service_role";



GRANT ALL ON TABLE "public"."court_rulings_archive" TO "anon";
GRANT ALL ON TABLE "public"."court_rulings_archive" TO "authenticated";
GRANT ALL ON TABLE "public"."court_rulings_archive" TO "service_role";



GRANT ALL ON TABLE "public"."court_schedules" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."court_schedules" TO "authenticated";



GRANT ALL ON TABLE "public"."creator_earnings" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."creator_earnings" TO "authenticated";



GRANT ALL ON TABLE "public"."creator_migration_claims" TO "anon";
GRANT ALL ON TABLE "public"."creator_migration_claims" TO "authenticated";
GRANT ALL ON TABLE "public"."creator_migration_claims" TO "service_role";



GRANT ALL ON TABLE "public"."creator_yearly_payouts" TO "anon";
GRANT ALL ON TABLE "public"."creator_yearly_payouts" TO "authenticated";
GRANT ALL ON TABLE "public"."creator_yearly_payouts" TO "service_role";



GRANT ALL ON TABLE "public"."creators_over_600" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."creators_over_600" TO "authenticated";



GRANT ALL ON TABLE "public"."critical_alerts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."critical_alerts" TO "authenticated";



GRANT ALL ON TABLE "public"."daily_giveaways" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."daily_giveaways" TO "authenticated";



GRANT ALL ON TABLE "public"."daily_logins" TO "anon";
GRANT ALL ON TABLE "public"."daily_logins" TO "authenticated";
GRANT ALL ON TABLE "public"."daily_logins" TO "service_role";



GRANT ALL ON TABLE "public"."daily_rewards" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."daily_rewards" TO "authenticated";



GRANT ALL ON TABLE "public"."declined_transactions" TO "anon";
GRANT ALL ON TABLE "public"."declined_transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."declined_transactions" TO "service_role";



GRANT ALL ON TABLE "public"."deed_transfers" TO "anon";
GRANT ALL ON TABLE "public"."deed_transfers" TO "authenticated";
GRANT ALL ON TABLE "public"."deed_transfers" TO "service_role";



GRANT ALL ON TABLE "public"."deeds" TO "anon";
GRANT ALL ON TABLE "public"."deeds" TO "authenticated";
GRANT ALL ON TABLE "public"."deeds" TO "service_role";



GRANT ALL ON TABLE "public"."district_announcements" TO "anon";
GRANT ALL ON TABLE "public"."district_announcements" TO "authenticated";
GRANT ALL ON TABLE "public"."district_announcements" TO "service_role";



GRANT ALL ON TABLE "public"."district_features" TO "anon";
GRANT ALL ON TABLE "public"."district_features" TO "authenticated";
GRANT ALL ON TABLE "public"."district_features" TO "service_role";



GRANT ALL ON TABLE "public"."district_navigation" TO "anon";
GRANT ALL ON TABLE "public"."district_navigation" TO "authenticated";
GRANT ALL ON TABLE "public"."district_navigation" TO "service_role";



GRANT ALL ON TABLE "public"."earnings" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."earnings" TO "authenticated";



GRANT ALL ON TABLE "public"."economy_abuse_flags" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."economy_abuse_flags" TO "authenticated";



GRANT ALL ON TABLE "public"."economy_summary" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."economy_summary" TO "authenticated";



GRANT ALL ON TABLE "public"."empire_applications" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."empire_applications" TO "authenticated";



GRANT ALL ON TABLE "public"."empire_partner_rewards" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."empire_partner_rewards" TO "authenticated";



GRANT ALL ON TABLE "public"."empire_partners" TO "anon";
GRANT ALL ON TABLE "public"."empire_partners" TO "authenticated";
GRANT ALL ON TABLE "public"."empire_partners" TO "service_role";



GRANT ALL ON TABLE "public"."empire_referrals" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."empire_referrals" TO "authenticated";



GRANT ALL ON TABLE "public"."empire_rewards" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."empire_rewards" TO "authenticated";



GRANT ALL ON TABLE "public"."entrance_effect_catalog" TO "anon";
GRANT ALL ON TABLE "public"."entrance_effect_catalog" TO "authenticated";
GRANT ALL ON TABLE "public"."entrance_effect_catalog" TO "service_role";



GRANT ALL ON TABLE "public"."entrance_effects" TO "anon";
GRANT ALL ON TABLE "public"."entrance_effects" TO "authenticated";
GRANT ALL ON TABLE "public"."entrance_effects" TO "service_role";



GRANT ALL ON TABLE "public"."error_logs" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."error_logs" TO "authenticated";



GRANT ALL ON TABLE "public"."escalation_matrix" TO "anon";
GRANT ALL ON TABLE "public"."escalation_matrix" TO "authenticated";
GRANT ALL ON TABLE "public"."escalation_matrix" TO "service_role";



GRANT ALL ON TABLE "public"."escalation_reports" TO "service_role";
GRANT ALL ON TABLE "public"."escalation_reports" TO "authenticated";



GRANT ALL ON TABLE "public"."event_participants" TO "anon";
GRANT ALL ON TABLE "public"."event_participants" TO "authenticated";
GRANT ALL ON TABLE "public"."event_participants" TO "service_role";



GRANT ALL ON TABLE "public"."executive_intake" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."executive_intake" TO "authenticated";



GRANT ALL ON TABLE "public"."executive_reports" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."executive_reports" TO "authenticated";



GRANT ALL ON TABLE "public"."families" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."families" TO "authenticated";



GRANT ALL ON TABLE "public"."family_activity_log" TO "anon";
GRANT ALL ON TABLE "public"."family_activity_log" TO "authenticated";
GRANT ALL ON TABLE "public"."family_activity_log" TO "service_role";



GRANT ALL ON TABLE "public"."family_badges_earned" TO "anon";
GRANT ALL ON TABLE "public"."family_badges_earned" TO "authenticated";
GRANT ALL ON TABLE "public"."family_badges_earned" TO "service_role";



GRANT ALL ON TABLE "public"."family_boosts" TO "anon";
GRANT ALL ON TABLE "public"."family_boosts" TO "authenticated";
GRANT ALL ON TABLE "public"."family_boosts" TO "service_role";



GRANT ALL ON TABLE "public"."family_invites" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."family_invites" TO "authenticated";



GRANT ALL ON TABLE "public"."family_lounge_messages" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."family_lounge_messages" TO "authenticated";



GRANT ALL ON TABLE "public"."family_members" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."family_members" TO "authenticated";



GRANT ALL ON TABLE "public"."family_seasons" TO "anon";
GRANT ALL ON TABLE "public"."family_seasons" TO "authenticated";
GRANT ALL ON TABLE "public"."family_seasons" TO "service_role";



GRANT ALL ON TABLE "public"."family_shop_items" TO "anon";
GRANT ALL ON TABLE "public"."family_shop_items" TO "authenticated";
GRANT ALL ON TABLE "public"."family_shop_items" TO "service_role";



GRANT ALL ON TABLE "public"."family_shop_purchases" TO "anon";
GRANT ALL ON TABLE "public"."family_shop_purchases" TO "authenticated";
GRANT ALL ON TABLE "public"."family_shop_purchases" TO "service_role";



GRANT ALL ON TABLE "public"."family_stats" TO "anon";
GRANT ALL ON TABLE "public"."family_stats" TO "authenticated";
GRANT ALL ON TABLE "public"."family_stats" TO "service_role";



GRANT ALL ON TABLE "public"."family_tasks" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."family_tasks" TO "authenticated";



GRANT ALL ON TABLE "public"."family_tasks_new" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."family_tasks_new" TO "authenticated";



GRANT ALL ON TABLE "public"."family_war_stats" TO "anon";
GRANT ALL ON TABLE "public"."family_war_stats" TO "authenticated";
GRANT ALL ON TABLE "public"."family_war_stats" TO "service_role";



GRANT ALL ON TABLE "public"."family_wars" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."family_wars" TO "authenticated";



GRANT ALL ON TABLE "public"."follows" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."follows" TO "authenticated";



GRANT ALL ON TABLE "public"."ghost_presence_logs" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."ghost_presence_logs" TO "authenticated";



GRANT ALL ON TABLE "public"."gift_bonus_tracker" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."gift_bonus_tracker" TO "authenticated";



GRANT ALL ON TABLE "public"."gift_card_redemptions" TO "anon";
GRANT ALL ON TABLE "public"."gift_card_redemptions" TO "authenticated";
GRANT ALL ON TABLE "public"."gift_card_redemptions" TO "service_role";



GRANT ALL ON TABLE "public"."gift_cards" TO "anon";
GRANT ALL ON TABLE "public"."gift_cards" TO "authenticated";
GRANT ALL ON TABLE "public"."gift_cards" TO "service_role";



GRANT ALL ON TABLE "public"."gift_catalog" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."gift_catalog" TO "authenticated";



GRANT ALL ON TABLE "public"."gift_items" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."gift_items" TO "authenticated";



GRANT ALL ON TABLE "public"."gift_leaderboard_entries" TO "anon";
GRANT ALL ON TABLE "public"."gift_leaderboard_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."gift_leaderboard_entries" TO "service_role";



GRANT ALL ON TABLE "public"."gift_leaderboards" TO "anon";
GRANT ALL ON TABLE "public"."gift_leaderboards" TO "authenticated";
GRANT ALL ON TABLE "public"."gift_leaderboards" TO "service_role";



GRANT ALL ON TABLE "public"."gifts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."gifts" TO "authenticated";



GRANT ALL ON TABLE "public"."gift_ledger" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."gift_ledger" TO "authenticated";



GRANT ALL ON TABLE "public"."gift_transactions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."gift_transactions" TO "authenticated";



GRANT ALL ON TABLE "public"."gift_xp_stats" TO "anon";
GRANT ALL ON TABLE "public"."gift_xp_stats" TO "authenticated";
GRANT ALL ON TABLE "public"."gift_xp_stats" TO "service_role";



GRANT ALL ON TABLE "public"."giftcard_fulfillments" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."giftcard_fulfillments" TO "authenticated";



GRANT ALL ON TABLE "public"."gifts_owned" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."gifts_owned" TO "authenticated";



GRANT ALL ON TABLE "public"."group_chats" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."group_chats" TO "authenticated";



GRANT ALL ON TABLE "public"."hire_fire_actions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."hire_fire_actions" TO "authenticated";



GRANT ALL ON TABLE "public"."hire_limits" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."hire_limits" TO "authenticated";



GRANT ALL ON TABLE "public"."home_feature_cycles" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."home_feature_cycles" TO "authenticated";



GRANT ALL ON TABLE "public"."home_feature_spend" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."home_feature_spend" TO "authenticated";



GRANT ALL ON TABLE "public"."honorary_family_members" TO "anon";
GRANT ALL ON TABLE "public"."honorary_family_members" TO "authenticated";
GRANT ALL ON TABLE "public"."honorary_family_members" TO "service_role";



GRANT ALL ON TABLE "public"."hr_employees" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."hr_employees" TO "authenticated";



GRANT ALL ON TABLE "public"."hr_events" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."hr_events" TO "authenticated";



GRANT ALL ON TABLE "public"."hr_notes" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."hr_notes" TO "authenticated";



GRANT ALL ON TABLE "public"."identity_reward_logs" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."identity_reward_logs" TO "authenticated";



GRANT ALL ON TABLE "public"."incidents" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."incidents" TO "authenticated";



GRANT ALL ON TABLE "public"."insurance" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."insurance" TO "authenticated";



GRANT ALL ON TABLE "public"."insurance_logs" TO "anon";
GRANT ALL ON TABLE "public"."insurance_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."insurance_logs" TO "service_role";



GRANT ALL ON TABLE "public"."insurance_options" TO "anon";
GRANT ALL ON TABLE "public"."insurance_options" TO "authenticated";
GRANT ALL ON TABLE "public"."insurance_options" TO "service_role";



GRANT ALL ON TABLE "public"."insurance_packages" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."insurance_packages" TO "authenticated";



GRANT ALL ON TABLE "public"."insurance_plans" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."insurance_plans" TO "authenticated";



GRANT ALL ON TABLE "public"."interview_sessions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."interview_sessions" TO "authenticated";



GRANT ALL ON TABLE "public"."inventory_items" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."inventory_items" TO "authenticated";



GRANT ALL ON TABLE "public"."ip_bans" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."ip_bans" TO "authenticated";



GRANT ALL ON TABLE "public"."irs_threshold_tracking" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."irs_threshold_tracking" TO "authenticated";



GRANT ALL ON TABLE "public"."job_applications" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."job_applications" TO "authenticated";



GRANT ALL ON TABLE "public"."kick_logs" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."kick_logs" TO "authenticated";



GRANT ALL ON TABLE "public"."kick_logs_moderation" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."kick_logs_moderation" TO "authenticated";



GRANT ALL ON TABLE "public"."live_streams" TO "anon";
GRANT ALL ON TABLE "public"."live_streams" TO "authenticated";
GRANT ALL ON TABLE "public"."live_streams" TO "service_role";



GRANT ALL ON TABLE "public"."lucky_coin_events" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."lucky_coin_events" TO "authenticated";



GRANT ALL ON TABLE "public"."mai_appeals" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."mai_appeals" TO "authenticated";



GRANT ALL ON TABLE "public"."mai_incidents" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."mai_incidents" TO "authenticated";



GRANT ALL ON TABLE "public"."mai_overrides" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."mai_overrides" TO "authenticated";



GRANT ALL ON TABLE "public"."mai_timeline_events" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."mai_timeline_events" TO "authenticated";



GRANT ALL ON TABLE "public"."mai_user_memory" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."mai_user_memory" TO "authenticated";



GRANT ALL ON TABLE "public"."marketplace_items" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."marketplace_items" TO "authenticated";



GRANT ALL ON TABLE "public"."message_receipts" TO "anon";
GRANT ALL ON TABLE "public"."message_receipts" TO "authenticated";
GRANT ALL ON TABLE "public"."message_receipts" TO "service_role";



GRANT ALL ON TABLE "public"."message_requests" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."message_requests" TO "authenticated";



GRANT ALL ON TABLE "public"."messages" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."messages" TO "authenticated";



GRANT ALL ON TABLE "public"."millionaire_hall_of_fame" TO "anon";
GRANT ALL ON TABLE "public"."millionaire_hall_of_fame" TO "authenticated";
GRANT ALL ON TABLE "public"."millionaire_hall_of_fame" TO "service_role";



GRANT ALL ON TABLE "public"."moderation_actions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."moderation_actions" TO "authenticated";



GRANT ALL ON TABLE "public"."moderation_events" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."moderation_events" TO "authenticated";



GRANT ALL ON TABLE "public"."moderation_fee_settings" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."moderation_fee_settings" TO "authenticated";



GRANT ALL ON TABLE "public"."moderation_notes" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."moderation_notes" TO "authenticated";



GRANT ALL ON TABLE "public"."moderation_reports" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."moderation_reports" TO "authenticated";



GRANT ALL ON TABLE "public"."moderation_reports_view" TO "anon";
GRANT ALL ON TABLE "public"."moderation_reports_view" TO "authenticated";
GRANT ALL ON TABLE "public"."moderation_reports_view" TO "service_role";



GRANT ALL ON TABLE "public"."monthly_earnings_breakdown" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."monthly_earnings_breakdown" TO "authenticated";



GRANT ALL ON TABLE "public"."notifications" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."notifications" TO "authenticated";



GRANT ALL ON TABLE "public"."notifications_view" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."notifications_view" TO "authenticated";



GRANT ALL ON TABLE "public"."observer_ratings" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."observer_ratings" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_actions" TO "anon";
GRANT ALL ON TABLE "public"."officer_actions" TO "authenticated";
GRANT ALL ON TABLE "public"."officer_actions" TO "service_role";



GRANT ALL ON TABLE "public"."officer_activity" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_activity" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_applications" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_applications" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_availability" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_availability" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_badges" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_badges" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_chat" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_chat" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_earnings" TO "anon";
GRANT ALL ON TABLE "public"."officer_earnings" TO "authenticated";
GRANT ALL ON TABLE "public"."officer_earnings" TO "service_role";



GRANT ALL ON TABLE "public"."officer_hours" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_hours" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_live_assignments" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_live_assignments" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_logs" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_logs" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_mission_logs" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_mission_logs" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_monthly_payroll" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_monthly_payroll" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_orientation_results" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_orientation_results" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_orientations" TO "anon";
GRANT ALL ON TABLE "public"."officer_orientations" TO "authenticated";
GRANT ALL ON TABLE "public"."officer_orientations" TO "service_role";



GRANT ALL ON TABLE "public"."officer_payouts" TO "anon";
GRANT ALL ON TABLE "public"."officer_payouts" TO "authenticated";
GRANT ALL ON TABLE "public"."officer_payouts" TO "service_role";



GRANT ALL ON TABLE "public"."officer_performance" TO "anon";
GRANT ALL ON TABLE "public"."officer_performance" TO "authenticated";
GRANT ALL ON TABLE "public"."officer_performance" TO "service_role";



GRANT ALL ON TABLE "public"."officer_quiz_attempts" TO "service_role";
GRANT ALL ON TABLE "public"."officer_quiz_attempts" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_quiz_questions" TO "service_role";
GRANT ALL ON TABLE "public"."officer_quiz_questions" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_quiz_results" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_quiz_results" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_quiz_results_view" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_quiz_results_view" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_shift_slots" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_shift_slots" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_shifts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_shifts" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_stream_logs" TO "anon";
GRANT ALL ON TABLE "public"."officer_stream_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."officer_stream_logs" TO "service_role";



GRANT ALL ON TABLE "public"."officer_strikes" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_strikes" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_training_sessions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_training_sessions" TO "authenticated";



GRANT ALL ON TABLE "public"."officer_work_sessions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."officer_work_sessions" TO "authenticated";



GRANT ALL ON TABLE "public"."onboarding_events" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."onboarding_events" TO "authenticated";



GRANT ALL ON TABLE "public"."onboarding_progress" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."onboarding_progress" TO "authenticated";



GRANT ALL ON TABLE "public"."owc_transactions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."owc_transactions" TO "authenticated";



GRANT ALL ON TABLE "public"."payment_fees" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."payment_fees" TO "authenticated";



GRANT ALL ON TABLE "public"."payment_holds" TO "anon";
GRANT ALL ON TABLE "public"."payment_holds" TO "authenticated";
GRANT ALL ON TABLE "public"."payment_holds" TO "service_role";



GRANT ALL ON TABLE "public"."payment_logs" TO "anon";
GRANT ALL ON TABLE "public"."payment_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."payment_logs" TO "service_role";



GRANT ALL ON TABLE "public"."payment_methods" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."payment_methods" TO "authenticated";



GRANT ALL ON TABLE "public"."payment_transactions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."payment_transactions" TO "authenticated";



GRANT ALL ON TABLE "public"."payout_audit_log" TO "anon";
GRANT ALL ON TABLE "public"."payout_audit_log" TO "authenticated";
GRANT ALL ON TABLE "public"."payout_audit_log" TO "service_role";



GRANT ALL ON TABLE "public"."payout_history_view" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."payout_history_view" TO "authenticated";



GRANT ALL ON TABLE "public"."payout_reviews" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."payout_reviews" TO "authenticated";



GRANT ALL ON TABLE "public"."payout_settings" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."payout_settings" TO "authenticated";



GRANT ALL ON TABLE "public"."payouts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."payouts" TO "authenticated";



GRANT ALL ON TABLE "public"."perk_catalog" TO "anon";
GRANT ALL ON TABLE "public"."perk_catalog" TO "authenticated";
GRANT ALL ON TABLE "public"."perk_catalog" TO "service_role";



GRANT ALL ON TABLE "public"."perks" TO "anon";
GRANT ALL ON TABLE "public"."perks" TO "authenticated";
GRANT ALL ON TABLE "public"."perks" TO "service_role";



GRANT ALL ON TABLE "public"."platform_fees" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."platform_fees" TO "authenticated";



GRANT ALL ON TABLE "public"."platform_profit" TO "anon";
GRANT ALL ON TABLE "public"."platform_profit" TO "authenticated";
GRANT ALL ON TABLE "public"."platform_profit" TO "service_role";



GRANT ALL ON TABLE "public"."platform_revenue" TO "anon";
GRANT ALL ON TABLE "public"."platform_revenue" TO "authenticated";
GRANT ALL ON TABLE "public"."platform_revenue" TO "service_role";



GRANT ALL ON TABLE "public"."platform_wallet" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."platform_wallet" TO "authenticated";



GRANT ALL ON TABLE "public"."post_gifts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."post_gifts" TO "authenticated";



GRANT ALL ON TABLE "public"."posts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."posts" TO "authenticated";



GRANT ALL ON TABLE "public"."profiles" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."profiles" TO "authenticated";



GRANT ALL ON TABLE "public"."promo_code_uses" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."promo_code_uses" TO "authenticated";



GRANT ALL ON TABLE "public"."promo_codes" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."promo_codes" TO "authenticated";



GRANT ALL ON TABLE "public"."properties" TO "anon";
GRANT ALL ON TABLE "public"."properties" TO "authenticated";
GRANT ALL ON TABLE "public"."properties" TO "service_role";



GRANT ALL ON TABLE "public"."property_upgrades" TO "anon";
GRANT ALL ON TABLE "public"."property_upgrades" TO "authenticated";
GRANT ALL ON TABLE "public"."property_upgrades" TO "service_role";



GRANT ALL ON TABLE "public"."provider_costs" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."provider_costs" TO "authenticated";



GRANT ALL ON TABLE "public"."punishment_transactions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."punishment_transactions" TO "authenticated";



GRANT ALL ON TABLE "public"."punishments" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."punishments" TO "authenticated";



GRANT ALL ON TABLE "public"."referral_claims" TO "anon";
GRANT ALL ON TABLE "public"."referral_claims" TO "authenticated";
GRANT ALL ON TABLE "public"."referral_claims" TO "service_role";



GRANT ALL ON TABLE "public"."referral_monthly_bonus" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."referral_monthly_bonus" TO "authenticated";



GRANT ALL ON TABLE "public"."referrals" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."referrals" TO "authenticated";



GRANT ALL ON TABLE "public"."report_cases" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."report_cases" TO "authenticated";



GRANT ALL ON TABLE "public"."reputation_events" TO "anon";
GRANT ALL ON TABLE "public"."reputation_events" TO "authenticated";
GRANT ALL ON TABLE "public"."reputation_events" TO "service_role";



GRANT ALL ON TABLE "public"."revenue_ledger" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."revenue_ledger" TO "authenticated";



GRANT ALL ON TABLE "public"."revenue_settings" TO "anon";
GRANT ALL ON TABLE "public"."revenue_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."revenue_settings" TO "service_role";



GRANT ALL ON TABLE "public"."risk_events" TO "anon";
GRANT ALL ON TABLE "public"."risk_events" TO "authenticated";
GRANT ALL ON TABLE "public"."risk_events" TO "service_role";



GRANT ALL ON TABLE "public"."role_change_log" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."role_change_log" TO "authenticated";



GRANT ALL ON TABLE "public"."role_privileges" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."role_privileges" TO "authenticated";



GRANT ALL ON TABLE "public"."roles" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."roles" TO "authenticated";



GRANT ALL ON TABLE "public"."rooms" TO "anon";
GRANT ALL ON TABLE "public"."rooms" TO "authenticated";
GRANT ALL ON TABLE "public"."rooms" TO "service_role";



GRANT ALL ON TABLE "public"."royal_family_history" TO "anon";
GRANT ALL ON TABLE "public"."royal_family_history" TO "authenticated";
GRANT ALL ON TABLE "public"."royal_family_history" TO "service_role";



GRANT ALL ON TABLE "public"."royal_family_leaderboard" TO "anon";
GRANT ALL ON TABLE "public"."royal_family_leaderboard" TO "authenticated";
GRANT ALL ON TABLE "public"."royal_family_leaderboard" TO "service_role";



GRANT ALL ON TABLE "public"."royal_family_perks" TO "anon";
GRANT ALL ON TABLE "public"."royal_family_perks" TO "authenticated";
GRANT ALL ON TABLE "public"."royal_family_perks" TO "service_role";



GRANT ALL ON TABLE "public"."royal_family_titles" TO "anon";
GRANT ALL ON TABLE "public"."royal_family_titles" TO "authenticated";
GRANT ALL ON TABLE "public"."royal_family_titles" TO "service_role";



GRANT ALL ON TABLE "public"."scheduled_announcements" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."scheduled_announcements" TO "authenticated";



GRANT ALL ON TABLE "public"."secretary_assignments" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."secretary_assignments" TO "authenticated";



GRANT ALL ON TABLE "public"."security_events" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."security_events" TO "authenticated";



GRANT ALL ON TABLE "public"."seller_appeals_queue" TO "anon";
GRANT ALL ON TABLE "public"."seller_appeals_queue" TO "authenticated";
GRANT ALL ON TABLE "public"."seller_appeals_queue" TO "service_role";



GRANT ALL ON TABLE "public"."seller_reliability" TO "anon";
GRANT ALL ON TABLE "public"."seller_reliability" TO "authenticated";
GRANT ALL ON TABLE "public"."seller_reliability" TO "service_role";



GRANT ALL ON TABLE "public"."shadow_bans" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."shadow_bans" TO "authenticated";



GRANT ALL ON TABLE "public"."shifts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."shifts" TO "authenticated";



GRANT ALL ON TABLE "public"."shop_items" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."shop_items" TO "authenticated";



GRANT ALL ON TABLE "public"."shop_partners" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."shop_partners" TO "authenticated";



GRANT ALL ON TABLE "public"."shop_transactions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."shop_transactions" TO "authenticated";



GRANT ALL ON TABLE "public"."shops" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."shops" TO "authenticated";



GRANT ALL ON TABLE "public"."special_gift_earnings" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."special_gift_earnings" TO "authenticated";



GRANT ALL ON TABLE "public"."square_events" TO "anon";
GRANT ALL ON TABLE "public"."square_events" TO "authenticated";
GRANT ALL ON TABLE "public"."square_events" TO "service_role";



GRANT ALL ON TABLE "public"."staff_applications" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."staff_applications" TO "authenticated";



GRANT ALL ON TABLE "public"."staff_profiles" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."staff_profiles" TO "authenticated";



GRANT ALL ON TABLE "public"."store_items" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."store_items" TO "authenticated";



GRANT ALL ON TABLE "public"."stores" TO "anon";
GRANT ALL ON TABLE "public"."stores" TO "authenticated";
GRANT ALL ON TABLE "public"."stores" TO "service_role";



GRANT ALL ON TABLE "public"."stream_discovery_prefs" TO "anon";
GRANT ALL ON TABLE "public"."stream_discovery_prefs" TO "authenticated";
GRANT ALL ON TABLE "public"."stream_discovery_prefs" TO "service_role";



GRANT ALL ON TABLE "public"."stream_entrances" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_entrances" TO "authenticated";



GRANT ALL ON TABLE "public"."stream_entries" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_entries" TO "authenticated";



GRANT ALL ON TABLE "public"."stream_events" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_events" TO "authenticated";



GRANT ALL ON TABLE "public"."stream_gifts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_gifts" TO "authenticated";



GRANT ALL ON TABLE "public"."stream_join_requests" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_join_requests" TO "authenticated";



GRANT ALL ON TABLE "public"."stream_likes" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_likes" TO "authenticated";



GRANT ALL ON TABLE "public"."stream_messages" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_messages" TO "authenticated";



GRANT ALL ON TABLE "public"."stream_momentum" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_momentum" TO "authenticated";



GRANT ALL ON TABLE "public"."stream_mute_counts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_mute_counts" TO "authenticated";



GRANT ALL ON TABLE "public"."stream_passwords" TO "anon";
GRANT ALL ON TABLE "public"."stream_passwords" TO "authenticated";
GRANT ALL ON TABLE "public"."stream_passwords" TO "service_role";



GRANT ALL ON TABLE "public"."stream_presets" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_presets" TO "authenticated";



GRANT ALL ON TABLE "public"."stream_ranking" TO "anon";
GRANT ALL ON TABLE "public"."stream_ranking" TO "authenticated";
GRANT ALL ON TABLE "public"."stream_ranking" TO "service_role";



GRANT ALL ON TABLE "public"."stream_reactions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_reactions" TO "authenticated";



GRANT ALL ON TABLE "public"."stream_reports" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_reports" TO "authenticated";



GRANT ALL ON TABLE "public"."stream_sessions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_sessions" TO "authenticated";



GRANT ALL ON TABLE "public"."stream_snack_purchases" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_snack_purchases" TO "authenticated";



GRANT ALL ON TABLE "public"."stream_viewers" TO "anon";
GRANT ALL ON TABLE "public"."stream_viewers" TO "authenticated";
GRANT ALL ON TABLE "public"."stream_viewers" TO "service_role";



GRANT ALL ON TABLE "public"."stream_vods" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."stream_vods" TO "authenticated";



GRANT ALL ON TABLE "public"."streams_participants" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."streams_participants" TO "authenticated";



GRANT ALL ON TABLE "public"."support_tickets" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."support_tickets" TO "authenticated";



GRANT ALL ON TABLE "public"."system_alerts" TO "anon";
GRANT ALL ON TABLE "public"."system_alerts" TO "authenticated";
GRANT ALL ON TABLE "public"."system_alerts" TO "service_role";



GRANT ALL ON TABLE "public"."system_errors" TO "anon";
GRANT ALL ON TABLE "public"."system_errors" TO "authenticated";
GRANT ALL ON TABLE "public"."system_errors" TO "service_role";



GRANT ALL ON TABLE "public"."task_completions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."task_completions" TO "authenticated";



GRANT ALL ON TABLE "public"."task_history" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."task_history" TO "authenticated";



GRANT ALL ON TABLE "public"."task_templates" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."task_templates" TO "authenticated";



GRANT ALL ON TABLE "public"."tax_report_status" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."tax_report_status" TO "authenticated";



GRANT ALL ON TABLE "public"."ticket_messages" TO "anon";
GRANT ALL ON TABLE "public"."ticket_messages" TO "authenticated";
GRANT ALL ON TABLE "public"."ticket_messages" TO "service_role";



GRANT ALL ON TABLE "public"."training_scenarios" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."training_scenarios" TO "authenticated";



GRANT ALL ON TABLE "public"."transactions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."transactions" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_ai_avatars" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_ai_avatars" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_battle_gifts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_battle_gifts" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_court_cases" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_court_cases" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_dna_events" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_dna_events" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_dna_profiles" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_dna_profiles" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_dna_traits" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_dna_traits" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_drops" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_drops" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_drops_log" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_drops_log" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_event_claims" TO "anon";
GRANT ALL ON TABLE "public"."troll_event_claims" TO "authenticated";
GRANT ALL ON TABLE "public"."troll_event_claims" TO "service_role";



GRANT ALL ON TABLE "public"."troll_events" TO "anon";
GRANT ALL ON TABLE "public"."troll_events" TO "authenticated";
GRANT ALL ON TABLE "public"."troll_events" TO "service_role";



GRANT ALL ON TABLE "public"."troll_families" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_families" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_family_members" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_family_members" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_family_memberships" TO "anon";
GRANT ALL ON TABLE "public"."troll_family_memberships" TO "authenticated";
GRANT ALL ON TABLE "public"."troll_family_memberships" TO "service_role";



GRANT ALL ON TABLE "public"."troll_family_messages" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_family_messages" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_family_wars" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_family_wars" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_gift_items" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_gift_items" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_officer_applications" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_officer_applications" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_officers" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_officers" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_post_comments" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_post_comments" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_post_gifts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_post_gifts" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_post_reactions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_post_reactions" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_post_views" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_post_views" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_posts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_posts" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_stream_messages" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_stream_messages" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_streams" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_streams" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_wall_gifts" TO "anon";
GRANT ALL ON TABLE "public"."troll_wall_gifts" TO "authenticated";
GRANT ALL ON TABLE "public"."troll_wall_gifts" TO "service_role";



GRANT ALL ON TABLE "public"."troll_wall_gifts_summary" TO "anon";
GRANT ALL ON TABLE "public"."troll_wall_gifts_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."troll_wall_gifts_summary" TO "service_role";



GRANT ALL ON TABLE "public"."troll_wall_likes" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_wall_likes" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_wall_posts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_wall_posts" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_wall_posts_view" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."troll_wall_posts_view" TO "authenticated";



GRANT ALL ON TABLE "public"."troll_wall_reactions" TO "anon";
GRANT ALL ON TABLE "public"."troll_wall_reactions" TO "authenticated";
GRANT ALL ON TABLE "public"."troll_wall_reactions" TO "service_role";



GRANT ALL ON TABLE "public"."troll_wall_reactions_summary" TO "anon";
GRANT ALL ON TABLE "public"."troll_wall_reactions_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."troll_wall_reactions_summary" TO "service_role";



GRANT ALL ON TABLE "public"."trollcity_orders" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."trollcity_orders" TO "authenticated";



GRANT ALL ON TABLE "public"."trollcity_products" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."trollcity_products" TO "authenticated";



GRANT ALL ON TABLE "public"."trollcity_shops" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."trollcity_shops" TO "authenticated";



GRANT ALL ON TABLE "public"."trollmond_gifts" TO "anon";
GRANT ALL ON TABLE "public"."trollmond_gifts" TO "authenticated";
GRANT ALL ON TABLE "public"."trollmond_gifts" TO "service_role";



GRANT ALL ON TABLE "public"."trollmond_ledger" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."trollmond_ledger" TO "authenticated";



GRANT ALL ON TABLE "public"."trollmond_store_items" TO "anon";
GRANT ALL ON TABLE "public"."trollmond_store_items" TO "authenticated";
GRANT ALL ON TABLE "public"."trollmond_store_items" TO "service_role";



GRANT ALL ON TABLE "public"."trollmond_transactions" TO "anon";
GRANT ALL ON TABLE "public"."trollmond_transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."trollmond_transactions" TO "service_role";



GRANT ALL ON TABLE "public"."trollmonds_pools" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."trollmonds_pools" TO "authenticated";



GRANT ALL ON TABLE "public"."trolls_night_applications" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."trolls_night_applications" TO "authenticated";



GRANT ALL ON TABLE "public"."trollstown_properties" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."trollstown_properties" TO "authenticated";



GRANT ALL ON TABLE "public"."trollstown_property_upgrades" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."trollstown_property_upgrades" TO "authenticated";



GRANT ALL ON TABLE "public"."trollstown_upgrade_config" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."trollstown_upgrade_config" TO "authenticated";



GRANT ALL ON TABLE "public"."trolltract_contracts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."trolltract_contracts" TO "authenticated";



GRANT ALL ON TABLE "public"."trolltract_weekly_rewards" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."trolltract_weekly_rewards" TO "authenticated";



GRANT ALL ON TABLE "public"."tromody_battles" TO "anon";
GRANT ALL ON TABLE "public"."tromody_battles" TO "authenticated";
GRANT ALL ON TABLE "public"."tromody_battles" TO "service_role";



GRANT ALL ON TABLE "public"."tromody_gifts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."tromody_gifts" TO "authenticated";



GRANT ALL ON SEQUENCE "public"."tromody_gifts_id_seq" TO "service_role";
GRANT SELECT,USAGE ON SEQUENCE "public"."tromody_gifts_id_seq" TO "authenticated";



GRANT ALL ON TABLE "public"."tromody_matches" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."tromody_matches" TO "authenticated";



GRANT ALL ON TABLE "public"."tromody_queue" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."tromody_queue" TO "authenticated";



GRANT ALL ON TABLE "public"."tromody_sessions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."tromody_sessions" TO "authenticated";



GRANT ALL ON TABLE "public"."trophies" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."trophies" TO "authenticated";



GRANT ALL ON TABLE "public"."typing_statuses" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."typing_statuses" TO "authenticated";



GRANT ALL ON TABLE "public"."user_active_entrance_effect" TO "anon";
GRANT ALL ON TABLE "public"."user_active_entrance_effect" TO "authenticated";
GRANT ALL ON TABLE "public"."user_active_entrance_effect" TO "service_role";



GRANT ALL ON TABLE "public"."user_active_items" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user_active_items" TO "authenticated";



GRANT ALL ON TABLE "public"."user_badges_earned" TO "anon";
GRANT ALL ON TABLE "public"."user_badges_earned" TO "authenticated";
GRANT ALL ON TABLE "public"."user_badges_earned" TO "service_role";



GRANT ALL ON TABLE "public"."user_balances" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user_balances" TO "authenticated";



GRANT ALL ON TABLE "public"."user_bans" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user_bans" TO "authenticated";



GRANT ALL ON TABLE "public"."user_boosts" TO "anon";
GRANT ALL ON TABLE "public"."user_boosts" TO "authenticated";
GRANT ALL ON TABLE "public"."user_boosts" TO "service_role";



GRANT ALL ON TABLE "public"."user_broadcast_theme_purchases" TO "anon";
GRANT ALL ON TABLE "public"."user_broadcast_theme_purchases" TO "authenticated";
GRANT ALL ON TABLE "public"."user_broadcast_theme_purchases" TO "service_role";



GRANT ALL ON TABLE "public"."user_broadcast_theme_state" TO "anon";
GRANT ALL ON TABLE "public"."user_broadcast_theme_state" TO "authenticated";
GRANT ALL ON TABLE "public"."user_broadcast_theme_state" TO "service_role";



GRANT ALL ON TABLE "public"."user_call_sounds" TO "anon";
GRANT ALL ON TABLE "public"."user_call_sounds" TO "authenticated";
GRANT ALL ON TABLE "public"."user_call_sounds" TO "service_role";



GRANT ALL ON TABLE "public"."user_devices" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user_devices" TO "authenticated";



GRANT ALL ON TABLE "public"."user_district_progress" TO "anon";
GRANT ALL ON TABLE "public"."user_district_progress" TO "authenticated";
GRANT ALL ON TABLE "public"."user_district_progress" TO "service_role";



GRANT ALL ON TABLE "public"."user_entrance_effects" TO "anon";
GRANT ALL ON TABLE "public"."user_entrance_effects" TO "authenticated";
GRANT ALL ON TABLE "public"."user_entrance_effects" TO "service_role";



GRANT ALL ON TABLE "public"."user_entrances" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user_entrances" TO "authenticated";



GRANT ALL ON TABLE "public"."user_follows" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user_follows" TO "authenticated";



GRANT ALL ON TABLE "public"."user_insurance" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user_insurance" TO "authenticated";



GRANT ALL ON TABLE "public"."user_insurances" TO "anon";
GRANT ALL ON TABLE "public"."user_insurances" TO "authenticated";
GRANT ALL ON TABLE "public"."user_insurances" TO "service_role";



GRANT ALL ON TABLE "public"."user_inventory" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user_inventory" TO "authenticated";



GRANT ALL ON TABLE "public"."user_ip_tracking" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user_ip_tracking" TO "authenticated";



GRANT ALL ON TABLE "public"."user_levels" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user_levels" TO "authenticated";



GRANT ALL ON TABLE "public"."user_notifications" TO "anon";
GRANT ALL ON TABLE "public"."user_notifications" TO "authenticated";
GRANT ALL ON TABLE "public"."user_notifications" TO "service_role";



GRANT ALL ON TABLE "public"."user_payment_methods" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user_payment_methods" TO "authenticated";



GRANT ALL ON TABLE "public"."user_payout_settings" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user_payout_settings" TO "authenticated";



GRANT ALL ON TABLE "public"."user_perks" TO "anon";
GRANT ALL ON TABLE "public"."user_perks" TO "authenticated";
GRANT ALL ON TABLE "public"."user_perks" TO "service_role";



GRANT ALL ON TABLE "public"."user_reputation" TO "anon";
GRANT ALL ON TABLE "public"."user_reputation" TO "authenticated";
GRANT ALL ON TABLE "public"."user_reputation" TO "service_role";



GRANT ALL ON TABLE "public"."user_risk_profile" TO "anon";
GRANT ALL ON TABLE "public"."user_risk_profile" TO "authenticated";
GRANT ALL ON TABLE "public"."user_risk_profile" TO "service_role";



GRANT ALL ON TABLE "public"."user_roles" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user_roles" TO "authenticated";



GRANT ALL ON TABLE "public"."user_streamer_entitlements" TO "anon";
GRANT ALL ON TABLE "public"."user_streamer_entitlements" TO "authenticated";
GRANT ALL ON TABLE "public"."user_streamer_entitlements" TO "service_role";



GRANT ALL ON TABLE "public"."user_tax_info" TO "anon";
GRANT ALL ON TABLE "public"."user_tax_info" TO "authenticated";
GRANT ALL ON TABLE "public"."user_tax_info" TO "service_role";



GRANT ALL ON TABLE "public"."user_wallets" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."user_wallets" TO "authenticated";



GRANT ALL ON TABLE "public"."users" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."users" TO "authenticated";



GRANT ALL ON TABLE "public"."v_broadcast_themes_for_user" TO "anon";
GRANT ALL ON TABLE "public"."v_broadcast_themes_for_user" TO "authenticated";
GRANT ALL ON TABLE "public"."v_broadcast_themes_for_user" TO "service_role";



GRANT ALL ON TABLE "public"."v_kick_ban_revenue" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."v_kick_ban_revenue" TO "authenticated";



GRANT ALL ON TABLE "public"."v_payout" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."v_payout" TO "authenticated";



GRANT ALL ON TABLE "public"."v_total_liability" TO "anon";
GRANT ALL ON TABLE "public"."v_total_liability" TO "authenticated";
GRANT ALL ON TABLE "public"."v_total_liability" TO "service_role";



GRANT ALL ON TABLE "public"."vendor_invoices" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."vendor_invoices" TO "authenticated";



GRANT ALL ON TABLE "public"."verification_requests" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."verification_requests" TO "authenticated";



GRANT ALL ON TABLE "public"."verification_transactions" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."verification_transactions" TO "authenticated";



GRANT ALL ON TABLE "public"."videos" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."videos" TO "authenticated";



GRANT ALL ON TABLE "public"."visa_redemptions" TO "anon";
GRANT ALL ON TABLE "public"."visa_redemptions" TO "authenticated";
GRANT ALL ON TABLE "public"."visa_redemptions" TO "service_role";



GRANT ALL ON TABLE "public"."visa_redemptions_user_view" TO "anon";
GRANT ALL ON TABLE "public"."visa_redemptions_user_view" TO "authenticated";
GRANT ALL ON TABLE "public"."visa_redemptions_user_view" TO "service_role";



GRANT ALL ON TABLE "public"."wall_posts" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."wall_posts" TO "authenticated";



GRANT ALL ON TABLE "public"."war_results" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."war_results" TO "authenticated";



GRANT ALL ON TABLE "public"."wars" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."wars" TO "authenticated";



GRANT ALL ON TABLE "public"."web_push_subscriptions" TO "anon";
GRANT ALL ON TABLE "public"."web_push_subscriptions" TO "authenticated";
GRANT ALL ON TABLE "public"."web_push_subscriptions" TO "service_role";



GRANT ALL ON TABLE "public"."weekly_officer_reports" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."weekly_officer_reports" TO "authenticated";



GRANT ALL ON TABLE "public"."weekly_reports" TO "service_role";
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE "public"."weekly_reports" TO "authenticated";



GRANT ALL ON TABLE "public"."wheel_spins" TO "anon";
GRANT ALL ON TABLE "public"."wheel_spins" TO "authenticated";
GRANT ALL ON TABLE "public"."wheel_spins" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";


























